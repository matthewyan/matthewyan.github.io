<!DOCTYPE HTML>
<html lang="zh-Hnas" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Objective-C - 开发知识库</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Common/index.html"><strong aria-hidden="true">1.</strong> 通用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Common/Git.html"><strong aria-hidden="true">1.1.</strong> Git</a></li><li class="chapter-item expanded "><a href="../Common/VI.html"><strong aria-hidden="true">1.2.</strong> VI</a></li><li class="chapter-item expanded "><a href="../Common/Shell.html"><strong aria-hidden="true">1.3.</strong> Shell</a></li><li class="chapter-item expanded "><a href="../Common/Markdown.html"><strong aria-hidden="true">1.4.</strong> Markdown</a></li><li class="chapter-item expanded "><a href="../Common/Regex.html"><strong aria-hidden="true">1.5.</strong> 正则表达式</a></li><li class="chapter-item expanded "><a href="../Common/Test.html"><strong aria-hidden="true">1.6.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../Common/Database.html"><strong aria-hidden="true">1.7.</strong> 数据库</a></li><li class="chapter-item expanded "><a href="../Common/Network.html"><strong aria-hidden="true">1.8.</strong> 网络</a></li><li class="chapter-item expanded "><a href="../Common/Tools.html"><strong aria-hidden="true">1.9.</strong> 常用工具</a></li><li class="chapter-item expanded "><a href="../Common/Algorithm.html"><strong aria-hidden="true">1.10.</strong> 算法</a></li><li class="chapter-item expanded "><a href="../Common/Graphics.html"><strong aria-hidden="true">1.11.</strong> 图像视频处理</a></li><li class="chapter-item expanded "><a href="../Common/System.html"><strong aria-hidden="true">1.12.</strong> 底层相关</a></li><li class="chapter-item expanded "><a href="../Common/Secure.html"><strong aria-hidden="true">1.13.</strong> 安全</a></li><li class="chapter-item expanded "><a href="../Common/Web3.html"><strong aria-hidden="true">1.14.</strong> Web3.0</a></li><li class="chapter-item expanded "><a href="../Common/Other.html"><strong aria-hidden="true">1.15.</strong> 其它通用技术</a></li></ol></li><li class="chapter-item expanded "><a href="../Software/index.html"><strong aria-hidden="true">2.</strong> 软件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Software/Architecture.html"><strong aria-hidden="true">2.1.</strong> 软件架构</a></li><li class="chapter-item expanded "><a href="../Software/SoftwareDesign.html"><strong aria-hidden="true">2.2.</strong> 软件设计</a></li><li class="chapter-item expanded "><a href="../Software/DesignPattern.html"><strong aria-hidden="true">2.3.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="../Software/Document.html"><strong aria-hidden="true">2.4.</strong> 设计文档</a></li><li class="chapter-item expanded "><a href="../Software/Practice.html"><strong aria-hidden="true">2.5.</strong> 软件实践</a></li></ol></li><li class="chapter-item expanded "><a href="../iOS/index.html"><strong aria-hidden="true">3.</strong> iOS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../iOS/Performance.html"><strong aria-hidden="true">3.1.</strong> 性能相关</a></li><li class="chapter-item expanded "><a href="../iOS/UI.html"><strong aria-hidden="true">3.2.</strong> UI相关</a></li><li class="chapter-item expanded "><a href="../iOS/Swift.html"><strong aria-hidden="true">3.3.</strong> Swift</a></li><li class="chapter-item expanded "><a href="../iOS/ObjC.html" class="active"><strong aria-hidden="true">3.4.</strong> Objective-C</a></li><li class="chapter-item expanded "><a href="../iOS/SwiftUI.html"><strong aria-hidden="true">3.5.</strong> SwiftUI</a></li><li class="chapter-item expanded "><a href="../iOS/System.html"><strong aria-hidden="true">3.6.</strong> 底层相关</a></li><li class="chapter-item expanded "><a href="../iOS/Thread.html"><strong aria-hidden="true">3.7.</strong> 多线程</a></li><li class="chapter-item expanded "><a href="../iOS/WKWebview.html"><strong aria-hidden="true">3.8.</strong> WKWebview</a></li><li class="chapter-item expanded "><a href="../iOS/Sign.html"><strong aria-hidden="true">3.9.</strong> 签名相关</a></li><li class="chapter-item expanded "><a href="../iOS/Test.html"><strong aria-hidden="true">3.10.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../iOS/Device.html"><strong aria-hidden="true">3.11.</strong> 设备及系统</a></li><li class="chapter-item expanded "><a href="../iOS/Framework/index.html"><strong aria-hidden="true">3.12.</strong> 框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../iOS/Framework/Network.html"><strong aria-hidden="true">3.12.1.</strong> 网络</a></li><li class="chapter-item expanded "><a href="../iOS/Framework/ReactiveObjC.html"><strong aria-hidden="true">3.12.2.</strong> ReactiveObjC</a></li></ol></li><li class="chapter-item expanded "><a href="../iOS/Question.html"><strong aria-hidden="true">3.13.</strong> 问题集合</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/index.html"><strong aria-hidden="true">4.</strong> Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Detail.html"><strong aria-hidden="true">4.1.</strong> 详细介绍</a></li></ol></li><li class="chapter-item expanded "><a href="../Web/index.html"><strong aria-hidden="true">5.</strong> Web</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Web/HTML.html"><strong aria-hidden="true">5.1.</strong> HTML</a></li><li class="chapter-item expanded "><a href="../Web/CSS.html"><strong aria-hidden="true">5.2.</strong> CSS</a></li><li class="chapter-item expanded "><a href="../Web/JS.html"><strong aria-hidden="true">5.3.</strong> JS</a></li><li class="chapter-item expanded "><a href="../Web/TypeScript.html"><strong aria-hidden="true">5.4.</strong> TypeScript</a></li><li class="chapter-item expanded "><a href="../Web/React.html"><strong aria-hidden="true">5.5.</strong> React</a></li><li class="chapter-item expanded "><a href="../Web/Vue.html"><strong aria-hidden="true">5.6.</strong> Vue</a></li><li class="chapter-item expanded "><a href="../Web/WebAssembly.html"><strong aria-hidden="true">5.7.</strong> WebAssembly</a></li><li class="chapter-item expanded "><a href="../Web/CROS.html"><strong aria-hidden="true">5.8.</strong> 同源策略 & 跨域</a></li><li class="chapter-item expanded "><a href="../Web/Cookie.html"><strong aria-hidden="true">5.9.</strong> Cookie</a></li><li class="chapter-item expanded "><a href="../Web/DOM.html"><strong aria-hidden="true">5.10.</strong> DOM</a></li><li class="chapter-item expanded "><a href="../Web/JSEngine.html"><strong aria-hidden="true">5.11.</strong> JS引擎</a></li><li class="chapter-item expanded "><a href="../Web/Browser.html"><strong aria-hidden="true">5.12.</strong> 浏览器</a></li><li class="chapter-item expanded "><a href="../Web/Canvas.html"><strong aria-hidden="true">5.13.</strong> Canvas</a></li><li class="chapter-item expanded "><a href="../Web/MiniProgram.html"><strong aria-hidden="true">5.14.</strong> 小程序</a></li></ol></li><li class="chapter-item expanded "><a href="../Flutter/index.html"><strong aria-hidden="true">6.</strong> Flutter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Flutter/Reference.html"><strong aria-hidden="true">6.1.</strong> Flutter框架</a></li><li class="chapter-item expanded "><a href="../Flutter/Dart.html"><strong aria-hidden="true">6.2.</strong> Dart</a></li><li class="chapter-item expanded "><a href="../Flutter/Layout.html"><strong aria-hidden="true">6.3.</strong> 布局</a></li><li class="chapter-item expanded "><a href="../Flutter/Animation.html"><strong aria-hidden="true">6.4.</strong> 动画</a></li><li class="chapter-item expanded "><a href="../Flutter/Widgets.html"><strong aria-hidden="true">6.5.</strong> 组件</a></li><li class="chapter-item expanded "><a href="../Flutter/State.html"><strong aria-hidden="true">6.6.</strong> 状态管理</a></li><li class="chapter-item expanded "><a href="../Flutter/Theme.html"><strong aria-hidden="true">6.7.</strong> 主题</a></li><li class="chapter-item expanded "><a href="../Flutter/Source.html"><strong aria-hidden="true">6.8.</strong> 源码 & 原理</a></li><li class="chapter-item expanded "><a href="../Flutter/Test.html"><strong aria-hidden="true">6.9.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../Flutter/Performance.html"><strong aria-hidden="true">6.10.</strong> 性能相关</a></li><li class="chapter-item expanded "><a href="../Flutter/Web.html"><strong aria-hidden="true">6.11.</strong> Web开发</a></li><li class="chapter-item expanded "><a href="../Flutter/Desktop.html"><strong aria-hidden="true">6.12.</strong> Desktop开发</a></li></ol></li><li class="chapter-item expanded "><a href="../Server/index.html"><strong aria-hidden="true">7.</strong> 后台</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Server/Linux.html"><strong aria-hidden="true">7.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="../Server/Go.html"><strong aria-hidden="true">7.2.</strong> GO语言</a></li><li class="chapter-item expanded "><a href="../Server/NodeJS.html"><strong aria-hidden="true">7.3.</strong> Node.js</a></li><li class="chapter-item expanded "><a href="../Server/Docker.html"><strong aria-hidden="true">7.4.</strong> Docker</a></li></ol></li><li class="chapter-item expanded "><a href="../Language/index.html"><strong aria-hidden="true">8.</strong> 语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Language/Swift.html"><strong aria-hidden="true">8.1.</strong> Swift</a></li><li class="chapter-item expanded "><a href="../Language/Kotlin.html"><strong aria-hidden="true">8.2.</strong> Kotlin</a></li><li class="chapter-item expanded "><a href="../Language/Java.html"><strong aria-hidden="true">8.3.</strong> Java</a></li><li class="chapter-item expanded "><a href="../Language/Dart.html"><strong aria-hidden="true">8.4.</strong> Dart</a></li><li class="chapter-item expanded "><a href="../Language/CPP.html"><strong aria-hidden="true">8.5.</strong> C++</a></li><li class="chapter-item expanded "><a href="../Language/Rust.html"><strong aria-hidden="true">8.6.</strong> Rust</a></li><li class="chapter-item expanded "><a href="../Language/JS.html"><strong aria-hidden="true">8.7.</strong> JS</a></li><li class="chapter-item expanded "><a href="../Language/TypeScript.html"><strong aria-hidden="true">8.8.</strong> TypeScript</a></li><li class="chapter-item expanded "><a href="../Language/WebAssembly.html"><strong aria-hidden="true">8.9.</strong> WebAssembly</a></li><li class="chapter-item expanded "><a href="../Language/Haskell.html"><strong aria-hidden="true">8.10.</strong> Haskell</a></li><li class="chapter-item expanded "><a href="../Language/ArmAssembly.html"><strong aria-hidden="true">8.11.</strong> ARM汇编</a></li><li class="chapter-item expanded "><a href="../Language/Compiler.html"><strong aria-hidden="true">8.12.</strong> 编译器</a></li><li class="chapter-item expanded "><a href="../Language/Functional.html"><strong aria-hidden="true">8.13.</strong> 函数式编程</a></li></ol></li><li class="chapter-item expanded "><a href="../DevPlatform/index.html"><strong aria-hidden="true">9.</strong> 开发框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DevPlatform/RN/index.html"><strong aria-hidden="true">9.1.</strong> React Native</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DevPlatform/RN/Dev.html"><strong aria-hidden="true">9.1.1.</strong> RN开发</a></li><li class="chapter-item expanded "><a href="../DevPlatform/RN/Render.html"><strong aria-hidden="true">9.1.2.</strong> RN渲染</a></li><li class="chapter-item expanded "><a href="../DevPlatform/RN/flow.html"><strong aria-hidden="true">9.1.3.</strong> 时序图</a></li><li class="chapter-item expanded "><a href="../DevPlatform/RN/class.html"><strong aria-hidden="true">9.1.4.</strong> 类图</a></li></ol></li><li class="chapter-item expanded "><a href="../DevPlatform/Hippy.html"><strong aria-hidden="true">9.2.</strong> Hippy</a></li><li class="chapter-item expanded "><a href="../DevPlatform/Dynamic.html"><strong aria-hidden="true">9.3.</strong> 动态化</a></li><li class="chapter-item expanded "><a href="../DevPlatform/Sentry.html"><strong aria-hidden="true">9.4.</strong> Sentry</a></li></ol></li><li class="chapter-item expanded "><a href="../Note/index.html"><strong aria-hidden="true">10.</strong> 笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Note/10xWork.html"><strong aria-hidden="true">10.1.</strong> 10x程序员工作法</a></li><li class="chapter-item expanded "><a href="../Note/ProfessionalJS.html"><strong aria-hidden="true">10.2.</strong> JavaScript高级程序设计</a></li><li class="chapter-item expanded "><a href="../Note/XSW_ArchTech.html"><strong aria-hidden="true">10.3.</strong> 许式伟的架构课</a></li><li class="chapter-item expanded "><a href="../Note/DDD_Distilled.html"><strong aria-hidden="true">10.4.</strong> 领域驱动设计精粹</a></li><li class="chapter-item expanded "><a href="../Note/SoftwareDesign.html"><strong aria-hidden="true">10.5.</strong> 软件设计之美</a></li><li class="chapter-item expanded "><a href="../Note/DDDPractice.html"><strong aria-hidden="true">10.6.</strong> DDD实战课</a></li><li class="chapter-item expanded "><a href="../Note/DDDThoughtworks.html"><strong aria-hidden="true">10.7.</strong> 领域驱动设计综述(Thoughtworks洞见)</a></li><li class="chapter-item expanded "><a href="../Note/SoftwareArchitecture.html"><strong aria-hidden="true">10.8.</strong> 架构整洁之道</a></li><li class="chapter-item expanded "><a href="../Note/XPExplained.html"><strong aria-hidden="true">10.9.</strong> 解析极限编程</a></li><li class="chapter-item expanded "><a href="../Note/RustSwift.html"><strong aria-hidden="true">10.10.</strong> Rust / Swift对比</a></li></ol></li><li class="chapter-item expanded "><a href="../Article/READMD.html"><strong aria-hidden="true">11.</strong> 文章</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Article/SoftwareDesign.html"><strong aria-hidden="true">11.1.</strong> 浅谈软件设计</a></li><li class="chapter-item expanded "><a href="../Article/ExtremeProgramming.html"><strong aria-hidden="true">11.2.</strong> 解析极限编程</a></li><li class="chapter-item expanded "><a href="../Article/FunctionalProgramming.html"><strong aria-hidden="true">11.3.</strong> 浅谈函数式编程</a></li><li class="chapter-item expanded "><a href="../Article/DartIterableEffective.html"><strong aria-hidden="true">11.4.</strong> Dart中自定义Iterable高效操作</a></li><li class="chapter-item expanded "><a href="../Article/FlutterExperience.html"><strong aria-hidden="true">11.5.</strong> Flutter开发小结</a></li><li class="chapter-item expanded "><a href="../Article/Builder_Runner.html"><strong aria-hidden="true">11.6.</strong> builder_runner实现简介</a></li><li class="chapter-item expanded "><a href="../Article/Compiler_Parser.html"><strong aria-hidden="true">11.7.</strong> 词法&语法分析工具介绍</a></li><li class="chapter-item expanded "><a href="../Article/WKWebview_Cookie.html"><strong aria-hidden="true">11.8.</strong> WKWebview Cookie开发及需要注意的点</a></li></ol></li><li class="chapter-item expanded "><a href="../Other/index.html"><strong aria-hidden="true">12.</strong> 其它</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Other/Concept.html"><strong aria-hidden="true">12.1.</strong> 概念/术语</a></li><li class="chapter-item expanded "><a href="../Other/TechArticle.html"><strong aria-hidden="true">12.2.</strong> 技术文章概要</a></li><li class="chapter-item expanded "><a href="../Other/Design.html"><strong aria-hidden="true">12.3.</strong> 设计相关</a></li><li class="chapter-item expanded "><a href="../Other/Blog.html"><strong aria-hidden="true">12.4.</strong> 博客搭建</a></li><li class="chapter-item expanded "><a href="../Other/MacOS.html"><strong aria-hidden="true">12.5.</strong> MacOS</a></li><li class="chapter-item expanded "><a href="../Other/TechSolution.html"><strong aria-hidden="true">12.6.</strong> 业界方案</a></li><li class="chapter-item expanded "><a href="../Other/English.html"><strong aria-hidden="true">12.7.</strong> 英语</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发知识库</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="objective-c"><a class="header" href="#objective-c">Objective-C</a></h1>
<h3 id="资料"><a class="header" href="#资料">资料</a></h3>
<ul>
<li><a href="https://kangzubin.com/nullability-and-objective-c/">Objective-C 中 nullable、__nullable、_Nullable 的区别</a></li>
<li><a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></li>
<li><a href="https://nshipster.cn/__attribute__/">NSHipster <strong>attribute</strong></a></li>
<li><a href="https://juejin.cn/post/6844904101839372295">iOS底层原理：weak的实现原理</a>、<a href="https://mp.weixin.qq.com/s/OxePl6fBKYFOeL_tHN8UAA">探秘Weak实现原理</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">OC中参数类型定义</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/81449078">ARC 实现的原理</a></li>
<li><a href="https://zesming.com/oc-super/">简谈 OC 中陌生而又熟悉的 super</a>： <code>super</code> 是一个关键字，给 <code>super</code> 发消息实际上是一种调用继承链上父类实现的方法的方式</li>
</ul>
<h3 id="语法"><a class="header" href="#语法">语法</a></h3>
<h4 id="所有权"><a class="header" href="#所有权">所有权</a></h4>
<p>ARC下支持如下4种所有权：</p>
<ul>
<li>__strong</li>
<li>__weak</li>
<li>__unsafe_unretained</li>
<li>__autoreleasing (修饰当前变量，可以在当前autorelease pool结束时自动释放)</li>
</ul>
<h4 id="const的位置"><a class="header" href="#const的位置">const的位置</a></h4>
<p><a href="https://www.zhihu.com/question/443195492">C++里 const int* 与 int const* 有什么区别？</a></p>
<h4 id="import"><a class="header" href="#import">@import</a></h4>
<p><a href="https://medium.com/@Paris_Meta/include-import%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB-35d7d53f6af7">#include、#import 和 @import 的区别</a></p>
<ul>
<li>不需要像 #import 一样得手动去链接 Framework，@import 会自动去链接</li>
<li>@import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多</li>
<li>@import 导入 Modul 优化文件体积变大、编译速度变慢的问题</li>
<li>可以部分导入（@import Framework.A）或全部导入（@import Framework）</li>
</ul>
<h4 id="clang-attributes"><a class="header" href="#clang-attributes">Clang Attributes</a></h4>
<p><a href="https://blog.sunnyxx.com/2016/05/14/clang-attributes/">Clang Attributes 黑魔法小记</a></p>
<h4 id="kvc--kvo"><a class="header" href="#kvc--kvo">KVC / KVO</a></h4>
<p><a href="http://leejunhui.com/2020/02/15/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVC/">iOS 底层探索 - KVC</a></p>
<p>KVC: Key Value Coding，即可以通过Key来访问属性的机制：</p>
<pre><code class="language-objc">-(void)setValue:(id)value forKeyPath:(NSString *)keyPath;
-(void)setValue:(id)value forKey:(NSString *)key;
-(id)valueForKeyPath:(NSString *)keyPath;
-(id)valueForKey:(NSString *)key;
</code></pre>
<p><a href="https://juejin.cn/post/6844903593925935117">iOS底层原理总结 - 探寻KVO本质</a></p>
<p>KVO的核心原理是：iOS系统会修改这个对象的isa指针，改为指向一个全新的通过Runtime动态创建的子类，子类拥有自己的set方法实现，set方法实现内部会顺序调用willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。</p>
<h4 id="block"><a class="header" href="#block">Block</a></h4>
<p><a href="https://juejin.cn/post/6844904040954871815">OC中block的底层实现原理</a></p>
<p>Block本质是OC对象，内部也包含isa指针，以及一个函数指针，指向真正的block执行代码。</p>
<h3 id="runtime"><a class="header" href="#runtime">Runtime</a></h3>
<ul>
<li><a href="https://www.jianshu.com/u/988db278abcd">无忘无往的文章列表</a>：对Runtime讲解的非常清晰易读</li>
<li><a href="https://blog.csdn.net/businiao_zell/article/details/45872939">SEL类型数据和selector的用法</a>：SEL就是方法的包装，包含了调用地址</li>
<li><a href="https://tech.meituan.com/2015/08/12/deep-understanding-object-c-of-method-caching.html">深入理解 Objective-C：方法缓存</a></li>
<li><a href="https://blog.csdn.net/potato512/article/details/80947303">Runtime消息转发</a></li>
<li><a href="https://github.com/RetVal/objc-runtime">objc-runtime</a> | <a href="https://github.com/0xxd0/objc4">objc4</a>：可以调试的objc-runtime源代码</li>
<li><a href="https://huang-libo.github.io/posts/Objective-C-Runtime-Changes-in-iOS-14">【iOS 14】Objective-C Runtime 的优化</a></li>
</ul>
<h4 id="特点"><a class="header" href="#特点">特点</a></h4>
<p>将一些在编译和链接过程中的工作，放到了运行阶段。</p>
<ul>
<li>可以运行时新增类、方法、属性等</li>
<li>可以运行时交换两个方法</li>
<li>获得某个类所有成员方法、成员变量</li>
<li>可以通过<code>objc_copyClassList</code>或<code>objc_getClassList</code>获取所有已注册的类 (系统类有很多，在Demo中得到2W多个类) (<a href="https://www.jianshu.com/p/bf6c81fc2434">runtime使用篇: objc_getClassList 和 objc_copyClassList</a>)</li>
<li>运行时库跟系统是绑定的，也即不同系统上，其实现可能是不同的</li>
</ul>
<h4 id="hook"><a class="header" href="#hook">Hook</a></h4>
<p><a href="https://www.jianshu.com/p/86a0982398ca">基于iOS简单的hook原理及防护</a></p>
<p>Hook手段：</p>
<ul>
<li><code>Method Swizzle</code> (class_replaceMethod、method_exchangeImplementations)</li>
<li><code>fishhook</code></li>
</ul>
<blockquote>
<p>fishhook仅可以hook系统的c接口。</p>
</blockquote>
<p>反<code>Method Swizzle</code> Hook原理：使用fishhook修改<code>method_exchangeImplementations</code>指向自己的接口，在自己的接口中进行判断。</p>
<h4 id="分类"><a class="header" href="#分类">分类</a></h4>
<p><a href="https://tech.meituan.com/2015/03/03/diveintocategory.html">深入理解Objective-C：Category</a></p>
<ul>
<li>
<p>分类中的同名函数，是会覆盖原类的函数。</p>
</li>
<li>
<p>调用优先级：分类(category) &gt; 本类 &gt; 父类</p>
</li>
<li>
<p>如果两个扩展中，存在同名函数，则后编译的生效 (<a href="https://www.jianshu.com/p/39735f57443d">Category同名方法执行顺序</a>)</p>
</li>
<li>
<p>通过<code>class_addMethod</code>添加的方法，往往是最后添加的，其一般会最先调用</p>
</li>
<li>
<p>如果希望所有的同名函数都可以被调用到，可以通过<code>class_copyMethodList</code>拿到所有的函数，然后逐渐调用同名的接口。(该方法返回的顺序，就是调用查找的顺序)</p>
</li>
<li>
<p><code>class_copyMethodList</code>只会获取当前类的方法列表，父类的方法列表不会返回</p>
</li>
</ul>
<h4 id="对象--类实现"><a class="header" href="#对象--类实现">对象 &amp; 类实现</a></h4>
<p>所有的类、元类，都是运行时创建的。</p>
<ul>
<li>普通@interface定义的对象，都是从NSObject继承的。其存在一个属性，即<code>Class isa</code>。</li>
<li><code>Class</code>类型，是<code>struct objc_class</code>的定义</li>
<li><code>objc_class</code>继承自<code>objc_object</code></li>
<li><code>objc_class</code>中有三个成员
<ul>
<li><code>Class superclass</code>指向父类</li>
<li><code>cache_t cache</code>优化方法调用的cache</li>
<li><code>class_data_bits_t bits</code>标明Class的属性的</li>
</ul>
</li>
<li><code>objc_object</code>是Runtime层的对象。而类是一种特殊的对象，即对象的继承对象 (OC中id类型也是定义为该结构体类型)</li>
<li><code>objc_object</code>仅有一个<code>isa_t isa</code>属性</li>
<li><code>isa_t</code>是一个联合体，可能描述了对象的属性，也可能指向了一个类</li>
<li>元类不是父类</li>
</ul>
<p>示意图：（来源https://www.jianshu.com/p/b42db8b06088）</p>
<img src="./images/rt_objc_class.png" style="zoom:50%;" />
<h4 id="关键对象实现"><a class="header" href="#关键对象实现">关键对象实现</a></h4>
<pre><code class="language-c++">struct objc_object {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;
};

struct objc_class : objc_object {
    Class superclass;
    cache_t cache;             // 方法列表的缓存，调用过的方法会存储在这儿
    class_data_bits_t bits;    // 要找函数、属性等数据，要通过该字段获取
    ...
}
</code></pre>
<pre><code class="language-c++">struct class_data_bits_t {
    friend objc_class;

    // Values are the FAST_ flags above.
    uintptr_t bits;
  
    // 返回的class_rw_t中，包含了方法列表
    class_rw_t* data() const {
        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);
    }
    ...
}
</code></pre>
<pre><code class="language-c++">// https://www.jianshu.com/p/823eaedb3697
// class_rw_t和class_ro_t的专门解释
// class_rw_t存储的方法、属性等，是在运行时动态生成或变化的
struct class_rw_t {
    // Be warned that Symbolication knows the layout of this structure.
    uint32_t flags;
    uint16_t witness;
#if SUPPORT_INDEXED_ISA
    uint16_t index;
#endif

    explicit_atomic&lt;uintptr_t&gt; ro_or_rw_ext;

    Class firstSubclass;
    Class nextSiblingClass;
  
    using ro_or_rw_ext_t = objc::PointerUnion&lt;const class_ro_t, class_rw_ext_t, PTRAUTH_STR(&quot;class_ro_t&quot;), PTRAUTH_STR(&quot;class_rw_ext_t&quot;)&gt;;

    const ro_or_rw_ext_t get_ro_or_rwe() const {
        return ro_or_rw_ext_t{ro_or_rw_ext};
    }
  
    // 返回指向的class_ro_t结构
    const class_ro_t *ro() const { ... }
    // 返回指向的class_rw_ext_t结构
    class_rw_ext_t *ext() const { ... }
  
    // 返回方法列表 (其实是去class_rw_ext_t和class_ro_t结构中读取)
    const method_array_t methods() const {
        auto v = get_ro_or_rwe();
        if (v.is&lt;class_rw_ext_t *&gt;()) {
            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;methods;
        } else {
            return method_array_t{v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseMethods()};
        }
    }
  
    // 属性列表
    const property_array_t properties() const { ... }
    // 协议列表
    const protocol_array_t protocols() const { ... }
}
</code></pre>
<pre><code class="language-c++">// 编译期就已经决定好的了，运行时不会修改 (存储在clean memory中)
struct class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
#ifdef __LP64__
    uint32_t reserved;
#endif

    const uint8_t * ivarLayout;
    
    const char * name;
    WrappedPtr&lt;method_list_t, PtrauthStrip&gt; baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;
    ...
};
</code></pre>
<pre><code class="language-c++">// iOS14中新增的类型，为了优化内存
// https://huang-libo.github.io/posts/Objective-C-Runtime-Changes-in-iOS-14
struct class_rw_ext_t {
    DECLARE_AUTHED_PTR_TEMPLATE(class_ro_t)
    class_ro_t_authed_ptr&lt;const class_ro_t&gt; ro;
    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;
    char *demangledName;
    uint32_t version;
};
</code></pre>
<pre><code class="language-c++">struct method_t {
    static const uint32_t smallMethodListFlag = 0x80000000;

    method_t(const method_t &amp;other) = delete;

    // 核心数据
    struct big {
        SEL name;
        const char *types;
        MethodListIMP imp;	// 就是IMP类型，该地址就是该函数的实现，https://www.jianshu.com/p/27ee04f3ed7b 中有示例
    };
}
</code></pre>
<pre><code class="language-c++">// method_array_t，是一个二维数组，存放了方法列表的数组
class method_array_t : 
    public list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt;
{
    typedef list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; Super;

 public:
    method_array_t() : Super() { }
    method_array_t(method_list_t *l) : Super(l) { }

    const method_list_t_authed_ptr&lt;method_list_t&gt; *beginCategoryMethodLists() const {
        return beginLists();
    }
    
    const method_list_t_authed_ptr&lt;method_list_t&gt; *endCategoryMethodLists(Class cls) const;
};

</code></pre>
<pre><code class="language-c++">// Category生成的结构。这个结构数据，会在运行时被runtime合入到class_rw_t中(或class_rw_ext_t)
struct category_t {
    const char *name;
    classref_t cls;
    WrappedPtr&lt;method_list_t, PtrauthStrip&gt; instanceMethods;
    WrappedPtr&lt;method_list_t, PtrauthStrip&gt; classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
    // Fields below this point are not always present on disk.
    struct property_list_t *_classProperties;
    ...
};
</code></pre>
<h5 id="其它对象"><a class="header" href="#其它对象">其它对象</a></h5>
<ul>
<li><code>PointerUnion</code>：联合体指针，期内存储的值要么A，要么B (两个值互斥的情况使用)</li>
<li><code>list_array_tt</code>，可以用来存储一维或二维数组数据。(<a href="https://jianli2017.top/wiki/IOS/Runtime/objc/5list_array_tt/">list_array_tt 结构详解</a>)</li>
</ul>
<h4 id="消息方法"><a class="header" href="#消息方法">消息/方法</a></h4>
<ul>
<li>SEL定义为<code>struct objc_selector</code> （目前仅是一个字符串，苹果将其实现隐藏了）</li>
<li>不同类的同名方法（即使参数不同），它们的SEL也是相同的</li>
<li><code>sel_isEqual</code>可以用来判断两个SEL是否相同</li>
<li><code>@selector</code>及<code>sel_registerName</code>可以获取SEL方法选择器</li>
<li>IMP实际上是一个函数指针</li>
<li>在cache中存的是<code>method_t</code>类型，里面包含了SEL和IMP</li>
<li><code>class_copyMethodList</code>只会获取当前类的方法列表，父类的方法列表不会返回</li>
<li><code>super</code>会从继承链上找父类的方法实现，然后进行调用</li>
<li><code>objc_msgSend</code>可以直接调用某个类的某个方法 (<code>id objc_msgSend(id self, SEL _cmd, ...)</code>)</li>
<li><code>objc_msgSendSuper</code>可以直接调用某个父类的方法</li>
<li>消息调用时，会优先从<code>objc_class</code>的<code>cache_t</code>中查找方法。</li>
</ul>
<p>消息调用示意图：（来源：https://www.jianshu.com/p/782d7ce86d0f）</p>
<img src="./images/rt_method_forward.png" style="zoom:80%;" />
<h5 id="消息调用流程"><a class="header" href="#消息调用流程">消息调用流程</a></h5>
<ul>
<li>实例对象通过isa找到它的类对象</li>
<li>在类对象的缓存方法列表中寻找指定方法</li>
<li>如果缓存中没有，就到当前类的方法列表中寻找</li>
<li>如果方法列表中没有，就通过superclass到父类的方法列表中寻找</li>
<li>如果父类方法类别也没有，那么就动态解析（Method Resolution）</li>
<li>如果消息解析后还没找到，那么就消息转发（Method Forwarding）</li>
<li>如果还是没找到，程序就崩溃，如果2~6步骤中有一个找到，则返回对应的函数实现（IMP）</li>
</ul>
<blockquote>
<p>类方法的调用类似，但是是会去元类中找</p>
</blockquote>
<p>动态解析，需要重写NSObject的<code>resolveInstanceMethod</code>来实现</p>
<p>消息转发，可以分两步处理：</p>
<ul>
<li>先调用<code>forwardingTargetForSelector</code>，返回可以处理的对象</li>
<li>上面不响应，则调用<code>methodSignatureForSelector</code>，返回函数签名，然后调用<code>forwardInvocation</code></li>
</ul>
<p>流程参考：</p>
<p><img src="./images/method_forward.png" alt="" /></p>
<h3 id="runloop"><a class="header" href="#runloop">Runloop</a></h3>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></p>
<p>是一个运行循环，有事情时处理事情，没有事情时休眠。</p>
<p>作用：</p>
<ul>
<li>保持程序的持续运行g</li>
<li>处理各种事件</li>
<li>节省CPU资源，提高程序性能</li>
</ul>
<p>特点：</p>
<ul>
<li>一个线程对应一个Runloop</li>
<li>子线程Runloop的创建是发生在第一次获取时，Runloop的销毁是发生在线程结束时</li>
<li>一个Runloop中包含多个Mode</li>
<li>每个Mode包含若干个Source/Timer/Observer</li>
</ul>
<blockquote>
<p>Source主要用来跟其它线程互发消息使用</p>
<p>Observer可以监听：即将进入loop、即将处理timer、即将处理Source、即将进入休眠、刚从休眠中唤醒、即将退出loop这些事件。</p>
<p><code>performSelector:</code>异步执行某个接口时，其实现也是通过添加timer来做的。</p>
</blockquote>
<p>Runloop类型：</p>
<ul>
<li>NSDefaultRunLoopMode：默认的模式</li>
<li>UITrackingRunLoopMode：界面跟踪，用于scrollView拖拽滑动</li>
<li>NSRunLoopCommonModes：综合模式</li>
</ul>
<p>示意图：（来源：https://www.jianshu.com/p/d8c3a65b6e19）</p>
<img src="./images/runloop.png" style="zoom:80%;" />
<p>Timer与Runloop结合的使用：</p>
<ul>
<li>子线程中启动Timer，需要手动将其加入到当前runloop中</li>
<li>如果当前线程的runloop还没有启动过，还需要调用一下<code>run</code>接口</li>
<li>子线程释放Timer也需要注意，<code>timer.invalidate()</code>的调用线程要与Timer的创建线程是同一个</li>
</ul>
<h3 id="其它"><a class="header" href="#其它">其它</a></h3>
<h4 id="load-顺序"><a class="header" href="#load-顺序">+load 顺序</a></h4>
<ul>
<li>动态库<code>+load</code>最优先执行
<ul>
<li>跟加载顺序有关系</li>
</ul>
</li>
<li>主应用内<code>+load</code>其次执行
<ul>
<li>跟文件编译顺序有关系</li>
</ul>
</li>
<li>静态库<code>+load</code>最后执行
<ul>
<li>跟文件编译顺序有关系</li>
</ul>
</li>
</ul>
<p>具体类的load加载顺序：</p>
<ul>
<li>Super Class Load</li>
<li>Sub Class Load (多个Sub Class，哪个在Compile Sources排前面哪个先编译)</li>
<li>Category Class Load (与是否父类子类无关，完全由Compile Sources顺序决定，哪个排前面哪个先加载)</li>
</ul>
<h4 id="oc动态性"><a class="header" href="#oc动态性">OC动态性</a></h4>
<p>要给一个类动态添加方法有如下两种办法：</p>
<ul>
<li>通过Category来扩展 (Category与Extension是不一样的，Category是运行时添加的，而Extension是编译期确定的)</li>
<li>通过<code>class_addMethod</code>添加 (如果存在同名的方法，会返回<code>false</code>)</li>
</ul>
<h4 id="tagged-pointer"><a class="header" href="#tagged-pointer">Tagged Pointer</a></h4>
<ul>
<li><a href="https://swift.gg/2018/10/08/tagged-pointer-strings/">Tagged Pointer 字符串</a></li>
<li><a href="https://www.jianshu.com/p/df630e78df32">NSString存储管理--NSTaggedPointerString</a></li>
<li><a href="https://juejin.cn/post/6975765788355461133">Tagged Pointer对象安全气垫为何会失效</a></li>
</ul>
<p>Apple为了优化<code>NSNumber</code>、<code>NSString</code>等小对象所占用的空间，提供了该技术。在该技术实现中也考虑到缓冲区溢出等保护。</p>
<p>Tagged Pointer在存储时，也会对数据进行混淆。混淆的方式，即是通过生成的随机数作为因子。具体可参考：<a href="https://fangshufeng.github.io/2019/01/13/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84TaggedPointer/">你不知道的TaggedPointer</a></p>
<blockquote>
<p>在苹果的64位OC实现中，若对象指针的二进制第一位是1，则该指针为Tagged Pointer。
例如0xa000000000000311其中a的2进制为1010,第一位1表示这是Tagged Pointer，010表示这是一个NSTaggedPointerString类；这个地址最后一位表示字符串的数目，这里是0001表示有1位字符串；其中真正用来存储的位数只有中间的14位16进制。这个地址本身其实就存储了字符串的值，可以说是存储在&amp;strS内存中值，只是伪装成了地址，它不需要存储在数据区，也不需要申请堆空间。</p>
</blockquote>
<p>Tagged Pointer的实现也经过了多次修改，目前最新的实现中，那个标识放在了最低位。</p>
<h4 id="nsinvocation使用"><a class="header" href="#nsinvocation使用">NSInvocation使用</a></h4>
<p><a href="https://www.jianshu.com/p/6e8ae95adf83">iOS NSInvocation使用理解</a></p>
<p>关于NSInvocation，有如下特点：</p>
<ul>
<li>如果方法有2个参数，但调用时，只传一个参数，则第2个参数会给赋值默认值，并不会出异常 (比如NSString类型，拿到的就是nil，Int类型就是0)</li>
<li>如果方法有2个参数，但调用时传了3个参数，则会产生<code>NSInvalidArgumentException</code>的异常</li>
</ul>
<h4 id="swizzing特点"><a class="header" href="#swizzing特点">Swizzing特点</a></h4>
<ul>
<li>一个普通的OC方法，可以与可变参数的OC方法进行交换的。(但交换完，处理逻辑不好处理)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../iOS/Swift.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../iOS/SwiftUI.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../iOS/Swift.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../iOS/SwiftUI.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
