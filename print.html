<!DOCTYPE HTML>
<html lang="zh-Hnas" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>开发知识库</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Common/index.html"><strong aria-hidden="true">1.</strong> 通用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Common/Git.html"><strong aria-hidden="true">1.1.</strong> Git</a></li><li class="chapter-item expanded "><a href="Common/VI.html"><strong aria-hidden="true">1.2.</strong> VI</a></li><li class="chapter-item expanded "><a href="Common/Shell.html"><strong aria-hidden="true">1.3.</strong> Shell</a></li><li class="chapter-item expanded "><a href="Common/Markdown.html"><strong aria-hidden="true">1.4.</strong> Markdown</a></li><li class="chapter-item expanded "><a href="Common/Regex.html"><strong aria-hidden="true">1.5.</strong> 正则表达式</a></li><li class="chapter-item expanded "><a href="Common/Test.html"><strong aria-hidden="true">1.6.</strong> 测试</a></li><li class="chapter-item expanded "><a href="Common/VSCode.html"><strong aria-hidden="true">1.7.</strong> VSCode</a></li><li class="chapter-item expanded "><a href="Common/Database.html"><strong aria-hidden="true">1.8.</strong> 数据库</a></li><li class="chapter-item expanded "><a href="Common/Network.html"><strong aria-hidden="true">1.9.</strong> 网络</a></li><li class="chapter-item expanded "><a href="Common/Tools.html"><strong aria-hidden="true">1.10.</strong> 常用工具</a></li><li class="chapter-item expanded "><a href="Common/Algorithm.html"><strong aria-hidden="true">1.11.</strong> 算法</a></li><li class="chapter-item expanded "><a href="Common/Graphics.html"><strong aria-hidden="true">1.12.</strong> 图像处理</a></li><li class="chapter-item expanded "><a href="Common/OperateSystem.html"><strong aria-hidden="true">1.13.</strong> 操作系统</a></li><li class="chapter-item expanded "><a href="Common/Secure.html"><strong aria-hidden="true">1.14.</strong> 安全</a></li></ol></li><li class="chapter-item expanded "><a href="Software/index.html"><strong aria-hidden="true">2.</strong> 软件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Software/Architecture.html"><strong aria-hidden="true">2.1.</strong> 软件架构</a></li><li class="chapter-item expanded "><a href="Software/SoftwareDesign.html"><strong aria-hidden="true">2.2.</strong> 软件设计</a></li><li class="chapter-item expanded "><a href="Software/DesignPattern.html"><strong aria-hidden="true">2.3.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="Software/Document.html"><strong aria-hidden="true">2.4.</strong> 文档</a></li></ol></li><li class="chapter-item expanded "><a href="iOS/index.html"><strong aria-hidden="true">3.</strong> iOS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="iOS/Performance.html"><strong aria-hidden="true">3.1.</strong> 性能相关</a></li><li class="chapter-item expanded "><a href="iOS/UI.html"><strong aria-hidden="true">3.2.</strong> UI相关</a></li><li class="chapter-item expanded "><a href="iOS/Swift.html"><strong aria-hidden="true">3.3.</strong> Swift</a></li><li class="chapter-item expanded "><a href="iOS/ObjC.html"><strong aria-hidden="true">3.4.</strong> Objective-C</a></li><li class="chapter-item expanded "><a href="iOS/SwiftUI.html"><strong aria-hidden="true">3.5.</strong> SwiftUI</a></li><li class="chapter-item expanded "><a href="iOS/Runtime.html"><strong aria-hidden="true">3.6.</strong> Runtime</a></li><li class="chapter-item expanded "><a href="iOS/Thread.html"><strong aria-hidden="true">3.7.</strong> 多线程</a></li><li class="chapter-item expanded "><a href="iOS/Event.html"><strong aria-hidden="true">3.8.</strong> 事件相关</a></li><li class="chapter-item expanded "><a href="iOS/WKWebview.html"><strong aria-hidden="true">3.9.</strong> WKWebview</a></li><li class="chapter-item expanded "><a href="iOS/Scheme.html"><strong aria-hidden="true">3.10.</strong> Scheme</a></li><li class="chapter-item expanded "><a href="iOS/Sign.html"><strong aria-hidden="true">3.11.</strong> 签名相关</a></li><li class="chapter-item expanded "><a href="iOS/UnitTest.html"><strong aria-hidden="true">3.12.</strong> 单元测试</a></li><li class="chapter-item expanded "><a href="iOS/Device.html"><strong aria-hidden="true">3.13.</strong> 设备及系统</a></li><li class="chapter-item expanded "><a href="iOS/Framework/index.html"><strong aria-hidden="true">3.14.</strong> 框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="iOS/Framework/ReactiveObjC.html"><strong aria-hidden="true">3.14.1.</strong> ReactiveObjC</a></li><li class="chapter-item expanded "><a href="iOS/Framework/SDWebImage.html"><strong aria-hidden="true">3.14.2.</strong> SDWebImage</a></li></ol></li><li class="chapter-item expanded "><a href="iOS/Question.html"><strong aria-hidden="true">3.15.</strong> 问题集合</a></li></ol></li><li class="chapter-item expanded "><a href="Web/index.html"><strong aria-hidden="true">4.</strong> Web</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Web/HTML.html"><strong aria-hidden="true">4.1.</strong> HTML</a></li><li class="chapter-item expanded "><a href="Web/CSS.html"><strong aria-hidden="true">4.2.</strong> CSS</a></li><li class="chapter-item expanded "><a href="Web/JS.html"><strong aria-hidden="true">4.3.</strong> JS</a></li><li class="chapter-item expanded "><a href="Web/TypeScript.html"><strong aria-hidden="true">4.4.</strong> TypeScript</a></li><li class="chapter-item expanded "><a href="Web/React.html"><strong aria-hidden="true">4.5.</strong> React</a></li><li class="chapter-item expanded "><a href="Web/Vue.html"><strong aria-hidden="true">4.6.</strong> Vue</a></li><li class="chapter-item expanded "><a href="Web/WebAssembly.html"><strong aria-hidden="true">4.7.</strong> WebAssembly</a></li><li class="chapter-item expanded "><a href="Web/CROS.html"><strong aria-hidden="true">4.8.</strong> 同源策略 &amp; 跨域</a></li><li class="chapter-item expanded "><a href="Web/Cookie.html"><strong aria-hidden="true">4.9.</strong> Cookie</a></li><li class="chapter-item expanded "><a href="Web/DOM.html"><strong aria-hidden="true">4.10.</strong> DOM</a></li><li class="chapter-item expanded "><a href="Web/JSEngine.html"><strong aria-hidden="true">4.11.</strong> JS引擎</a></li><li class="chapter-item expanded "><a href="Web/Canvas.html"><strong aria-hidden="true">4.12.</strong> Canvas</a></li></ol></li><li class="chapter-item expanded "><a href="Flutter/index.html"><strong aria-hidden="true">5.</strong> Flutter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Flutter/Reference.html"><strong aria-hidden="true">5.1.</strong> Flutter框架</a></li><li class="chapter-item expanded "><a href="Flutter/Dart.html"><strong aria-hidden="true">5.2.</strong> Dart</a></li><li class="chapter-item expanded "><a href="Flutter/Layout.html"><strong aria-hidden="true">5.3.</strong> 布局</a></li><li class="chapter-item expanded "><a href="Flutter/Animation.html"><strong aria-hidden="true">5.4.</strong> 动画</a></li><li class="chapter-item expanded "><a href="Flutter/Widgets.html"><strong aria-hidden="true">5.5.</strong> 组件</a></li><li class="chapter-item expanded "><a href="Flutter/State.html"><strong aria-hidden="true">5.6.</strong> 状态管理</a></li><li class="chapter-item expanded "><a href="Flutter/Theme.html"><strong aria-hidden="true">5.7.</strong> 主题</a></li><li class="chapter-item expanded "><a href="Flutter/Source.html"><strong aria-hidden="true">5.8.</strong> 源码 &amp; 原理</a></li><li class="chapter-item expanded "><a href="Flutter/Test.html"><strong aria-hidden="true">5.9.</strong> 测试</a></li><li class="chapter-item expanded "><a href="Flutter/Performance.html"><strong aria-hidden="true">5.10.</strong> 性能相关</a></li><li class="chapter-item expanded "><a href="Flutter/Web.html"><strong aria-hidden="true">5.11.</strong> Web开发</a></li><li class="chapter-item expanded "><a href="Flutter/Desktop.html"><strong aria-hidden="true">5.12.</strong> Desktop开发</a></li></ol></li><li class="chapter-item expanded "><a href="Server/index.html"><strong aria-hidden="true">6.</strong> 后台</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Server/Linux.html"><strong aria-hidden="true">6.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="Server/Go.html"><strong aria-hidden="true">6.2.</strong> GO语言</a></li><li class="chapter-item expanded "><a href="Server/NodeJS.html"><strong aria-hidden="true">6.3.</strong> Node.js</a></li><li class="chapter-item expanded "><a href="Server/Docker.html"><strong aria-hidden="true">6.4.</strong> Docker</a></li><li class="chapter-item expanded "><a href="Server/K8S.html"><strong aria-hidden="true">6.5.</strong> K8S</a></li></ol></li><li class="chapter-item expanded "><a href="Language/index.html"><strong aria-hidden="true">7.</strong> 语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Language/Swift.html"><strong aria-hidden="true">7.1.</strong> Swift</a></li><li class="chapter-item expanded "><a href="Language/Dart.html"><strong aria-hidden="true">7.2.</strong> Dart</a></li><li class="chapter-item expanded "><a href="Language/CPP.html"><strong aria-hidden="true">7.3.</strong> C++</a></li><li class="chapter-item expanded "><a href="Language/Rust.html"><strong aria-hidden="true">7.4.</strong> Rust</a></li><li class="chapter-item expanded "><a href="Language/JS.html"><strong aria-hidden="true">7.5.</strong> JS</a></li><li class="chapter-item expanded "><a href="Language/TypeScript.html"><strong aria-hidden="true">7.6.</strong> TypeScript</a></li><li class="chapter-item expanded "><a href="Language/WebAssembly.html"><strong aria-hidden="true">7.7.</strong> WebAssembly</a></li><li class="chapter-item expanded "><a href="Language/Haskell.html"><strong aria-hidden="true">7.8.</strong> Haskell</a></li><li class="chapter-item expanded "><a href="Language/ArmAssembly.html"><strong aria-hidden="true">7.9.</strong> ARM汇编</a></li><li class="chapter-item expanded "><a href="Language/Compiler.html"><strong aria-hidden="true">7.10.</strong> 编译器</a></li><li class="chapter-item expanded "><a href="Language/Functional.html"><strong aria-hidden="true">7.11.</strong> 函数式编程</a></li></ol></li><li class="chapter-item expanded "><a href="CrossPlatform/index.html"><strong aria-hidden="true">8.</strong> 跨平台</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="CrossPlatform/ReactNative.html"><strong aria-hidden="true">8.1.</strong> React Native</a></li><li class="chapter-item expanded "><a href="CrossPlatform/Hippy.html"><strong aria-hidden="true">8.2.</strong> Hippy</a></li></ol></li><li class="chapter-item expanded "><a href="Note/index.html"><strong aria-hidden="true">9.</strong> 笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Note/10xWork.html"><strong aria-hidden="true">9.1.</strong> 10x程序员工作法</a></li><li class="chapter-item expanded "><a href="Note/ProfessionalJS.html"><strong aria-hidden="true">9.2.</strong> JavaScript高级程序设计</a></li><li class="chapter-item expanded "><a href="Note/XSW_ArchTech.html"><strong aria-hidden="true">9.3.</strong> 许式伟的架构课</a></li><li class="chapter-item expanded "><a href="Note/DDD_Distilled.html"><strong aria-hidden="true">9.4.</strong> 领域驱动设计精粹</a></li><li class="chapter-item expanded "><a href="Note/SoftwareDesign.html"><strong aria-hidden="true">9.5.</strong> 软件设计之美</a></li><li class="chapter-item expanded "><a href="Note/DDDPractice.html"><strong aria-hidden="true">9.6.</strong> DDD实战课</a></li><li class="chapter-item expanded "><a href="Note/DDDThoughtworks.html"><strong aria-hidden="true">9.7.</strong> 领域驱动设计综述(Thoughtworks洞见)</a></li><li class="chapter-item expanded "><a href="Note/SoftwareArchitecture.html"><strong aria-hidden="true">9.8.</strong> 架构整洁之道</a></li><li class="chapter-item expanded "><a href="Note/XPExplained.html"><strong aria-hidden="true">9.9.</strong> 解析极限编程</a></li><li class="chapter-item expanded "><a href="Note/RustSwift.html"><strong aria-hidden="true">9.10.</strong> Rust / Swift对比</a></li></ol></li><li class="chapter-item expanded "><a href="Article/READMD.html"><strong aria-hidden="true">10.</strong> 文章</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Article/SoftwareDesign.html"><strong aria-hidden="true">10.1.</strong> 浅谈软件设计</a></li><li class="chapter-item expanded "><a href="Article/ExtremeProgramming.html"><strong aria-hidden="true">10.2.</strong> 解析极限编程</a></li><li class="chapter-item expanded "><a href="Article/FunctionalProgramming.html"><strong aria-hidden="true">10.3.</strong> 浅谈函数式编程</a></li><li class="chapter-item expanded "><a href="Article/DartIterableEffective.html"><strong aria-hidden="true">10.4.</strong> Dart中自定义Iterable高效操作</a></li><li class="chapter-item expanded "><a href="Article/FlutterExperience.html"><strong aria-hidden="true">10.5.</strong> Flutter开发小结</a></li><li class="chapter-item expanded "><a href="Article/Builder_Runner.html"><strong aria-hidden="true">10.6.</strong> builder_runner实现简介</a></li><li class="chapter-item expanded "><a href="Article/Compiler_Parser.html"><strong aria-hidden="true">10.7.</strong> 词法&amp;语法分析工具介绍</a></li><li class="chapter-item expanded "><a href="Article/WKWebview_Cookie.html"><strong aria-hidden="true">10.8.</strong> WKWebview Cookie开发及需要注意的点</a></li></ol></li><li class="chapter-item expanded "><a href="Other/index.html"><strong aria-hidden="true">11.</strong> 其它</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Other/Concept.html"><strong aria-hidden="true">11.1.</strong> 概念/术语</a></li><li class="chapter-item expanded "><a href="Other/Design.html"><strong aria-hidden="true">11.2.</strong> 设计相关</a></li><li class="chapter-item expanded "><a href="Other/Blog.html"><strong aria-hidden="true">11.3.</strong> 博客搭建</a></li><li class="chapter-item expanded "><a href="Other/MacOS.html"><strong aria-hidden="true">11.4.</strong> MacOS</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发知识库</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="通用"><a class="header" href="#通用">通用</a></h1>
<h3 id="常用链接"><a class="header" href="#常用链接">常用链接</a></h3>
<ul>
<li><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li>
<li><a href="https://toutiao.io/">开发者头条</a></li>
<li><a href="https://github.com/SwiftOldDriver/iOS-Weekly/tree/master/Reports/2020">iOS老司机周报</a></li>
<li><a href="https://github.com/trending">Github每日趋势</a></li>
<li><a href="https://rustmagazine.github.io/rust_magazine_2021/index.html">Rust语言开源杂志</a></li>
</ul>
<h3 id="技术趋势"><a class="header" href="#技术趋势">技术趋势</a></h3>
<ul>
<li><a href="https://github.com/trending/">开源库趋势榜</a></li>
<li><a href="https://www.thoughtworks.com/cn/radar">Toughtworks技术雷达</a></li>
<li><a href="https://insights.thoughtworks.cn/">ThoughtWorks洞见</a></li>
</ul>
<h3 id="开发工具"><a class="header" href="#开发工具">开发工具</a></h3>
<ul>
<li><a href="https://david-smith.org/iosversionstats/">iOS系统版本占有率</a></li>
<li><a href="https://www.theiphonewiki.com/wiki/Models">设备定义</a></li>
<li><a href="http://aso.oa.com/keyword/sort">ASO搜索优化工具</a></li>
<li><a href="http://www.osstatus.com/">iOS错误码查询</a></li>
<li><a href="http://tool.chinaz.com/Tools/Unicode.aspx">Unicode转中文</a></li>
</ul>
<h3 id="其它工具"><a class="header" href="#其它工具">其它工具</a></h3>
<ul>
<li><a href="https://kahoot.it/">提供选项，进行竞猜</a></li>
<li><a href="https://app.sli.do/">在线收集反馈</a></li>
</ul>
<h3 id="服务"><a class="header" href="#服务">服务</a></h3>
<ul>
<li><a href="https://www.appsflyer.com/cn/">Appsflyer</a>：归因服务</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">git</a></h1>
<h3 id="资料"><a class="header" href="#资料">资料</a></h3>
<p><a href="https://learngitbranching.js.org/">git 入门小游戏</a></p>
<p><a href="https://www.git-scm.com/downloads/guis">git GUI工具</a></p>
<p><a href="https://git-scm.com/book/zh/v2">官方教程</a></p>
<p>​	</p>
<h3 id="clone"><a class="header" href="#clone">Clone</a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>git clone --depth=1 url</code></td><td>clone仓库，但git记录仅拉取深度为1的信息</td></tr>
<tr><td><code>git clone -b ${branch} --depth=1</code></td><td>当仓库用depth=1来拉取后，有些远程分支信息是没有的，此时可以拉对应远程分支</td></tr>
</tbody></table>
<h3 id="重置相关"><a class="header" href="#重置相关">重置相关</a></h3>
<h5 id="还未添加到暂存区"><a class="header" href="#还未添加到暂存区">还未添加到暂存区</a></h5>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>git checkout .</code></td><td>丢弃所有文件的修改</td></tr>
<tr><td><code>git checkout -- file</code></td><td>丢弃单个文件的修改</td></tr>
<tr><td><code>git clean -xdf</code></td><td>丢弃所有新增的文件</td></tr>
<tr><td><code>git clean -f a.txt</code></td><td>移除单个新增的文件</td></tr>
<tr><td><code>git checkout . &amp;&amp; git clean -xdf</code></td><td>丢弃所有修改</td></tr>
</tbody></table>
<h5 id="已添加到暂存区但还未提交"><a class="header" href="#已添加到暂存区但还未提交">已添加到暂存区，但还未提交</a></h5>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>git reset HEAD</code></td><td>将修改移回工作区</td></tr>
<tr><td><code>git reset --hard HEAD</code></td><td>将修改丢弃</td></tr>
</tbody></table>
<h5 id="已经commit但还未push"><a class="header" href="#已经commit但还未push">已经commit，但还未push</a></h5>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>git reset commitid</code></td><td>可以将commitid至HEAD之间的提交，全部移回到工作区</td></tr>
<tr><td><code>git reset --hard HEAD^</code></td><td>跳到上个结点 (HEAD^^跳到上上个结点)</td></tr>
</tbody></table>
<h5 id="已经push到远端的提交"><a class="header" href="#已经push到远端的提交">已经push到远端的提交</a></h5>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>git revert commitid</code></td><td>重置某次提交，会生成一条新的commit记录 (处理完<code>git push</code>即可)</td></tr>
<tr><td><code>git revert HEAD</code></td><td>将最新的提交revert掉</td></tr>
</tbody></table>
<p>还有一种不安全的方式：<code>git reset --hard commitID</code> 然后 <code>git push -f</code>。 表示先在本地重置到某次提交，然后强制将远端的记录用本地替换。</p>
<hr />
<p>​	</p>
<h3 id="分支相关"><a class="header" href="#分支相关">分支相关</a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>git checkout master</code></td><td>切换到本地已有的分支</td></tr>
<tr><td><code>git checkout -b new_branch</code></td><td>新建一个分支，并切换至该分支</td></tr>
<tr><td><code>git branch name</code></td><td>从当前分支创建一个新分支，但不切换</td></tr>
<tr><td><code>git branch -a</code></td><td>查看所有分支，包括远端分支</td></tr>
<tr><td><code>git branch -v</code></td><td>查看本地分支跟踪的远程分支信息</td></tr>
<tr><td><code>git branch -u origin/master</code></td><td>设置远程分支跟踪 (<code>-u</code>与<code>--set-upstream-to</code>等同)</td></tr>
<tr><td><code>git merge --no-ff develop</code></td><td>在merge指定分支时，生成一个合并结点 (即禁用<code>Fast-Forward</code>)</td></tr>
<tr><td><code>git push origin branch_name:branch_name</code></td><td>推送本地分支至远程（在远程会创建该分支）</td></tr>
<tr><td><code>git branch -d branch_name</code></td><td>删除本地分支</td></tr>
<tr><td><code>git branch -D branch_name</code></td><td>强制删除本地分支</td></tr>
<tr><td><code>git push origin --delete branch_name</code></td><td>删除远程分支</td></tr>
<tr><td><code>git cherry-pick commitid</code></td><td>选择一个 commit，合并进当前分支</td></tr>
</tbody></table>
<hr />
<h3 id="多仓库操作"><a class="header" href="#多仓库操作">多仓库操作</a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>git remote add another ***</code></td><td>添加另外一个仓库地址至本仓库，别名为another</td></tr>
<tr><td><code>git remote rm another</code></td><td>删除别名为another的仓库地址</td></tr>
<tr><td><code>git remote show origin</code></td><td>查看默认跟踪的源</td></tr>
<tr><td><code>git push -u origin master</code></td><td>推送至指定远程仓库的指定分支</td></tr>
<tr><td><code>git pull origin master</code></td><td>拉取指定远程仓库的指定分支</td></tr>
</tbody></table>
<hr />
<h3 id="储藏区操作"><a class="header" href="#储藏区操作">储藏区操作</a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>git stash</code></td><td>将工作区的修改添加至储藏区</td></tr>
<tr><td><code>git stash list</code></td><td>查看储藏区内容</td></tr>
<tr><td><code>git stash pop</code></td><td>将最上面的储藏内容应用至工作区，并删除这条储藏记录</td></tr>
<tr><td><code>git stash apply</code></td><td>将最上面的储藏内容应用至工作区，并保留这条储藏记录</td></tr>
<tr><td><code>git stash apply stash@{0}</code></td><td>应用指定的储藏记录</td></tr>
</tbody></table>
<blockquote>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E8%B4%AE%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86">Git 工具 - 贮藏与清理</a></p>
</blockquote>
<hr />
<p>​	</p>
<h3 id="冲突相关"><a class="header" href="#冲突相关">冲突相关</a></h3>
<p>在merge冲突后，修复完冲突，需要执行如下指令：</p>
<pre><code class="language-shell"># 2和3只需要执行一个就好，git merge --continue会填上默认的merge信息
1. git add *		# 将修改添加
2. git commit -m *	# 将修改提交
3. git merge --continue	# 继续执行流程
</code></pre>
<p>如果不想继续解决冲突，则：</p>
<pre><code class="language-shell">git merge --abort
</code></pre>
<p>rebase冲突后，类似</p>
<pre><code class="language-shell">git add *	# 标识冲突已解决 // rebase不需要commit
git rebase --continue	# 继续执行流程
git rebase --abort	# 中止rebase
</code></pre>
<p>在冲突解决时，要注意ours和theirs的含义：</p>
<blockquote>
<p>merge时，ours表示当前分支，theirs表示被合并分支</p>
<p>rebase时，theirs表示当前分支，ours是表示被rebase的分支</p>
</blockquote>
<p>参考：<a href="https://bitmingw.com/2017/02/16/git-merge-rebase-ours-and-theirs/">化解冲突：git merge 与 git rebase 中的 ours 和 theirs</a></p>
<hr />
<p>​	</p>
<h3 id="submodule"><a class="header" href="#submodule">SubModule</a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>git submodule init</code></td><td>初始化工程 (新clone的代码，要更新submodule，也需要调用这个命令)</td></tr>
<tr><td><code>git submodule update</code></td><td>更新submodule代码</td></tr>
<tr><td><code>git submodule add https://gitrepo.git directory</code></td><td>添加submodule到当前工程</td></tr>
<tr><td><code>git push origin HEAD:master</code></td><td>推送修改的代码至远端仓库指定分支</td></tr>
</tbody></table>
<p>submodule相关信息，存储在了<code>.gitmodules</code>文件中</p>
<p>要删除某个submodule，参考：<a href="https://gist.github.com/myusuf3/7f645819ded92bda6677">delete_git_submodule.md</a></p>
<hr />
<p>​	</p>
<h3 id="subtree"><a class="header" href="#subtree">SubTree</a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>git subtree add --prefix=Path http://gitrepo.git master --squash</code></td><td>添加subtree</td></tr>
<tr><td><code>git subtree pull --prefix=Path http://gitrepo.git master --squash</code></td><td>更新代码</td></tr>
<tr><td><code>git subtree split --rejoin push --prefix=Path http://gitrepo.git master</code></td><td>推送代码</td></tr>
</tbody></table>
<p>要查看subtree仓库有哪些，可以使用：</p>
<pre><code class="language-shell">git log | grep git-subtree-dir | tr -d ' ' | cut -d &quot;:&quot; -f2 | sort | uniq
</code></pre>
<blockquote>
<p>如果在推送时，不使用<code>--rejoin</code>选项，可能会耗时很久</p>
</blockquote>
<p>SubTree设置为一个仓库和分支之后，仍然可以随时修改为另一个仓库或分支</p>
<hr />
<p>​	</p>
<h3 id="其它命令"><a class="header" href="#其它命令">其它命令</a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>git reflog</code></td><td>查看有执行的记录</td></tr>
<tr><td><code>git show</code></td><td>查看最近一次提交的修改</td></tr>
<tr><td><code>git show commitID</code></td><td>查看指定commitID的修改</td></tr>
<tr><td><code>git show commit file</code></td><td>查看某次，某个文件的修改</td></tr>
<tr><td><code>git fetch --all &amp;&amp; git reset --hard origin/master</code></td><td>重置本地所有修改，并更新到远端仓库的最新代码</td></tr>
<tr><td><code>git config --global https.proxy http://127.0.0.1</code></td><td>配置git全局代理</td></tr>
<tr><td><code>git config --global --unset http.proxy</code></td><td>清理掉git全局代理</td></tr>
<tr><td><code>git config [--global] user.email &quot;email@example.com&quot;</code></td><td>配置本地或全局仓库的用户邮箱</td></tr>
</tbody></table>
<hr />
<h3 id="mergerebase区别"><a class="header" href="#mergerebase区别">Merge、Rebase区别</a></h3>
<blockquote>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">Git 分支 - 变基</a></p>
</blockquote>
<ul>
<li>在无法fast-forward时，Merge会生成一条新的合并记录 （当前分支/目标分支/共同祖先，共同生成）</li>
<li>Rebase会把目标分支所有提交拿过来应用到当前分支上，当前分支的修改会放在最新的提交历史上</li>
<li>git pull与git pull -r的区别，也是merge/rebase的区别。当用git pull时，如果本地和远端都有修改，则会生成一条新的merge记录</li>
</ul>
<hr />
<p>​	</p>
<h3 id="alias配置"><a class="header" href="#alias配置">alias配置</a></h3>
<p>打开或新建.gitconfig文件：<code>vi ~/.gitconfig</code>  (<a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732837407424">配置别名</a>)</p>
<p>加上如下内容:</p>
<pre><code class="language-sh">[alias]
        st = status
        co = checkout
        ci = commit
        br = branch
        pr = pull -r
        lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit
        ls-subtrees = !&quot;git log | grep git-subtree-dir | tr -d ' ' | cut -d &quot;:&quot; -f2 | sort | uniq&quot;
</code></pre>
<p>此时就可以使用 git ci -m &quot;msg&quot; 来提交代码了</p>
<hr />
<h3 id="高阶使用"><a class="header" href="#高阶使用">高阶使用</a></h3>
<h4 id="修改已提交代码的日志"><a class="header" href="#修改已提交代码的日志">修改已提交代码的日志</a></h4>
<ol>
<li>
<p><code>git rebase -i HEAD~2</code>	# 表示修改近两次的提交</p>
</li>
<li>
<p>指定哪些提交信息要被修改，如果两个都要修改，则要将pick修改为edit</p>
<pre><code class="language-console">pick f7f3f6d message1
pick 310154e message2
</code></pre>
<p>修改为：</p>
<pre><code class="language-console">edit f7f3f6d message1
edit 310154e message2
</code></pre>
</li>
<li>
<p>保存退出，则控制台会提示操作某次修改，此时输入<code>git commit --amend</code>，就可以针对一次提交进行编辑</p>
</li>
<li>
<p>保存退出，则提示某次修改成功，然后执行 <code>git rebase --continue</code></p>
</li>
<li>
<p>会提示进行下一次的操作修改，此时继续输入 <code>git commit --amend</code>，重复刚才的操作</p>
</li>
<li>
<p>当都修改完后，仍然需要继续执行一次 <code>git rebase --continue</code>，才能最终结束</p>
</li>
</ol>
<p>参考：<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2">Git 工具 - 重写历史</a></p>
<h4 id="合并多次提交至一次提交"><a class="header" href="#合并多次提交至一次提交">合并多次提交至一次提交</a></h4>
<ol>
<li>
<p><code>git rebase -i HEAD~2</code> # 合并最近两次提交</p>
</li>
<li>
<p>修改合并操作 (s表示squash，跟前一个提交合并，Message1为更早提交的)</p>
<pre><code class="language-console">p a4658c8 Message1
s ae2e0fa Message2
</code></pre>
</li>
<li>
<p>保存退出，正常情况下就完成了</p>
</li>
</ol>
<p>但需要注意的是，已经push到远端的提交，不能使用这个操作。如果这样操作了，修改会无法push到远端的</p>
<p>参考：<a href="http://jartto.wang/2018/12/11/git-rebase/">彻底搞懂 Git-Rebase</a>，文章里有一点错误，p和s操作顺序写反了，要注意下这儿。</p>
<h4 id="统计指定日期之后的提交次数"><a class="header" href="#统计指定日期之后的提交次数">统计指定日期之后的提交次数</a></h4>
<p>这种方法可以查看指定版本或灰度版本之后，进行的修改次数，以评估风险 (该命令过滤掉了merge的记录)</p>
<p><code> git log --since=&quot;2020-06-25&quot; --no-merges | grep -e 'commit [a-zA-Z0-9]*' | wc -l</code></p>
<h3 id="其它"><a class="header" href="#其它">其它</a></h3>
<h4 id="git工作流"><a class="header" href="#git工作流">Git工作流</a></h4>
<ul>
<li>Git Flow: 现在较多的终端开发模式。长期存在master、develop分支，发布时就拉发布分支，fix版本拉bugfix分支。</li>
<li>Github flow: 只存在一个master长期分支，功能开发、修改Bug，都拉分支操作，最后再PR回master。</li>
<li>Gitlab flow: 也只有一个master长期分支，但强调“上游分支”的概念。代码的变化，必须由“上游”向“下游”发展。</li>
</ul>
<p>参考：<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a></p>
<h3 id="有趣的使用"><a class="header" href="#有趣的使用">有趣的使用</a></h3>
<h4 id="本地仓库使用"><a class="header" href="#本地仓库使用">本地仓库使用</a></h4>
<ul>
<li>假设本地有一个ARepo的仓库，可以直接通过 <code>git clone ./ARepo ./BRepo</code> 来clone一个新的仓库</li>
<li>通过 <code>git clone ./ARepo ./BRepo</code> clone的BRepo的远端分支默认就是ARepo，git pull / git push默认也都是可以使用的</li>
<li>默认创建的ARepo，是无法往里面推送代码的，需要在ARepo下的<code>.git/config</code>中添加denyCurrentBranch配置 (<a href="https://blog.csdn.net/yuhuafeixian/article/details/77679930">git push首次提交报错denyCurrentBranch</a>)</li>
<li>本地作为共享的仓库，最好用<code>git init --bare</code>来初始化，这种仓库是没有工作区的，以免其它仓库推送代码过来之后，会导致当前工作区中代码很多变为修改状态</li>
</ul>
<h4 id="reflog的使用"><a class="header" href="#reflog的使用">Reflog的使用</a></h4>
<ul>
<li><code>git reflog</code>可以查看所有操作记录</li>
<li>通过reflog可以在操作记录中任意跳转。如果跳到历史的一个记录，再进行新的提交，就可以认为时间线分叉了，然后可以通过<code>git reset --hard commitid</code>来在不同时间线上跳，但一个时刻只能保持一个时间线。并且没办法合并两个不同</li>
</ul>
<h4 id="lfs使用"><a class="header" href="#lfs使用">LFS使用</a></h4>
<p><a href="https://zzz.buzz/zh/2016/04/19/the-guide-to-git-lfs/">Git LFS 操作指南</a></p>
<h4 id="git-commitizen"><a class="header" href="#git-commitizen">git commitizen</a></h4>
<ul>
<li><code>npm i -g commitizen &amp;&amp; npm i -g cz-conventional-changelog</code></li>
<li><code>echo '{ &quot;path&quot;: &quot;cz-conventional-changelog&quot; }' &gt; ~/.czrc</code></li>
</ul>
<p>即可使用<code>git cz</code>提交代码，使用更规范的提交日志。</p>
<h3 id="原理"><a class="header" href="#原理">原理</a></h3>
<ul>
<li><a href="https://www.jiqizhixin.com/articles/2019-12-20">这才是真正的Git——Git内部原理揭秘！</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim"><a class="header" href="#vim">VIM</a></h1>
<h4 id="跳转"><a class="header" href="#跳转">跳转</a></h4>
<table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody>
<tr><td><code>10G</code> / <code>10gg</code></td><td>可以跳转到第10行 (<code>G</code>跳转至最后、<code>gg</code>跳转至最开头)</td></tr>
<tr><td><code>ctrl-w-w</code></td><td>在多个内部窗口之间跳转</td></tr>
<tr><td><code>0</code></td><td>移动光标到行首 (同 <code>^</code> )</td></tr>
<tr><td><code>w</code> / <code>b</code></td><td><code>w</code>移动光标到下一个单词的开始位置 ( <code>2w</code> 移到下下个单词开始位置)。<code>b</code>为前移</td></tr>
<tr><td><code>e</code></td><td>移到光标到当前单词的末尾</td></tr>
<tr><td><code>b</code></td><td>前一单词</td></tr>
<tr><td><code>%</code></td><td>可以跳转至与括号匹配的另一个括号位置。 <code>{ [ ( ) ] }</code>都可以匹配</td></tr>
<tr><td><code>H</code> / <code>M</code> / <code>L</code></td><td>分别移动光标至屏幕顶端、屏幕中间、屏幕底部</td></tr>
<tr><td><code>zt</code> / <code>zz</code> / <code>zb</code></td><td>分别为将光标所在行移至屏幕顶端、中间、底端</td></tr>
<tr><td><code>ctrl-f</code> / <code>ctrl-b</code></td><td>分别为向下翻页，向上翻页 (同<code>PgUp</code>和<code>pgDn</code>按键)</td></tr>
<tr><td><code>ctrl-e</code> / <code>ctrl-y</code></td><td>分别为向下滚动，向上滚动</td></tr>
</tbody></table>
<hr />
<h4 id="代码常用-基于as的vim插件验证"><a class="header" href="#代码常用-基于as的vim插件验证">代码常用 (基于AS的VIM插件验证)</a></h4>
<table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody>
<tr><td><code>%</code></td><td>匹配到对应的括号</td></tr>
<tr><td><code>gD</code></td><td>跳转至符号定义处</td></tr>
<tr><td><code>ctrl-]</code></td><td>跳转至符号定义处</td></tr>
<tr><td><code>ctrl-o</code> (字母o)</td><td>返回跳转前位置 (<code>2,ctrl-o</code>，可以返回2步）</td></tr>
<tr><td><code>''</code></td><td>跳转到光标上次停留的地方</td></tr>
<tr><td><code>mx</code> (x为a-z的字母)</td><td>设置标签，并且在当前文件中，可以快速跳到标签位置</td></tr>
<tr><td>``x`</td><td>跳至名为x的标签位置</td></tr>
<tr><td><code>&gt;&gt;</code>、<code>5&gt;&gt;</code></td><td>增加缩进，前面加数字时，表示几行进行缩进</td></tr>
<tr><td><code>{</code> 、 <code>}</code></td><td>跳转至上一段或下一段的开头 (是以空行来区分段的)</td></tr>
<tr><td><code>(</code> 、<code>)</code></td><td>跳到当前段落的开头或结尾</td></tr>
</tbody></table>
<hr />
<h4 id="编辑"><a class="header" href="#编辑">编辑</a></h4>
<table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody>
<tr><td><code>d2w</code> / <code>d2e</code></td><td>删除两个单词 (w会删除单词后的空格、e不包括)</td></tr>
<tr><td><code>daw</code></td><td>删除当前光标所在单词</td></tr>
<tr><td><code>cw</code> / <code>ce</code></td><td>删除当前光标至单词末尾，并进入编辑模式</td></tr>
<tr><td><code>c$</code></td><td>删除光标至行尾，并进入编辑模式</td></tr>
<tr><td><code>ctrl-r</code></td><td>可以将撤销的操作重新执行</td></tr>
<tr><td><code>J</code></td><td>将当前行与下一行合并</td></tr>
<tr><td><code>&quot;+y</code></td><td>可以将内容复制到系统剪切板里。(如：<code>&quot;+yw</code>复制当前单词到系统剪切板)</td></tr>
<tr><td><code>&quot;+p</code></td><td>将系统剪切板内容粘贴在光标后面</td></tr>
</tbody></table>
<hr />
<h4 id="搜索替换"><a class="header" href="#搜索替换">搜索/替换</a></h4>
<table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody>
<tr><td><code>/</code></td><td>直接进入搜索模式，正向查找</td></tr>
<tr><td><code>?</code></td><td>直接进入搜索模式，反向搜索</td></tr>
<tr><td><code>ctrl-o</code></td><td>可以回到跳转前的光标位置，并且可以多次执行</td></tr>
<tr><td><code>:s/old/new</code></td><td>在当前行将第一个old替换为new</td></tr>
<tr><td><code>:s/old/new/g</code></td><td>在当前行，将所有old替换为new</td></tr>
<tr><td><code>:%s/old/new/g</code></td><td>全文替换 (<code>:%s/old/new/gc</code>: 全文替换时需要确认)</td></tr>
</tbody></table>
<hr />
<h4 id="命令"><a class="header" href="#命令">命令</a></h4>
<table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody>
<tr><td><code>:help [cmd]</code></td><td>查看帮助</td></tr>
<tr><td><code>:q</code></td><td>可以关闭窗口，包括VIM内部打开的多个窗口</td></tr>
<tr><td><code>ZQ</code></td><td>不保存退出 (<code>ZZ</code>是保存退出)</td></tr>
<tr><td><code>:!</code></td><td>执行外部命令，如: <code>:!ls</code> 表示查看外部当前目录的文件</td></tr>
<tr><td><code>:w filename</code></td><td>将当前所有内容写入到filename中</td></tr>
<tr><td><code>:r filename</code></td><td>可以将filename的内容读取出来，抛入到光标处</td></tr>
<tr><td><code>v</code></td><td>进入可视模式，此时所有移动操作都可以用来选择内容 (选完再按<code>:</code>，就对选中内容操作)</td></tr>
<tr><td><code>ctrl-d</code></td><td>可以将所有匹配的命令列出来。如输入<code>:e</code>后，按<code>ctrl-d</code>，就能列出来以e开头的命令</td></tr>
</tbody></table>
<hr />
<h4 id="配置"><a class="header" href="#配置">配置</a></h4>
<table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody>
<tr><td><code>:set ic</code></td><td>设置搜索忽略大小写</td></tr>
<tr><td><code>:set hls</code></td><td>设置搜索结果高亮</td></tr>
<tr><td><code>:set is</code></td><td>搜索时每次键入都去尝试匹配</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell"><a class="header" href="#shell">Shell</a></h1>
<h3 id="资料-1"><a class="header" href="#资料-1">资料</a></h3>
<p><a href="https://wangdoc.com/bash/">Bash 脚本教程</a></p>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>ctrl-r</code></td><td>搜索历史命令，可以从命令中间进行匹配。<code>Enter</code>可以直接执行，左右方向键可以对命令二次编辑</td></tr>
<tr><td><code>ctrl-u</code></td><td>删除当前行的内容</td></tr>
<tr><td><code>ctrl-w</code></td><td>删除你输入的最后一个单词</td></tr>
<tr><td><code>ctrl-k</code></td><td>删除光标之后的内容</td></tr>
<tr><td><code>option-左右方向键</code></td><td>可以左移或右移一个单词</td></tr>
<tr><td><code>ctrl-x ctrl-e</code></td><td>在vim中编辑命令</td></tr>
<tr><td><code>cd -</code></td><td>回到前一个工作路径中</td></tr>
<tr><td><code>set -o vi</code></td><td>命令行用vi的方式来使用</td></tr>
<tr><td><code>set -o emacs</code></td><td>还原为默认方式</td></tr>
</tbody></table>
<hr />
<table><thead><tr><th>命令</th><th>使用</th></tr></thead><tbody>
<tr><td><code>ctrl-z</code></td><td>将当前执行任务挂起</td></tr>
<tr><td><code>jobs</code></td><td>列出所有子任务</td></tr>
<tr><td><code>fg %1</code></td><td>将编号为1的挂起任务放到前台来执行</td></tr>
<tr><td><code>bg %1</code></td><td>将编号为1的挂起任务在后台执行起来</td></tr>
<tr><td><code>kill %1</code></td><td>立即强制中止编码为1的任务</td></tr>
</tbody></table>
<hr />
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>man ascii</code></td><td>查看ascii码表</td></tr>
<tr><td><code>cal</code></td><td>查看日历</td></tr>
<tr><td><code>bc</code> / <code>python</code></td><td>使用计算器</td></tr>
</tbody></table>
<h3 id="其它-1"><a class="header" href="#其它-1">其它</a></h3>
<p>用JS写Shell的库：<a href="https://github.com/shelljs/shelljs">shelljs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="markdown"><a class="header" href="#markdown">Markdown</a></h1>
<p><a href="https://www.jianshu.com/p/02a5a1bf1096">Markdown流程图使用</a></p>
<h3 id="markdown常用js库"><a class="header" href="#markdown常用js库">Markdown常用js库</a></h3>
<ul>
<li><a href="https://github.com/markedjs/marked">Marked</a></li>
<li><a href="https://github.com/markdown-it/markdown-it">Markdown-it</a>
<blockquote>
<p><code>Marked</code>和<code>Markdown-it</code>，在测试过程中，解析速度差不多。不过markdown-it扩展性更强，而且稳定性好。</p>
</blockquote>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="正则表达式"><a class="header" href="#正则表达式">正则表达式</a></h1>
<h3 id="资料-2"><a class="header" href="#资料-2">资料</a></h3>
<ul>
<li><a href="https://regex101.com/">正则表达式测试</a></li>
<li><a href="https://regexper.com/">正则可视化</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试"><a class="header" href="#测试">测试</a></h1>
<h3 id="资料-3"><a class="header" href="#资料-3">资料</a></h3>
<ul>
<li><a href="https://www.kancloud.cn/apachecn/guru99-zh/1953496">Guru99 软件测试教程</a></li>
</ul>
<h3 id="测试方式"><a class="header" href="#测试方式">测试方式</a></h3>
<h4 id="回归测试"><a class="header" href="#回归测试">回归测试</a></h4>
<p>是指对软件的新版本测试时，重复执行之前某一个重要版本的所有测试用例</p>
<p>目的：</p>
<ul>
<li>验证之前版本产生的所有缺陷已全部被修复；</li>
<li>确认修复这些缺陷没有引发新的缺陷</li>
</ul>
<h3 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h3>
<h4 id="通用-1"><a class="header" href="#通用-1">通用</a></h4>
<ul>
<li><a href="https://www.cnblogs.com/Neeo/articles/11795996.html">测试 - 测试覆盖率</a>：语句覆盖率、条件覆盖率等是不一样的</li>
</ul>
<h4 id="前端"><a class="header" href="#前端">前端</a></h4>
<h5 id="jest的使用"><a class="header" href="#jest的使用">jest的使用</a></h5>
<p>https://jestjs.io/docs/zh-Hans/getting-started</p>
<p>https://github.com/sapegin/jest-cheat-sheet</p>
<h5 id="mocha的使用"><a class="header" href="#mocha的使用">mocha的使用</a></h5>
<p>https://github.com/matthewyan/Mocha</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vscode"><a class="header" href="#vscode">VSCode</a></h1>
<p>VSCoce远程开发配置：https://juejin.im/post/5cf9d23ce51d45773d4685d9</p>
<p>远程开发配置好后，连接到远程服务器后，就用“打开文件夹”功能，就可以打开远端目录</p>
<h3 id="vscode快捷键"><a class="header" href="#vscode快捷键">VSCode快捷键</a></h3>
<table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody>
<tr><td>回退到上个位置</td><td><code>Ctrl</code> + <code>-</code></td></tr>
<tr><td>快速打开文件</td><td><code>Ctrl</code> + <code>p</code></td></tr>
<tr><td>代码格式化</td><td><code>Shift</code> + <code>Option</code> + <code>F</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库"><a class="header" href="#数据库">数据库</a></h1>
<h3 id="资料-4"><a class="header" href="#资料-4">资料</a></h3>
<p><a href="https://www.jianshu.com/p/107c6b045245">超全的数据库分类介绍</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/27789602">事务的ACID特性</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/69380112">通俗易懂 事务、ACID、脏读、脏写、幻读、读已提交、快照隔离、读写锁、两阶段锁定 的区别与联系</a></p>
<p><a href="https://db-engines.com/en/ranking">数据库排名</a></p>
<h3 id="基础概念"><a class="header" href="#基础概念">基础概念</a></h3>
<ul>
<li>关系型数据库，如MySQL、Oracle、SQL Server</li>
<li>非关系型数据库</li>
<li>事务：一个或者一系列操作的最小逻辑单元，这个逻辑单元内的操作要么全部成功，要么就全部失败。</li>
</ul>
<h4 id="aicd"><a class="header" href="#aicd">AICD</a></h4>
<ul>
<li>原子性</li>
<li>隔离性：事务之间不会相互影响，如果多个事务操作一个对象时，会串行处理。</li>
<li>一致性</li>
<li>持久性：一旦事务成功提交后，就不会丢失。</li>
</ul>
<h4 id="orm"><a class="header" href="#orm">ORM</a></h4>
<p>ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术，是&quot;对象-关系映射&quot;（Object/Relational Mapping） 的缩写。</p>
<h4 id="索引"><a class="header" href="#索引">索引</a></h4>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODEzNDA4OA==&amp;mid=2650317286&amp;idx=1&amp;sn=10273b8b2d75583ee75355bc4f30f3cf&amp;chksm=bec369c189b4e0d71fbe466cfe6319cbcabf87c506352e2c03eefa7f2560c0e2ff1c6bb80014&amp;mpshare=1&amp;scene=1&amp;srcid=07275NaWbWibeXaMQhvuIGhR&amp;sharer_sharetime=1627353559190&amp;sharer_shareid=46db0b7b20a25a2d43b9732f9afbb07d&amp;version=3.1.10.90255&amp;platform=mac#rd">微信大牛教你深入了解数据库索引</a></p>
<p>索引的本质，是在数据表之外，建立一个新的数据结构，提升查询效率。</p>
<h3 id="关系型数据库"><a class="header" href="#关系型数据库">关系型数据库</a></h3>
<p>关系型数据库是指采用了关系模型来组织数据的数据库。简单来说，关系模式就是二维表格模型。</p>
<p>里面的核心概念是 <strong>联结</strong></p>
<h3 id="非关系型数据库"><a class="header" href="#非关系型数据库">非关系型数据库</a></h3>
<table><thead><tr><th>类型</th><th>示例</th></tr></thead><tbody>
<tr><td>KV存储</td><td>LevelDB、Redis</td></tr>
<tr><td>列存储</td><td>HBase</td></tr>
<tr><td>文档型</td><td>MongoDB</td></tr>
<tr><td>搜索型</td><td>ElasticSearch</td></tr>
<tr><td>图形数据库</td><td>Neo4J</td></tr>
</tbody></table>
<p>列存储类型的介绍可以参考：<a href="https://juejin.im/entry/6844903750012780558">五分钟轻松了解Hbase列式存储</a></p>
<p>了解文档存储，参考MongoDB介绍：<a href="https://zhuanlan.zhihu.com/p/87722764">了解 MongoDB 看这一篇就够了</a></p>
<h3 id="常用数据库"><a class="header" href="#常用数据库">常用数据库</a></h3>
<h4 id="leveldb"><a class="header" href="#leveldb">LevelDB</a></h4>
<p><a href="https://zhuanlan.zhihu.com/p/67833030">LevelDB深入浅出之整体架构</a></p>
<h4 id="sqlite"><a class="header" href="#sqlite">SQLite</a></h4>
<h5 id="ios端性能优化"><a class="header" href="#ios端性能优化">iOS端性能优化</a></h5>
<p><a href="https://www.jianshu.com/p/660df4731d63">iOS 平台 SQLite 性能优化</a></p>
<ul>
<li>
<p>Pragma参数优化（https://sqlite.org/pragma.html）</p>
</li>
<li>
<p>有效使用索引 （索引可以有效提升查询效率）(内置的explain功能查看语句的执行流程)</p>
</li>
<li>
<p>尽可能避免全表扫描。</p>
</li>
<li>
<p>减少无效数据的查询。</p>
</li>
<li>
<p>编写合理的语句</p>
</li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络"><a class="header" href="#网络">网络</a></h1>
<h3 id="概念"><a class="header" href="#概念">概念</a></h3>
<p>RTT：往返时延，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</p>
<h3 id="ipv6"><a class="header" href="#ipv6">IPv6</a></h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/50747832">IPV4和IPV6的区别有哪些</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/36542469">IPv6，到底是什么？</a>：可以查看IPv6规则</li>
</ul>
<h3 id="套接字"><a class="header" href="#套接字">套接字</a></h3>
<p>由两端的IP/端口来唯一标识</p>
<h3 id="tcp"><a class="header" href="#tcp">TCP</a></h3>
<p>三次握手步骤：</p>
<ul>
<li>SYN :客户端产生一个随机数x，再加上一些其他TCP参数，发送一个SYN包给服务端。</li>
<li>SYN ACK：服务端在对x加1，自己再产生一个随机数y，再加上一些其他TCP参数，返回给客户端。</li>
<li>ACK ：客户端同时对x和y再加1，发送最后一个ACK包，完成握手过程。</li>
</ul>
<p>为什么需要三次握手：</p>
<p><a href="https://www.zhihu.com/question/24853633/answer/115173386">TCP 为什么是三次握手，而不是两次或四次？ - 车小胖的回答 - 知乎</a>
<a href="https://www.zhihu.com/question/24853633/answer/573627478">TCP 为什么是三次握手，而不是两次或四次？ - 山尽的回答 - 知乎</a></p>
<p>原因是为了防止链接复用时，收到了老的包。三次握手是在确定<code>ISN</code>，即初始序列号。</p>
<h3 id="udp"><a class="header" href="#udp">UDP</a></h3>
<p><a href="https://zhuanlan.zhihu.com/p/64154915">udp协议-看这篇就够了</a></p>
<h3 id="http"><a class="header" href="#http">Http</a></h3>
<ul>
<li>
<p><a href="https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/">一文读懂 HTTP/2 及 HTTP/3 特性</a></p>
</li>
<li>
<p><a href="https://www.justdojava.com/2019/11/03/Network_interview_question/">最常见的12道计算机网络面试题</a></p>
</li>
</ul>
<h4 id="状态码"><a class="header" href="#状态码">状态码</a></h4>
<p>整体范围  已定义范围  含义
100~199	100~101	信息提示
200~299	200~206	成功
300~399	300~305	重定向
400~499	400~415	客户端错误
500~599	500~505	服务器错误</p>
<h4 id="http1x"><a class="header" href="#http1x">Http/1.x</a></h4>
<ul>
<li>链接复用问题
<ul>
<li>1.0不支持链接复用</li>
<li>1.1，支持keep alive，但部分情况仍然需要建立多个链接</li>
</ul>
</li>
<li>HOLB（Head-Of-Line Blocking）：当第一个包被阻塞时，后续的包也都会被阻塞
<ul>
<li>1.0只能等</li>
<li>1.1部分解决，即请求可以一次发送多个</li>
</ul>
</li>
<li>协议开销，每次Header里都带上所有相关信息</li>
<li>安全问题</li>
<li>有做并发限制，如果需要同时下载超过限制数的资源，就需要使用<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Domain_sharding">域名分片</a></li>
</ul>
<h4 id="http2"><a class="header" href="#http2">Http/2</a></h4>
<p>Http2的基础是Google开发的SPDY协议</p>
<ul>
<li>二进制传输</li>
<li>同域名通信，都是单链接完成 （单链接也给Header优化提供了支持）</li>
<li>请求带有优先级</li>
<li>支持Server Push</li>
</ul>
<p>问题：</p>
<ul>
<li>Http2的长链接，一旦丢包，就会导致所有包重传</li>
</ul>
<h4 id="http3"><a class="header" href="#http3">Http/3</a></h4>
<p>基于Google开发的QUIC协议</p>
<ul>
<li>基于UDP (可以实现真正的多路复用)</li>
<li>向前纠错机制</li>
</ul>
<h4 id="https"><a class="header" href="#https">Https</a></h4>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000019976390">HTTPS加密过程详解</a></p>
</blockquote>
<p>Https是在HTTP下加入<code>SSL</code>层</p>
<p>TLS目前使用较多的是TLS 1.1、TLS 1.2。</p>
<p>步骤：</p>
<ul>
<li>客户端请求服务器获取证书公钥</li>
<li>客户端(SSL/TLS)解析证书（无效会弹出警告）</li>
<li>生成随机值</li>
<li>用公钥加密随机值生成密钥</li>
<li>客户端将秘钥发送给服务器</li>
<li>服务端用私钥解密秘钥得到随机值</li>
<li>将信息和随机值混合在一起进行对称加密</li>
<li>将加密的内容发送给客户端</li>
<li>客户端用秘钥解密信息</li>
</ul>
<blockquote>
<p><a href="https://www.zhihu.com/question/36767829">什么是DES加密？</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理（一）</a></p>
</blockquote>
<h4 id="get--post区别"><a class="header" href="#get--post区别">GET / POST区别</a></h4>
<ul>
<li>
<p><a href="https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/">都 2019 年了，还问 GET 和 POST 的区别</a></p>
</li>
<li>
<p><a href="https://segmentfault.com/a/1190000023940344">【网络协议】彻底弄清POST和GET请求的区别，这次你GET了么</a></p>
</li>
<li>
<p>目的上有区别，GET用来获取数据，可以重复获取。POST用来写，重复请求会影响远端状态</p>
</li>
<li>
<p>请求报文上，没有实质区别。一个是<code>GET /uri ***</code>，一个是<code>POST /uri ***</code></p>
</li>
<li>
<p>按照约定，GET的请求参数一般放在url中，POST的请求参数一般放在body中</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用工具"><a class="header" href="#常用工具">常用工具</a></h1>
<h4 id="统计代码行数"><a class="header" href="#统计代码行数">统计代码行数</a></h4>
<p>安装：</p>
<pre><code class="language-sh">gem install git_stats
</code></pre>
<p>在工程目录执行：</p>
<pre><code class="language-sh">git_stats generate
</code></pre>
<p>其它的类似<code>cloc</code>也可以，参考：<a href="https://www.zhihu.com/question/22004842">有哪些比较好用的代码量统计工具？</a></p>
<h4 id="生成文本类型的目录结构"><a class="header" href="#生成文本类型的目录结构">生成文本类型的目录结构</a></h4>
<ul>
<li><code>brew install tree</code></li>
<li>使用：<code>tree -I node_modules &gt; tree.text</code> (表示忽略node_modules目录)</li>
</ul>
<h4 id="a-hrefhttpswwwbundlercnbundlera"><a class="header" href="#a-hrefhttpswwwbundlercnbundlera"><a href="https://www.bundler.cn/">Bundler</a></a></h4>
<p>能够跟踪并安装所需的特定版本的 gem</p>
<p>安装bundler：<code>gem install bundler</code></p>
<p>安装依赖：<code>bundle install</code></p>
<h4 id="cocoapods"><a class="header" href="#cocoapods">cocoapods</a></h4>
<p>安装：<code>sudo gem install cocoapods</code></p>
<p>如果提示路径没有权限的错误，可以用<code>-n</code>参数指定路径：<code>sudo gem install cocoapods -n /usr/local/bin</code></p>
<h4 id="fastlane"><a class="header" href="#fastlane">Fastlane</a></h4>
<p><a href="https://www.jianshu.com/p/d26db164fa87">Fastlane介绍及快速集成</a></p>
<p>实现iOS和Android的发布流程的自动化，以节省发布时间。功能有如下：</p>
<ul>
<li>生成并下载开发者证书</li>
<li>iTunes Connect上创建应用</li>
<li>打包应用</li>
<li>实现应用截屏</li>
<li>发布到Testflight</li>
<li>将包、截屏等传到Appstore</li>
</ul>
<blockquote>
<p>Fastlane实际上是一个Ruby脚本的集合,里面的每一个工具实际就是一个Ruby脚本,用于执行特定的工作任务。</p>
</blockquote>
<h4 id="a-hrefhttpswwwtravis-cicomtravis-cia"><a class="header" href="#a-hrefhttpswwwtravis-cicomtravis-cia"><a href="https://www.travis-ci.com/">Travis CI</a></a></h4>
<p><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html">持续集成服务 Travis CI 教程</a></p>
<p>市场份额最大，的持续集成服务。</p>
<blockquote>
<p>目前并不只支持Github项目了，也开始支持Bitbucket等仓库了。</p>
</blockquote>
<h4 id="jenkins"><a class="header" href="#jenkins">Jenkins</a></h4>
<p><a href="https://segmentfault.com/a/1190000038464808">别当工具人了，手摸手教会你 Jenkins ！</a></p>
<h4 id="gitlab-ci"><a class="header" href="#gitlab-ci">Gitlab-CI</a></h4>
<p><a href="https://juejin.cn/post/6844904045581172744">Gitlab-CI使用教程</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="算法"><a class="header" href="#算法">算法</a></h1>
<ul>
<li><a href="https://github.com/labuladong/fucking-algorithm">算法小抄</a></li>
<li><a href="https://apps.apple.com/cn/app/%E7%AE%97%E6%B3%95%E5%8A%A8%E7%94%BB%E5%9B%BE%E8%A7%A3/id1047532631">算法动画图解</a>：比较直观的看到部分算法的操作步骤，方便理解</li>
</ul>
<h3 id="堆"><a class="header" href="#堆">堆</a></h3>
<p>一种特殊的树，是完全二叉树；堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</p>
<p>堆化：当插入新的元素后，堆的条件不再满足时，就需要调整结点，以使其重新满足，这个过程就是堆化。</p>
<p>参考：https://time.geekbang.org/column/article/69913?utm_term=pc_interstitial_626</p>
<h3 id="红黑树"><a class="header" href="#红黑树">红黑树</a></h3>
<p><a href="https://www.jianshu.com/p/e136ec79235c">30张图带你彻底理解红黑树</a></p>
<p><a href="https://www.jianshu.com/p/d25e490e2441">红黑树(Red-black tree)</a>：插入过程讲的比较清晰</p>
<h5 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h5>
<ul>
<li>STL中的map和set</li>
<li><a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler">Linux进程调度</a></li>
<li>nginx中的超时管理</li>
<li>epoll的事件管理</li>
</ul>
<h3 id="图"><a class="header" href="#图">图</a></h3>
<ul>
<li>带权重的图，称为加权图</li>
<li>不带权重的图，称为非加权图</li>
</ul>
<h3 id="其它数据结构"><a class="header" href="#其它数据结构">其它数据结构</a></h3>
<h4 id="跳表"><a class="header" href="#跳表">跳表</a></h4>
<ul>
<li><a href="https://www.jianshu.com/p/9d8296562806">Skip List--跳表</a></li>
</ul>
<h4 id="字典树"><a class="header" href="#字典树">字典树</a></h4>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/28891541">字典树（前缀树）</a></li>
</ul>
<h3 id="常用算法"><a class="header" href="#常用算法">常用算法</a></h3>
<h5 id="狄克斯特拉算法"><a class="header" href="#狄克斯特拉算法">狄克斯特拉算法</a></h5>
<h5 id="滑动窗口算法"><a class="header" href="#滑动窗口算法">滑动窗口算法</a></h5>
<p><a href="https://www.zhihu.com/question/314669016/answer/620247024">什么是「滑动窗口算法」</a></p>
<p>滑动窗口算法可以用以解决数组/字符串的子元素问题，它可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。</p>
<h5 id="洗牌算法"><a class="header" href="#洗牌算法">洗牌算法</a></h5>
<p>https://www.zhihu.com/question/358255792/answer/974431591</p>
<h5 id="lru算法"><a class="header" href="#lru算法">LRU算法</a></h5>
<p><a href="https://www.cnblogs.com/linxiyue/p/10926944.html">LRU算法原理解析</a></p>
<h5 id="退火算法"><a class="header" href="#退火算法">退火算法</a></h5>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图像处理"><a class="header" href="#图像处理">图像处理</a></h1>
<h3 id="资料-5"><a class="header" href="#资料-5">资料</a></h3>
<p><a href="https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">移动端图片格式调研</a></p>
<h3 id="基础概念-1"><a class="header" href="#基础概念-1">基础概念</a></h3>
<p>页面卡顿的原因：CPU或GPU计算好数据后将渲染后的结果放入帧缓冲区。视频控制器会根据VSync信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>
<blockquote>
<p>来源：<a href="https://xiaozhuanlan.com/topic/3420765198">Metal【1】—— 概述</a></p>
</blockquote>
<h3 id="图像转换"><a class="header" href="#图像转换">图像转换</a></h3>
<h4 id="矩阵变换"><a class="header" href="#矩阵变换">矩阵变换</a></h4>
<h5 id="矩阵运算规则"><a class="header" href="#矩阵运算规则">矩阵运算规则</a></h5>
<img src="Common/images/matrix_transfer.png" alt="matrix_transfer" style="zoom:50%;" />
<h5 id="解释"><a class="header" href="#解释">解释</a></h5>
<p>资料：<a href="https://zhuanlan.zhihu.com/p/147791525">Transformation Matrix 变换矩阵</a></p>
<p>转换函数，是对图形的每一个点都应用这个转换，所有会使图形进行变形。这就是矩阵转换。</p>
<h3 id="gpu渲染流程"><a class="header" href="#gpu渲染流程">GPU渲染流程</a></h3>
<h5 id="顶点着色"><a class="header" href="#顶点着色">顶点着色</a></h5>
<p>输入是顶点数据</p>
<p>将一种3D坐标转为另一种3D坐标</p>
<p>对顶点属性做一些基本处理</p>
<h5 id="形状装配"><a class="header" href="#形状装配">形状装配</a></h5>
<p>将所有的点装配成指定图元的形状</p>
<h5 id="几何着色器"><a class="header" href="#几何着色器">几何着色器</a></h5>
<h3 id="框架"><a class="header" href="#框架">框架</a></h3>
<h4 id="metal"><a class="header" href="#metal">Metal</a></h4>
<ul>
<li><code>Metal</code> 和 <code>OpenGL ES</code>，<code>Core Graphics</code> 属于同一级，最接近 Graphics Hardware</li>
<li><code>Metal</code> 和 <code>OpenGL ES</code>使用GPU处理，<code>Core Graphics</code>使用CPU处理</li>
<li><code>OpenGL ES</code>在iOS12之后被标记为废弃</li>
<li>苹果很多图像处理框架，如<code>SpriteKit</code>、<code>SceneKit</code>、<code>Core Image</code>等低层都基于metal来实现</li>
</ul>
<p><a href="https://blog.csdn.net/u012681458/article/details/50684230">Metal-IOS-通用GPU计算:Data-Parallel Compute Processing: Compute Command Encoder</a></p>
<h4 id="webgl"><a class="header" href="#webgl">WebGL</a></h4>
<ul>
<li>在Web端高效渲染交互式的2D/3D图形</li>
<li>与OpenGL ES 2.0的API非常接近</li>
<li>API的使用同样需要在<code>&lt;canvas&gt;</code>中使用</li>
</ul>
<h4 id="webgpu"><a class="header" href="#webgpu">WebGPU</a></h4>
<ul>
<li>简单理解，WebGPU就是WebGL的升级版本</li>
<li>WebGPU使用了Vulkan、Metal和Direct3D 12，引擎较新，也更好的反映了GPU这些年新的发展。(WebGL是基于OpenGL的)</li>
<li>提供更好的性能，支持多线程，采用了偏面向对象的编程风格</li>
</ul>
<h3 id="svg"><a class="header" href="#svg">SVG</a></h3>
<ul>
<li><a href="https://www.clicktorelease.com/blog/svg-google-logo-in-305-bytes/">Google图标大小优化过程</a></li>
</ul>
<h3 id="图片处理"><a class="header" href="#图片处理">图片处理</a></h3>
<ul>
<li><a href="https://github.com/ppwwyyxx/OpenPano">全景拼接</a></li>
<li><a href="https://www.objccn.io/issue-21-9/">基于 OpenCV 的人脸识别</a></li>
<li><a href="https://github.com/mohssenfathi/MTLImage">基于Metal的图片处理类</a></li>
<li><a href="https://juejin.im/post/59ad5d6551882539255b4809">Metal使用</a></li>
<li><a href="http://blog.csdn.net/dcrmg/article/details/53677739">图像的亮化</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h1>
<h3 id="资料-6"><a class="header" href="#资料-6">资料</a></h3>
<p><a href="https://www.gitbook.com/book/wizardforcel/wangdaokaoyan-os">王道考研操作系统知识整理</a></p>
<p><a href="https://www.jianshu.com/p/4efd858c6520">操作系统中断机制</a></p>
<h3 id="虚拟内存"><a class="header" href="#虚拟内存">虚拟内存</a></h3>
<p>作业必须一次性全部装入内存后，方可运行。这是支持虚拟内存非常重要的目的。</p>
<p>虚拟内存技术实际上就是建立了“内存-外存”的两级存储器的结构，利用局部性原理实现高速缓存。</p>
<p>在程序装入时，可以将程序的一部分装入内存，而将其与部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。</p>
<p>局部性原理：</p>
<ul>
<li>时间局部性：如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行。</li>
<li>空间局部性：一旦程序访问量某个存储单元，在不久之后，其附近的存储单元也将被访问。（如指令的顺序执行）</li>
</ul>
<p>当用户程序要访问的部分尚未调入内存，则产生中断。</p>
<h3 id="中断"><a class="header" href="#中断">中断</a></h3>
<ul>
<li>中断是一种电信号，有硬件设备产生，直接向<code>中断控制器</code>发送信号。</li>
<li>中断控制器将信号发给CPU，CPU一旦检测到信号，就中断当前任务，转而处理中断信号。</li>
<li>CPU通知OS产生了中断，并将中断信号转给OS</li>
</ul>
<p>中断的分类：</p>
<ul>
<li>同步中断：由CPU产生 （也称异常）</li>
<li>异步中断：其它硬件设备产生 （称为中断）</li>
</ul>
<p>异常分如下三类：</p>
<ul>
<li>故障</li>
<li>陷阱</li>
<li>终止</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全"><a class="header" href="#安全">安全</a></h1>
<h3 id="oauth-20"><a class="header" href="#oauth-20">OAuth 2.0</a></h3>
<p><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0</a></p>
<p>OAuth的作用：就是让第三方服务安全可控地获取&quot;用户&quot;的授权，与&quot;服务商提供商&quot;进行互动。</p>
<p>方案</p>
<ul>
<li>设置授权层，区分普通用户与第三方服务 (授权层可以做灵活的控制)</li>
<li>三方登录使用的票据称为<code>Token</code></li>
<li>可以通过<code>Token</code>限制三方的权限范围，比如只能读数据，不能写数据，设置Token有效期等</li>
</ul>
<p>客户端获得授权，目前常用的方案为：<code>授权码模式</code> （也即通过客户端导向认证服务器进行认证）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件工程"><a class="header" href="#软件工程">软件工程</a></h1>
<h2 id="架构图"><a class="header" href="#架构图">架构图</a></h2>
<p>画架构图的工具：</p>
<ul>
<li><a href="https://www.processon.com/">ProcessOn</a></li>
<li><a href="https://diagrams.net">diagrams.net</a></li>
</ul>
<p>资料：</p>
<ul>
<li><a href="https://www.zhihu.com/question/27440059">如何画架构图？</a></li>
</ul>
<h2 id="类图工具"><a class="header" href="#类图工具">类图工具</a></h2>
<h3 id="plantuml"><a class="header" href="#plantuml">PlantUML</a></h3>
<p>官网：https://plantuml.com/zh/</p>
<p>安装：</p>
<ul>
<li><code>brew install graphviz</code></li>
<li>如果提示部分工具不存在：<code>xcode-select --install</code>，执行完之后再安装graphviz</li>
<li>下载<a href="http://sourceforge.net/projects/plantuml/files/plantuml.jar/download">plantuml.jar</a></li>
<li>执行<code>plantuml.jar</code>，然后指定工作目录，以及配置支持的文件后缀(如添加md)</li>
<li>在工作目录中新建的txt/md文件，编辑了之后直接保存，在当前目录下就会生成同名的png图片</li>
</ul>
<h3 id="mermaid-推荐"><a class="header" href="#mermaid-推荐">Mermaid (推荐)</a></h3>
<p>官网：https://github.com/mermaid-js/mermaid</p>
<p><code>typroa</code>及<code>gitlab</code>默认都支持这个插件</p>
<h2 id="开发模式"><a class="header" href="#开发模式">开发模式</a></h2>
<h3 id="ddd"><a class="header" href="#ddd">DDD</a></h3>
<h3 id="tdd"><a class="header" href="#tdd">TDD</a></h3>
<p><a href="https://juejin.cn/post/6844903780970921991">测试驱动开发（TDD）总结——原理篇</a></p>
<p><a href="https://colin1994.github.io/2016/06/03/TDD-With-Swift/">TDD 学习总结（Swift 实践）</a></p>
<p>BDD：其实是TDD的改进版，把测试代码用DSL以更加可读的方式来描述，方便其他角色一起参与沟通。（参考：<a href="https://zhuanlan.51cto.com/art/201805/573796.htm">一文讲清楚什么是行为驱动开发</a>）</p>
<h2 id="工程管理"><a class="header" href="#工程管理">工程管理</a></h2>
<p><a href="https://f5.pm/go-86022.html">​从微信后端仓库发展史谈谈单仓和多仓</a></p>
<p><a href="https://github.com/joelparkerhenderson/monorepo-vs-polyrepo">monorepo-vs-polyrepo</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件架构"><a class="header" href="#软件架构">软件架构</a></h1>
<h2 id="基础概念-2"><a class="header" href="#基础概念-2">基础概念</a></h2>
<p><strong>关注点分离</strong>：关注点混杂在一起会导致复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就可以有效降低复杂性。关注点分离是处理复杂性的一个原则。</p>
<h2 id="资料-7"><a class="header" href="#资料-7">资料</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/36071845">什么是架构设计</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/09/software-architecture.html">架构模式</a></li>
<li><a href="http://colobu.com/2015/04/08/software-architecture-patterns/">软件架构模式</a></li>
</ul>
<h2 id="架构"><a class="header" href="#架构">架构</a></h2>
<p>大的架构模式：</p>
<ul>
<li>分层架构（用的最多，我们常提的MVC、MVVM等也是分层架构的实现）</li>
<li>事件驱动架构（终端开发经常使用的Dispatcher）</li>
<li>微核架构。内核较少，功能通过插件来扩展。</li>
<li>微服务架构。每一个服务就是一个独立的部署单元。</li>
</ul>
<h3 id="分层架构"><a class="header" href="#分层架构">分层架构</a></h3>
<p>在分层架构中，有一种常用的三层架构，即将系统分为三层。详细参考：<a href="https://www.runoob.com/w3cnote/three-tier-architecture.html">三层架构详解</a></p>
<p>关于架构分层的优势：<a href="https://zhuanlan.zhihu.com/p/196733107">架构分层：我们为什么一定要这么做？</a></p>
<p>在三层架构中的DAL(数据访问层)，经常会使用DAO模式，关于DAO模式参考：<a href="https://zhuanlan.zhihu.com/p/59551370">DAO设计模式</a></p>
<p>MVC、MVVM也是分层架构，MV(X)模式介绍参考：</p>
<ul>
<li><a href="https://draveness.me/mvx">浅谈 MVC、MVP 和 MVVM 架构模式</a></li>
<li><a href="https://github.com/uptechteam/Coordinator-MVVM-Rx-Example.git">MVX模式示例</a>：比较清晰易懂的示例</li>
<li><a href="https://github.com/nandawperdana/ios-mvp-swift">MVP示例</a></li>
</ul>
<h2 id="架构模式"><a class="header" href="#架构模式">架构模式</a></h2>
<h3 id="provider"><a class="header" href="#provider">Provider</a></h3>
<p>状态是组件私有的，则应该由组件自己管理；如果状态要跨组件共享，则该状态应该由各个组件共同的父元素来管理。</p>
<p>组件共享管理方式：</p>
<ul>
<li>全局事件总线EventBus</li>
</ul>
<h3 id="bloc"><a class="header" href="#bloc">BLoC</a></h3>
<p>BLoC是<code>Business Logic Components</code>的缩写。</p>
<blockquote>
<p>BLoC的哲学就是app里的所有东西都应该被认为是事件流：一部分组件订阅事件，另一部分组件则响应事件。BLoC居中管理这些会话。
来源：<a href="https://juejin.cn/post/6844904183204691982">Flutter - BLoC模式入门</a></p>
</blockquote>
<h4 id="restful架构"><a class="header" href="#restful架构">RESTful架构</a></h4>
<p>理解RESTful架构：https://www.ruanyifeng.com/blog/2011/09/restful.html
Restful API设计：http://www.ruanyifeng.com/blog/2014/05/restful_api.html
RESTful API 最佳实践：https://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html</p>
<p>架构模式比较
http://www.cocoachina.com/ios/20160108/14916.html
https://academy.realm.io/cn/posts/krzysztof-zablocki-mDevCamp-ios-architecture-mvvm-mvc-viper/</p>
<p>架构相关
https://github.com/objcio/app-architecture
https://www.objc.io/books/app-architecture/</p>
<p>GUI架构
https://martinfowler.com/eaaDev/uiArchs.html</p>
<p>iOS 架构之 View 层的架构方案
https://mp.weixin.qq.com/s/t_IBkCClPBZFBPmtZT0WsQ</p>
<p>https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html</p>
<p>////////////////////////////////////////////////////////////////////////////////////</p>
<p>几种架构demo
https://github.com/uptechteam/Coordinator-MVVM-Rx-Example</p>
<p>Coordinator 架构模式
https://www.infoq.cn/article/ios-arch-based-on-reswift-and-app-coordinator</p>
<p>Coordinator架构开源库
https://github.com/quickbirdstudios/RxCoordinator
https://github.com/RxSwiftCommunity/RxFlow</p>
<p>VIPER架构：
https://objccn.io/issue-13-5/
Viper的Swift Demo
https://github.com/mutualmobile/VIPER-SWIFT.git</p>
<p>https://github.com/Clean-Swift/CleanStore
清洁架构的实践，不同于VIPER</p>
<p>Clean Architecture
https://clean-swift.com/clean-swift-ios-architecture/
https://github.com/sergdort/CleanArchitectureRxSwift
https://github.com/CassiusPacheco/Swift-CleanArchitecture</p>
<p>翻译
https://www.roczhang.com/%E7%BF%BB%E8%AF%91%EF%BC%9AClean%20Swift%20iOS%20Architecture%20for%20Fixing%20Massive%20View%20Controller%20%EF%BC%88%E4%BA%8C%EF%BC%89.html</p>
<p>https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html</p>
<p>Elm架构
https://github.com/chriseidhof/tea-in-swift
https://medium.com/design-x-code/elmification-of-swift-af14b7f92b30</p>
<p>////////////////////////////////////////////////////////////////////////////////////////////////</p>
<p>单向数据流架构
由于所有东西都通过单一数据点和单一修改点，因此可以将所有修改状态的行为保存下来</p>
<p>RxSwift和状态管理 (ReSwift)
https://juejin.im/post/5b6d72636fb9a04fd93e611b
ReSwift单向数据流
https://medium.com/@tobi_86596/reswift-in-practice-1512e0f59eb5
https://github.com/ReSwift/ReSwift</p>
<p>RxSwift社区的Redux(Flux)实现
https://github.com/RxSwiftCommunity/RxReduce
https://github.com/RxSwiftCommunity/RxState
https://github.com/ReactorKit/ReactorKit</p>
<p>////////////////////////////////////////////////////////</p>
<p>Redux: （http://cn.redux.js.org/docs/basics/）
通用的单向数据流架构，基于Flux发展出来的
State只读，要改变State必须要通过触发Action
使用纯函数来执行修改，即编写的reducer。（使用纯函数，是为了明确输入和输出）</p>
<p>Redux的主要作用是管理程序状态的。</p>
<p>http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html</p>
<p>https://github.com/onmyway133/fantastic-ios-architecture</p>
<p>////////////////////////////////////////////////////////</p>
<p>Flux:
Flux 的核心就是一个简单的约定：视图层组件不允许直接修改应用状态，只能触发 action。应用的状态必须独立出来放到 store 里面统一管理，通过侦听 action 来执行具体的状态操作。</p>
<p>https://gist.github.com/inamiy/bd257c60e670de8a144b1f97a07bacec</p>
<p>////////////////////////////////////////////////////////</p>
<p>https://matteomanferdini.com/ios-architecture-lotus-mvc-pattern/</p>
<p>https://github.com/matteocrippa/awesome-swift
Events</p>
<h2 id="笔记"><a class="header" href="#笔记">笔记</a></h2>
<h3 id="a-hrefhttpstimegeekbangorgopencoursedetail100069401从中台技术谈架构师的独立思考能力a"><a class="header" href="#a-hrefhttpstimegeekbangorgopencoursedetail100069401从中台技术谈架构师的独立思考能力a"><a href="https://time.geekbang.org/opencourse/detail/100069401">从中台技术谈架构师的独立思考能力</a></a></h3>
<p>一个持久创造价值的架构，一定是经过深度思考去发现的，而不是一本书上简单看到的。</p>
<p>好的思考，从清晰定义开始的，知道自己要做的真正的是什么。</p>
<p>中台定义：</p>
<ul>
<li>定义1：多个部门间共享的开发资源所提供的业务、数据和计算能力</li>
<li>定义2：业务中台是对前台应用的抽象，提供多个前台业务间共享的业务逻辑、数据和计算能力</li>
</ul>
<img src="Software/./images/MiddlePlatform.jpg" style="zoom:50%;" />
<blockquote>
<p>中台核心：抽象和降本</p>
<p>前台核心：商业机会捕捉和新商业机会创造</p>
</blockquote>
<p>中台缺点：</p>
<ul>
<li>对创新的遏制 （因为会将业务资源最小化，懂业务的人会非常少，导致面对业务创新受阻）</li>
<li>过度设计（容易做最大业务场景的全覆盖）</li>
</ul>
<p>中台本质：最简单直接的理解，中台提供技术复用，但最终公司是希望可以共享商业能力。即从技术再往业务扩展。</p>
<blockquote>
<p>中台目标，可以细分这6个目的：降低成本、加速上线、提升稳定性、加速能力扩散、统一数据资产、集团层次资源高效利用。</p>
<p>这些从左到右，即从具体到抽象，从技术到业务的过度。</p>
</blockquote>
<p>中台适用范围是有限的，适用于通用性+确定性的领域，在特殊和不确定性中，最好不要盲目使用中台。</p>
<p>SuperCell的成功，源于北欧的生活、工作准则：</p>
<ul>
<li>崇尚简约</li>
<li>尊重原创</li>
<li>组织扁平</li>
</ul>
<blockquote>
<p>中美等国家重复造轮子，源于文化，短期内难以解决。因为这些国家、公司都是奖励组织鼓胀，团队人数和收入挂钩，大家都会扩张组织。多出来的人力就去造轮子。</p>
</blockquote>
<p>抽象有天花板，终局是零和游戏？ 这句话如何理解？</p>
<p>不存在面向未来的完美设计，中台的价值会不断衰减</p>
<p>中台的发展必须要有合理的机制来配套，要有科学的方法，要有修正的机制等。</p>
<p>中台建设期，最好是在系统开始的时候。如果随着业务发展，在基础服务之上的楼建的越来越高，此时再想推翻重构，设计中台，是一种很不明智的行为。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件设计"><a class="header" href="#软件设计">软件设计</a></h1>
<hr />
<h2 id="浅谈软件设计"><a class="header" href="#浅谈软件设计">浅谈软件设计</a></h2>
<h3 id="前言"><a class="header" href="#前言">前言</a></h3>
<p>软件设计中，什么最重要？能让软件灵活、低成本修改的前提下，又能尽可能减少变化带来的风险。</p>
<p>如何能达到这个目的呢？有如下几个方面：</p>
<ul>
<li>能不修改原有代码就不修改，变化的功能完全通过新增代码来解决。(<a href="https://weread.qq.com/web/reader/480322f072021a3248038c8k98f3284021498f137082c2e">OCP原则</a>)</li>
<li>必须修改原有代码时，尽量把代码的变化限制在足够小的范围内。（正交性）
<ul>
<li>模块/类/方法的职责单一化，边界划分时将可能联动的变化隔离 (<a href="https://weread.qq.com/web/reader/480322f072021a3248038c8k1f032c402131f0e3dad99f3">SRP原则</a>)</li>
<li>对代码进行抽象，抽象的东西更具普适性，更容易在变化中做到不变。并且抽象的部分不要依赖于具体的部分（<a href="https://weread.qq.com/web/reader/480322f072021a3248038c8k37632cd021737693cfc7149">DIP原则</a>）</li>
</ul>
</li>
</ul>
<blockquote>
<p>正交性：源于<a href="https://book.douban.com/subject/1152111/">《程序员修炼之道》</a>，是一个核心指导原则。是指当某个模块有修改、变化时，对周边其它模块不造成任何影响。</p>
</blockquote>
<h3 id="设计原则"><a class="header" href="#设计原则">设计原则</a></h3>
<p>根据上面这些推导，就能看出来设计原则也是为了满足目的而总结出来的经验。虽然在<a href="https://weread.qq.com/web/reader/480322f072021a3248038c8kc81322c012c81e728d9d180">《架构整洁之道》</a>中提炼了SOLID五种设计原则，但根据上面的推论，可以看出来OCP/SRP/DIP是更加核心的设计原则。</p>
<p>如果从层次上来讲，OCP应该跟正交性属于同一个层次。</p>
<p>OCP在设计模式中的使用也是非常常用的指导原则，比如<code>观察者模式</code>、<code>职责链</code>、<code>装饰器模式</code>等，都是OCP原则的使用。</p>
<p>OCP也是可大可小的原则，在越大的系统上，OCP越重要。比如互联网，核心层是非常稳定，扩展性非常强，要发布新的网站完全是不需要修改互联网底层。</p>
<blockquote>
<p>互联网的这个例子，来自<a href="https://time.geekbang.org/column/intro/313">软件设计之美</a>，非常具有启发性。</p>
</blockquote>
<p>针对OCP原则，在<a href="https://time.geekbang.org/column/article/176075">《设计模式之美》</a>中提了一个有趣的问题：修改代码就意味着违背开闭原则吗？</p>
<p>其实不一定。比如实现某个需求时，如果在某个类中扩展了一个接口，那么对接口来说是满足OCP，但对类来说是不满足的(对模块和类层次来说也一样)。所以是否满足OCP不能简单一概而论。专栏中给出了这样的结论：<strong>尽量让修改操作更集中、更少，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。</strong></p>
<p>那SOLID中剩余的LSP及ISP原则是有什么用处呢？</p>
<p>LSP(里氏替换原则)从定义上来说：任何基类可以出现的地方，子类都可以替换它。</p>
<p>子类可以完全替换父类，这个约束可以产生什么样的结果呢？</p>
<ul>
<li>子类只能去扩展基类，而不能隐藏或者覆盖基类行为。这其实是对OCP的实践。</li>
<li>抽象层确定下来的行为，具体类不能改变它，只能适应它；也就是实现要依赖于抽象，而非具体。这其实是对DIP的实践。</li>
</ul>
<p>所以本质上LSP是在满足DIP和OCP的原则下推导出的一个具体原则。</p>
<p>ISP(接口隔离原则)从定义上来说：不应强迫使用者依赖于它们不用的方法。ISP有如下作用：</p>
<ul>
<li>源码层面的变化隔离，可以一定程度上提升源码编译速度。</li>
<li>对更高层次模块来说，可以防止不必要依赖变化时，都需要重新编译、布署。</li>
</ul>
<p>ISP与SRP一定程度上有些相似性，但并不一样。ISP更侧重于接口的设计，思考角度也是略不同的。</p>
<p>ISP迫使我们在接口的维度上来思考，使我们站在行为的角度上来思考。行为是更加复杂易变的，实体会更加稳定。那么基于行为进行职责划分与隔离，就更容易封装变化。</p>
<p>除SOLID原则外，还有一些比较有名的指导原则：</p>
<ul>
<li>针对接口编程：本质也是将代码分层，接口设计即抽象层的设计，也即DIP的实践。</li>
<li>KISS：使代码保持简洁。注意，如果问题很复杂，此时解决方案复杂的话，也可以认为是满足KISS原则的。</li>
<li>YAGNI：不要做过度设计。不要提前写用不到的代码，但预留扩展性是必要的。</li>
<li>DRY：完全重复的代码不一定违反DRY，不完全一样的代码也可能违反了DRY。详情可以参考：<a href="https://time.geekbang.org/column/article/179607">重复的代码就一定违背DRY吗？如何提高代码的复用性？</a></li>
<li>LOD：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。 详解参考：<a href="https://time.geekbang.org/column/article/179615">如何用迪米特法则（LOD）实现“高内聚、松耦合”？</a></li>
</ul>
<blockquote>
<p><code>KISS</code>、<code>LOD</code>、<code>YAGNI</code>等原则的一些详细说明，<a href="https://time.geekbang.org/column/intro/250">《设计模式之美》</a> 对这块的详细介绍是很值得看一下的
<code>DRY</code>原则，在《程序员修炼之道》中有更全面的说明，DRY不止指代码层面的重复，还包括意图等方面的重复</p>
</blockquote>
<h3 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h3>
<p>面向对象开发中，代码中遍布着对象。那么面向对象开发中对象及对象关系的处理就是非常重要的。GoF总结的设计模式，也可以围绕对象的关系/行为来理解。</p>
<p>对象的处理，可以划分为如下三种关系/行为：</p>
<ul>
<li>对象的创建</li>
<li>对象间的关系</li>
<li>对象的行为</li>
</ul>
<p>站在这个角度来理解设计模式是更容易理解的。但我们需要先考虑的是，为什么会存在这些设计模式。要研究这个问题，还是需要基于具体场景来看</p>
<blockquote>
<p>比较简单的单例、观察者模式，以及使用场景比较受限的解释器，还有仅为了内存优化而存在的FlyWeight模式并没有涉及</p>
</blockquote>
<h4 id="对象的创建"><a class="header" href="#对象的创建">对象的创建</a></h4>
<p>直接创建一个类会有什么问题呢？可能会违反DIP原则，导致抽象类依赖于具体类。</p>
<p>如何解决这个问题呢？在抽象层中不做具体的创建，只保留基类中对象的引用。只要想办法给引用赋值即可，一种办法是在外部创建好后再传进来(即依赖注入)。如果在对象中存在继承关系，还有一种办法就是在子类中创建。</p>
<p>在子类中创建的方式就是**<code>工厂模式</code>**，具体实现上就是抽象类提供<code>create</code>接口返回具体的对象，子类重载该接口返回具体对象。</p>
<p>有批量对象需要创建，对象之间存在约束：某些类型的对象只能同时使用。为了满足该约束，需要封装创建者，并将创建者也进一步分层为抽象类及具体类，就是**<code>抽象工厂模式</code>**</p>
<p>有批量对象要创建，这些对象创建完之后还需要做进一步拼装/组合等操作，同样需要封装创建者并进行设计分层，将拼装/组合的差异放在具体创建者子类中，就是**<code>创建者模式</code>**</p>
<p>如果要对已有对象(包含状态)进行复制，就是**<code>原型模式</code>**</p>
<p>创建型的设计模式，都在遵循<strong>封装变化</strong>、<strong>对接口编程</strong>这些根本原则。</p>
<h4 id="对象间的关系"><a class="header" href="#对象间的关系">对象间的关系</a></h4>
<p>对象与对象之间有多少种关系呢？</p>
<ul>
<li>继承</li>
<li>包装(包含组合)</li>
</ul>
<p>在什么场景下，可以很好的利用对象关系的处理达到设计的目的呢？</p>
<h5 id="继承"><a class="header" href="#继承">继承</a></h5>
<p>继承重要的作用就是将代码进行分层，分为抽象层与具体层，并且尽量保持抽象层的稳定。（虽然代码复用也是其中一个功能，但并不推荐）</p>
<p>遇到问题需要对类进行分层时，要满足<code>DIP</code>原则的约束，针对这种约束沉淀出来的方案，自然就可以做到具体层可以随意变化，不影响抽象层，抽象层做一些调整时，具体层也可能完全不受影响。这就是**<code>桥接模式</code>**</p>
<h5 id="包装"><a class="header" href="#包装">包装</a></h5>
<p>如果目前已有一个对象，我们希望对其进行扩展或修改时，但又希望满足OCP原则，那如何做呢？（还一种情况，就是原始对象无法修改）</p>
<p>有个办法就是通过一个Wrapper类，来将原有对象包装起来，并用Wrapper来替换原始对象的使用，以此来达到修改原始对象的功能。</p>
<p>要改变原始类的接口名称时，在Wrapper的新接口中调用原始接口，就是**<code>适配器模式</code>**</p>
<p>要扩展原始类的功能时，Wrapper与目标类设计为同样类型的对象。在Wrapper中抽象接口实现时，除了调用目标对象的接口，还补充了自己的逻辑。就是**<code>装饰器模式</code>**</p>
<p>修改原始类的行为时，Wrapper与目标类设计为同样类型的对象。在Wrapper中抽象接口实现时，可以按自己的预期来调整新的行为。就是**<code>代理模式</code>**</p>
<p>如果对象结构间有一种递归性，比如大图案是由小图案组合而成的，并且可以不断递归组合。此时Wrapper与目标类设计为同样的类型对象，并且Wrapper中可以存储多个目标类型对象。Wrapper的接口实现上，会迭代调用内部目标对象的接口。这就是**<code>组合模式</code>**</p>
<p>如果要扩大被包装目标的范围，比如是多个对象，或者某个模块，要对他们的接口进行调整，就可以产生**<code>外观模式</code>**</p>
<h4 id="对象的行为"><a class="header" href="#对象的行为">对象的行为</a></h4>
<p>站在对象的行为上来考虑时，可以更多的从他们的时机和行为上来分析。</p>
<p>如果有一系列操作需要执行，可以将这些操作封装为同一种类型的对象，然后在抽象层可以按序执行它们，就是**<code>Command模式</code>**</p>
<p>如果有一个数据或事件，需要交给多个对象处理或执行。可以将这些处理对象封装为同一类型对象，数据/事件在这个对象链条上进行传递，就是**<code>职责链模式</code>**</p>
<p>如果系统中存在不同的状态，并且这些状态可以随着系统执行不断改变其中的状态时，就可以将这些状态封装为同一类型对象，核心执行逻辑可以不关心使用的具体对象，这就是**<code>状态模式</code>**</p>
<p>如果系统中存在不同的状态，并且在不同场景会使用不同对象时，就可以将这些状态封装为同一类型对象，要使用不同策略，仅需要将策略对象设置给该系统，这就是**<code>策略模式</code>**</p>
<p>如果某容器内有多个元素，想在不了解容器内部实现的情况下枚举其中的内部元素，就可以通过提供统一访问协议，容器来实现该协议以达到遍历的目的。这就是**<code>迭代器模式</code>**</p>
<p>如果某个对象有存取需求，并且不想暴露内部实现，就可以让该对象提供导出/导入状态的接口，在外部来存取相应数据。这就是**<code>备忘录模式</code>**</p>
<p>如果在完成某件任务时，有统一的执行流程，不同场景下的差异仅在于细节上的差异，就可以在抽象层实现流程和通用的执行细节，具体差异部分通过子类重写保留的接口来实现。这就是**<code>模板模式</code>**</p>
<p>如果想在不同场景对容器元素进行遍历操作并得到不同结果，并且要处理的元素类型比较固定，但处理的操作可能易变时，就可以让元素对象提供一个访问接口，然后把要处理的操作封装为<code>访问者对象</code>，访问者对象中可以对不同元素进行不同处理。这样就可以更好的满足OCP原则，这就是<strong>访问者模式</strong></p>
<p>如果一组对象之间相互调用的关系比较复杂，形成了网状的结构时，通过增加一个中间交互对象的方式，来将各对象之间相互的引用解耦开，就是**<code>中介者模式</code>**</p>
<blockquote>
<p>在行为类模式中，状态模式跟策略模式是很像的，从类图上来看也是一致的。但两个模式处理的问题场景是不同的。
比如登录问题很适合用状态模式，登录过程分为几个状态，这几个状态在开始登录后，会自动切换其中的状态，一种状态切为另一种状态可能会执行不同的操作，该系统给外界的反馈可能也会有差异。
一个软件是试用模式还是正式模式，就可以比较适合使用策略模式，比如试用版本时某些功能的调用受限。如果用户付了费，可以直接将另外一个策略替换当前策略。</p>
</blockquote>
<p>其中<code>Command模式</code>、<code>职责链模式</code>、<code>状态模式</code>、<code>策略模式</code>在类结构上是比较相似的，可以用简单语言来描述的其中差异：</p>
<ul>
<li>当一系列对象有统一行为接口，在抽象层可以按序执行它们，就是<code>Command模式</code></li>
<li>当一系列对象有统一行为接口，并且数据或事件会沿着这一系列对象传递时，就是<code>职责链模式</code></li>
<li>当一系列对象有统一行为接口，在不同时机会切换不同的对象，就是<code>状态模式</code></li>
<li>当一系列对象有统一行为接口，在不同的场景使用不同的对象，就是<code>策略模式</code></li>
</ul>
<h3 id="结语"><a class="header" href="#结语">结语</a></h3>
<p>现在再回过头来看，设计模式是什么呢？设计模式其实是针对场景总结出的设计经验。</p>
<p>学习设计模式最重要的是什么？<strong>透彻理解设计原则是最重要的</strong>。如果熟练掌握了设计原则，即使从来不知道设计模式，仍然能在开发过程中自然而然的用上设计模式。</p>
<p>当然并不是说设计模式没有价值，首先是它可以给我们一些指导和演示，告诉我们在某些场景下比较优秀的设计是什么样的。其次它是一种沟通语言，可以在不同的开发之间方便的传达设计思路。</p>
<h3 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h3>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift/blob/master/README-CN.md">设计模式（Swift 5.0 实现）</a></li>
<li><a href="https://share.weiyun.com/unKs5RJG">设计模式迷你手册</a></li>
<li><a href="https://time.geekbang.org/column/intro/250">设计模式之美</a></li>
<li><a href="https://time.geekbang.org/column/intro/313">软件设计之美</a></li>
<li><a href="https://weread.qq.com/web/reader/480322f072021a3248038c8kc81322c012c81e728d9d180">架构整洁之道</a></li>
</ul>
<hr />
<hr />
<hr />
<h2 id="基础概念-3"><a class="header" href="#基础概念-3">基础概念</a></h2>
<p><strong>高内聚</strong>：模块内的元素，关联性越强，则内聚越高。</p>
<p><strong>依赖注入</strong>：当A类依赖于B类时，将B类的初始化等移出去，然后通过构造函数或接口的方式将其设置到A中，这种情况A仅对B的基类进行了依赖</p>
<p><strong>控制反转</strong>：通过一个控制系统(IoC容器)来自动化<code>依赖注入</code>的过程，解除各对象之间直接的联系。</p>
<p><strong>依赖倒置</strong>：直观的概念上，一个对象会依赖内部(实现)组件，依赖倒置即将上层对下层的依赖打破，做到上层仅依赖上层。控制反转就是DIP的一种实践</p>
<h2 id="核心"><a class="header" href="#核心">核心</a></h2>
<p><strong>软件设计的关键任务是职责分配</strong>，可以等同于<strong>分离关注点（正交性）</strong>。</p>
<p>高内聚性一般和许多理想的软件特性有关，包括鲁棒性、可靠度、可复用性及易懂性（understandability）等特性</p>
<h2 id="深入原则"><a class="header" href="#深入原则">深入原则</a></h2>
<ul>
<li><a href="https://blog.csdn.net/tjiyu/article/details/76862525">接口隔离原则（ISP）</a></li>
</ul>
<p>核心支撑：当有变化产生时，影响到的模块越少越好。</p>
<h5 id="srp"><a class="header" href="#srp">SRP</a></h5>
<p>职责越少，改动时越不易受影响</p>
<h5 id="ocp"><a class="header" href="#ocp">OCP</a></h5>
<p>尽可能不影响已有的模块，新增逻辑的风险或变化会更可控</p>
<h5 id="dip"><a class="header" href="#dip">DIP</a></h5>
<p>抽象的代码更稳定、更不容易变更</p>
<h5 id="isp"><a class="header" href="#isp">ISP</a></h5>
<p>不遵守ISP会导致的问题：</p>
<ul>
<li>增加使用者的心智负担</li>
<li>不被使用的接口能力进行调整时，可能对使用者产生影响</li>
</ul>
<h5 id="lsp"><a class="header" href="#lsp">LSP</a></h5>
<p>本质是遵循的如下两个原则：</p>
<ul>
<li>设计和实现要依赖于抽象而非具体； (对DIP的实践)</li>
<li>子类只能去扩展基类，而不是隐藏或者覆盖基类； （对OCP的实践）</li>
</ul>
<h5 id="lod"><a class="header" href="#lod">LOD</a></h5>
<p><a href="https://zhuanlan.zhihu.com/p/36883436">迪米特法则(LOD)</a>：又称<code>最小知识法则</code>，即一个类对其它类知道的越少越好，是对类职责划分做指导的原则。</p>
<h4 id="为什么要依赖于抽象而非具体"><a class="header" href="#为什么要依赖于抽象而非具体">为什么要依赖于抽象而非具体？</a></h4>
<p>抽象更稳定</p>
<h2 id="资料-8"><a class="header" href="#资料-8">资料</a></h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/03wnIHoAe6VyiMur0UvZHA">架构师必须知道的架构设计原则</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计模式-1"><a class="header" href="#设计模式-1">设计模式</a></h1>
<h3 id="概览"><a class="header" href="#概览">概览</a></h3>
<p>面向对象开发中，代码中遍布着对象。那么面向对象开发中对象及对象关系的处理就是非常重要的。所谓的GoF设计模式，也可以围绕对象的关系/行为来理解。</p>
<p>对象的处理，可以划分为如下三种关系/行为：</p>
<ul>
<li>对象的创建</li>
<li>对象间的关系</li>
<li>对象的行为</li>
</ul>
<h4 id="对象的创建-1"><a class="header" href="#对象的创建-1">对象的创建</a></h4>
<p>直接创建一个类会有什么问题呢？可能会违反DIP原则，导致抽象类依赖于具体类。</p>
<p>如何解决这个问题呢？在基类中不做具体的创建，只保留基类中对象的引用。只要想办法给引用赋值即可，一种办法是在外部创建好后再传进来(即依赖注入)。如果在对象中存在继承关系，还有一种办法就是在子类中创建。</p>
<p>抽象类提供<code>create</code>接口返回具体的对象，子类重载该接口返回具体对象，就是**<code>工厂模式</code>**</p>
<p>有批量对象需要创建，对象之间存在约束：某些类型的对象只能同时使用。为了满足该约束，需要封装创建者，并将创建者也进一步分层为抽象类及具体类，就是**<code>抽象工厂模式</code>**</p>
<p>有批量对象要创建，这些对象创建完之后还需要做进一步拼装/组合等操作，同样需要封装创建者并进行设计分层，将拼装/组合的差异放在具体创建者子类中，就是**<code>创建者模式</code>**</p>
<p>如果要对已有对象(包含状态)进行复制，就是**<code>原型模式</code>**</p>
<p>创建型的设计模式，都在遵循<strong>封装变化</strong>、<strong>对接口编程</strong>这些根本原则。而且目前提炼出来的构建型设计模式都是针对特性场景的，如果遇到的问题稍微有些不同，一定要能灵活的根据原则来调整模式。</p>
<h4 id="对象间的关系-1"><a class="header" href="#对象间的关系-1">对象间的关系</a></h4>
<p>对象与对象之间有多少种关系呢？</p>
<ul>
<li>继承</li>
<li>包装(包含组合)</li>
</ul>
<h5 id="继承-1"><a class="header" href="#继承-1">继承</a></h5>
<p>继承重要的作用就是将代码进行分层，分为抽象层与具体层，并且尽量保持抽象层的稳定。（虽然代码复用也是其中一个功能，但并不推荐）</p>
<p>利用对象继承时，需要注意的就是抽象层与具体层之间的依赖关系，需要满足<code>DIP</code>原则。针对这种原则，沉淀出来的具体实践就是**<code>桥接模式</code>**</p>
<h5 id="包装-1"><a class="header" href="#包装-1">包装</a></h5>
<p>可以理解为对象的<code>Hook</code>，即拦截原始对象的调用，来达到某种目的。（为什么不直接修改原始的类呢？最主要的是为了满足OCP原则。其次是有些情况是无法修改原始类。）</p>
<p>当要改变原始类的接口名称时，就是**<code>适配器模式</code>**</p>
<p>当要扩展原始类的功能时，就是**<code>装饰器模式</code>**</p>
<p>当要修改原始类的行为时，就是**<code>代理模式</code>**</p>
<p>如果对象结构间有一种递归性，被包装的对象同样可以是包装对象时，就是**<code>组合模式</code>**</p>
<p>如果要扩大被包装目标的范围，比如是多个对象，或者某个模块，要对他们的接口进行调整，就可以产生**<code>外观模式</code>**</p>
<h5 id="结构模式另一种描述"><a class="header" href="#结构模式另一种描述">结构模式另一种描述</a></h5>
<p>桥接模式：依赖倒置原则的一种实现，简单理解为<code>依赖注入</code>的实现结构。</p>
<p>适配器：简单理解就是转接头，将已有对象的接口，转为需要的接口。</p>
<p>装饰者模式：想灵活的给某些对象扩展功能就可以用装饰者模式。相比通过继承来扩展，装饰者模式可以给对象，而非类扩展功能。</p>
<p>代理模式：为了控制某个对象的操作行为，比如C++中的智能指针类就是典型的代理模式实现的。</p>
<p>组合模式：当某种结构有递归性时，就可以考虑组合模式。</p>
<p>外观模式：将一个子系统进行封装，提供一个高层接口来简化使用</p>
<p>FlyWeight模式：纯粹是为了减少运行时内存占用，这个模式并不是从代码的可维护角度来提出的</p>
<h4 id="对象的行为-1"><a class="header" href="#对象的行为-1">对象的行为</a></h4>
<p>当一系列对象有统一行为接口，在抽象层可以按序执行它们，就是**<code>Command模式</code>**</p>
<p>当一系列对象有统一行为接口，并且数据或事件会沿着这一系列对象传递时，就是**<code>职责链模式</code>**</p>
<p>当一系列对象有统一行为接口，在不同时机使用不同的对象，就是**<code>状态模式</code>**</p>
<p>当一系列对象有统一行为接口，在不同的场景使用不同的对象，就是**<code>策略模式</code>**</p>
<p>屏蔽容器的内部实现，提供特定的接口来遍历容器内部的元素，就是**<code>迭代器模式</code>**</p>
<p>屏蔽对象的内部实现，对象通过特定接口来导出内部状态，并且将导致的状态保存至外部某处，并且提供了还原状态的方式。这就是**<code>备忘录模式</code>**</p>
<p>在不同场景下，操作步骤相同，但某些步骤实现有差异，就是**<code>模板模式</code>**</p>
<p>不同场景对容器执行遍历操作得出不同的结果，为了满足OCP原则而产生的就是<strong>访问者模式</strong></p>
<p>一组对象之间相互调用的关系比较复杂，形成了网状的结构时，通过增加一个中间交互对象的方式，来将各对象之间相互的引用解耦开，就是**<code>中介者模式</code>**</p>
<h3 id="资料-9"><a class="header" href="#资料-9">资料</a></h3>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift/blob/master/README-CN.md">设计模式（Swift 5.0 实现）</a></li>
<li><a href="https://share.weiyun.com/unKs5RJG">设计模式迷你手册</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文档"><a class="header" href="#文档">文档</a></h1>
<p>流程图、架构图、类图等，有两个通用目的：</p>
<ul>
<li>将自己的想法明确的表述出来，并提前与人讨论沟通，以发现其中的问题。</li>
<li>可以作为项目的概览文档，方便按图索骥</li>
</ul>
<p><a href="https://www.infoq.cn/article/c4-architecture-model">用于软件架构的 C4 模型</a></p>
<h2 id="uml"><a class="header" href="#uml">UML</a></h2>
<p><a href="https://weread.qq.com/web/reader/3a332a1071f94aa23a37cc6kc81322c012c81e728d9d180">UML精粹</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35791964">那些年，产品经理er画过的流程图</a></p>
<p>统一建模语言，下面有各种使用，如流程图、类图等等。</p>
<h3 id="流程图"><a class="header" href="#流程图">流程图</a></h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/25020707">干货！如何绘制产品流程图</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/67533900">关于流程图，你想知道的都在这里</a></li>
</ul>
<p>目的：</p>
<ul>
<li>清楚的描述产品的流程和边界
<ul>
<li>梳理清楚活动流程的先后顺序</li>
<li>帮我们查漏补缺</li>
</ul>
</li>
<li>提升沟通效率</li>
</ul>
<p>种类：</p>
<ul>
<li>业务流程图</li>
<li>任务流程图</li>
<li>页面流程图</li>
<li>逻辑流程图</li>
</ul>
<h3 id="类图"><a class="header" href="#类图">类图</a></h3>
<p><a href="https://zhuanlan.zhihu.com/p/109655171">30分钟学会UML类图</a></p>
<h3 id="泳道图"><a class="header" href="#泳道图">泳道图</a></h3>
<p><a href="https://zhuanlan.zhihu.com/p/139206226">如何绘制泳道图？3步就能快速上手！</a></p>
<p>也叫跨职能流程图，旨在展示工作流中每个步骤涉及的流程和职能模块。</p>
<h3 id="时序图"><a class="header" href="#时序图">时序图</a></h3>
<h3 id="状态图"><a class="header" href="#状态图">状态图</a></h3>
<h3 id="甘特图"><a class="header" href="#甘特图">甘特图</a></h3>
<h3 id="协作图"><a class="header" href="#协作图">协作图</a></h3>
<h3 id="用例图"><a class="header" href="#用例图">用例图</a></h3>
<p><a href="https://www.jianshu.com/p/3cde67aed8e9">UML—用例图，Use Case</a></p>
<p>用例图是描述用例、参与者以及它们之间关系的图。</p>
<blockquote>
<p>用例是用户期望系统具备的功能，每一个用例说明一个系统提供给它的使用者的一种服务或功能。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios"><a class="header" href="#ios">iOS</a></h1>
<h3 id="资料-10"><a class="header" href="#资料-10">资料</a></h3>
<p><a href="https://juejin.im/user/5a52075e6fb9a01c9d31b107/posts">老司机iOS周报</a></p>
<p><a href="https://developer.apple.com/download/more/">Xcode官网下载</a></p>
<p><a href="https://github.com/futurice/ios-good-practices">iOS最佳实践</a></p>
<p><a href="https://juejin.cn/post/6864492188404088846">深入探索 iOS 内存优化</a></p>
<p><a href="https://juejin.cn/post/6844904058109575175">App 如何通过注入动态库的方式实现极速编译调试？</a></p>
<h3 id="arc"><a class="header" href="#arc">ARC</a></h3>
<p><a href="https://zhuanlan.zhihu.com/p/81449078"> ARC 实现的原理</a></p>
<h3 id="lldb"><a class="header" href="#lldb">LLDB</a></h3>
<p><a href="https://www.jianshu.com/p/29c9aee9cbf4">LLDB常用命令</a></p>
<p><a href="iOS/%5Bchisel%5D(https://github.com/facebook/chisel)">chisel</a>：facebook开源lldb插件</p>
<p>LLDB支持插件开发：<a href="https://www.jianshu.com/p/b3854a648dad">LLDB插件(三)</a></p>
<h4 id="命令-1"><a class="header" href="#命令-1">命令</a></h4>
<ul>
<li><code>expression somesth</code>：执行某个表达式</li>
<li><code>call somesth</code>：调用某个方法</li>
<li><code>bt 5</code>：打印当前堆栈，且只打印5帧</li>
<li><code>thread list</code>：查看线程列表</li>
<li><code>thread return 10</code>：直接从当前方法中返回，且返回值为10</li>
<li><code>c</code>：继续</li>
<li><code>n</code>：下一步</li>
<li><code>s</code>：进入</li>
<li><code>f</code>：跳出</li>
<li><code>frame select N</code>：当前堆栈中，跳至第N帧</li>
<li><code>frame variable ***</code>：查看帧变量（不指定具体变量，查看所有本地变量）</li>
<li><code>target variable ***</code>：查看全局变量（不指定具体变量名，即可查看所有）</li>
<li><code>image lookup -address 0x***</code>：查看指定地址的信息</li>
<li><code>image lookup -name</code>：查找方法来源，可以查看所有库中指定名称的方法</li>
<li><code>image lookup -type</code>：查看某个类的所有成员</li>
<li><code>breakpoint set -f ViewController.m -l 30</code>：在指定文件中指定行打断点</li>
<li><code>breakpoint set -n viewDidLoad</code>：会在所有viewDidLoad上打断点</li>
<li><code>breakpoint set -n &quot;-[MobShareViewController viewDidLoad]&quot;</code>：在指定类的指定方法上打断点</li>
<li><code>breakpoint delete 编号</code>：删除指定断点（不指定编号即清除所有）</li>
<li><code>breakpoint set -f MOBQQViewController.m -l 50 -c &quot;parameters != nil&quot;</code>：在指定位置添加符号断点，判断条件是c参数之后的字符串</li>
<li><code>breakpoint list</code>：查看断点列表</li>
<li><code>breakpoint disable/enable 2</code>：禁用/启用指定断点</li>
<li><code>watchpoint set variable b</code>：设置观察点，监听b变量，当其有改变时，会断下来</li>
<li><code>watchpoint set expression 0x7ffee1c1f0fc</code>：直接对指定内存地址进行监听</li>
<li><code>watchpoint list</code>：查看观察点</li>
<li><code>watchpoint delete 编号</code>：删除观察点（不指定编号即清除所有）</li>
<li><code>target stop-hook command</code>：可以在断点断下来之后，就自动执行指定的command</li>
<li><code>target stop-hook list</code>：列出所有的hook指令</li>
</ul>
<blockquote>
<p>观察点，有软件/硬件实现之分。软件实现的话，执行速度比正常执行要慢非常多（上百倍）。硬件观察点，速度基本不受影响。目前Xcode调试也支持了硬件观察点，设置观察点时就可以看到相关信息：</p>
<p>Number of supported hardware watchpoints: 4</p>
</blockquote>
<h4 id="别名"><a class="header" href="#别名">别名</a></h4>
<table><thead><tr><th>原名</th><th>别名</th></tr></thead><tbody>
<tr><td>print</td><td>p</td></tr>
<tr><td>expression</td><td>expr</td></tr>
</tbody></table>
<p>可以自定义别名：</p>
<p><code>command alias pb thread backtrace</code>：即可将pb定义为<code>thread backtrace</code></p>
<h3 id="多媒体"><a class="header" href="#多媒体">多媒体</a></h3>
<p><a href="https://juejin.cn/post/6864462772436992008">Metal入门</a></p>
<p>metal在模拟器上是使用不了的</p>
<p><a href="https://zhuanlan.zhihu.com/p/30591648">iOS平台图片编解码入门教程（Image/IO篇）</a></p>
<h3 id="动态库--静态库"><a class="header" href="#动态库--静态库">动态库 &amp; 静态库</a></h3>
<p><a href="https://www.jianshu.com/p/ceb33cff30f6">动态库的加载顺序</a></p>
<p><a href="https://github.com/Damonvvong/DevNotes/blob/master/Notes/framework2.md">iOS 开发中的『库』</a></p>
<p>静态库：编译时跟App链接在一起，启动时间会更少、安装包大小更小。</p>
<p>动态库：动态库分两种，一种是系统的tbd、dylib。一种是.framework。</p>
<ul>
<li>tbd是系统使用的，真正的动态库。</li>
<li>framework是动态加载到进程内存空间的，更多是为了同一进程内的多个目标使用。比如缩主和Extension可以共享。</li>
<li>framework可以使用dlopen来加载。</li>
<li>.tbd 其实是一个YAML本文文件，描述了需要链接的动态库的信息。主要目的是为了减少app 的下载大小。</li>
</ul>
<h3 id="崩溃"><a class="header" href="#崩溃">崩溃</a></h3>
<p><a href="https://time.geekbang.org/column/article/88600">iOS 崩溃千奇百怪，如何全面监控？</a></p>
<ul>
<li>Crash Sdk是通过注册异常信号来捕获异常的。</li>
<li>捕捉到异常再用<code>backtrace</code>接口来获取当前堆栈信息</li>
</ul>
<h3 id="日志"><a class="header" href="#日志">日志</a></h3>
<h4 id="nslog"><a class="header" href="#nslog">NSLog</a></h4>
<p>本质也是<code>ASL</code>(Apple System Logger)</p>
<p><code>aslMessageReceived</code>接收日志，<code>asl_get</code>解码日志。</p>
<h3 id="runloop"><a class="header" href="#runloop">Runloop</a></h3>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></p>
<p>是一个运行循环，有事情时处理事情，没有事情时休眠。</p>
<p>作用：</p>
<ul>
<li>保持程序的持续运行g</li>
<li>处理各种事件</li>
<li>节省CPU资源，提高程序性能</li>
</ul>
<p>特点：</p>
<ul>
<li>一个线程对应一个Runloop</li>
<li>子线程Runloop的创建是发生在第一次获取时，Runloop的销毁是发生在线程结束时</li>
<li>一个Runloop中包含多个Mode</li>
<li>每个Mode包含若干个Source/Timer/Observer</li>
</ul>
<blockquote>
<p>Source主要用来跟其它线程互发消息使用</p>
<p>Observer可以监听：即将进入loop、即将处理timer、即将处理Source、即将进入休眠、刚从休眠中唤醒、即将退出loop这些事件。</p>
<p><code>performSelector:</code>异步执行某个接口时，其实现也是通过添加timer来做的。</p>
</blockquote>
<p>Runloop类型：</p>
<ul>
<li>NSDefaultRunLoopMode：默认的模式</li>
<li>UITrackingRunLoopMode：界面跟踪，用于scrollView拖拽滑动</li>
<li>NSRunLoopCommonModes：综合模式</li>
</ul>
<p>示意图：（来源：https://www.jianshu.com/p/d8c3a65b6e19）</p>
<img src="iOS/./images/runloop.png" style="zoom:80%;" />
<p>Timer与Runloop结合的使用：</p>
<ul>
<li>子线程中启动Timer，需要手动将其加入到当前runloop中</li>
<li>如果当前线程的runloop还没有启动过，还需要调用一下<code>run</code>接口</li>
<li>子线程释放Timer也需要注意，<code>timer.invalidate()</code>的调用线程要与Timer的创建线程是同一个</li>
</ul>
<h3 id="xcode"><a class="header" href="#xcode">Xcode</a></h3>
<p>Xcode中的<code>Do no embed</code>等作用：https://stackoverflow.com/questions/57687170/do-not-embed-embed-sign-embed-without-signing-what-are-they-what-th</p>
<p>汇编调度：Xcode-&gt;Debug-&gt;Debug workflow-&gt;Always Show Disassembly</p>
<h3 id="内存"><a class="header" href="#内存">内存</a></h3>
<p><a href="https://juejin.cn/post/6864492188404088846">深入探索 iOS 内存优化</a></p>
<h4 id="缺页中断类型"><a class="header" href="#缺页中断类型">缺页中断类型</a></h4>
<ul>
<li>Hard Page Fault：物理内存中没有对应页，需要从磁盘读取</li>
<li>Soft Page Fault：物理内存中存在对应页，其它进程可能正在处理。只要用MMU建立映射</li>
<li>Invalid Page Fault：会触发SIGSEGV异常，导致应用中止。</li>
</ul>
<h4 id="内存布局"><a class="header" href="#内存布局">内存布局</a></h4>
<p><img src="iOS/./images/memory_layout.jpeg" alt="" /></p>
<h4 id="内存压缩"><a class="header" href="#内存压缩">内存压缩</a></h4>
<p>在iOS上，虚拟内存机制，并不是跟磁盘进行交换。而是将最久不使用的内存（LRU）进行压缩。当内存需要使用时，再解压。</p>
<h4 id="foom"><a class="header" href="#foom">FOOM</a></h4>
<p>即前台内存占用过多被杀，检测方法：</p>
<p>1.App没有升级</p>
<p>2.App没有调用exit()或abort()退出</p>
<p>3.App没有出现Crash (依赖于自身CrashReport组件的Crash回调)</p>
<p>4.用户没有强退App</p>
<p>5.系统没有升级/重启</p>
<p>6.App当时没有后台运行（依赖于ApplicationState和前后台切换通知）</p>
<p>7.App出现FOOM （依赖于ApplicationState和前后台切换通知）</p>
<h4 id="内存问题情况"><a class="header" href="#内存问题情况">内存问题情况</a></h4>
<ul>
<li>leaked Memory：有retain，但没对应release导致的（MRC容易出现）</li>
<li>Abandoned Memory：循环引用导致的</li>
<li>Zombies：即僵尸对象，已经释放了，但仍然可能被使用</li>
</ul>
<h3 id="图形处理"><a class="header" href="#图形处理">图形处理</a></h3>
<p><a href="https://www.jianshu.com/p/d2817058c901">使用渐进式 JPEG 来提升用户体验</a>：渐进式图片是需要图片本身支持</p>
<p>图片所占内存的大小与图片的尺寸有关，而不是图片的文件大小</p>
<h4 id="cpu--gpu"><a class="header" href="#cpu--gpu">CPU &amp; GPU</a></h4>
<p>在图形处理过程中，CPU的作用是将相应需要展示的内存数据准备好</p>
<p>GPU是拿这些内存数据，转化为可以直接渲染的数据。其中有多步：</p>
<ul>
<li>3D坐标转化为2D坐标</li>
<li>2D坐标转化为实际像素
<ul>
<li>顶点着色器</li>
<li>形状装配</li>
<li>几何着色器</li>
<li>光栅化</li>
<li>片段着色器</li>
<li>测试与混合</li>
</ul>
</li>
</ul>
<h4 id="原生渲染"><a class="header" href="#原生渲染">原生渲染</a></h4>
<p><a href="https://time.geekbang.org/column/article/101639">iOS原生、大前端和Flutter分别是怎么渲染的？</a></p>
<ul>
<li>更新视图树，同步更新图层树</li>
<li>CPU计算要显示的内容（包括布局计算、图像解码等），然后转至Render Server</li>
<li>数据到达Render Server后，按照图层树中图层顺序、RGBA值等等，转成渲染树给OpenGL / Metal</li>
<li>Render Server调用GPU进行处理</li>
</ul>
<blockquote>
<p>前三步，被称为Commit Transaction</p>
</blockquote>
<p><img src="iOS/./images/render_step.png" alt="" /></p>
<h3 id="黑暗模式适配"><a class="header" href="#黑暗模式适配">黑暗模式适配</a></h3>
<p><a href="https://juejin.im/post/5cf6276be51d455a68490b26">iOS13-适配夜间模式/深色外观(Dark Mode)</a></p>
<h4 id="注意问题"><a class="header" href="#注意问题">注意问题</a></h4>
<p>要关掉黑暗模式，需要在<code>info.plist</code>中添加如下KV值：</p>
<pre><code>Key: UIUserInterfaceStyle
Value: Light
</code></pre>
<p><font color=#f33 size=5>注意：</font><br />
工程中如果有Extension，则Extension的配置文件也需要改，否则扩展还是默认会打开黑暗模式。</p>
<p>但是经测试，<strong>Today Extension</strong> 即使关掉了黑暗模式，背景仍然会以黑暗模式的形式来展示。（为了防止系统级体验不好，也是合理）。所以Today Extension最好适配黑暗模式</p>
<h3 id="universal-links支持"><a class="header" href="#universal-links支持">Universal Links支持</a></h3>
<p><a href="https://www.jianshu.com/p/03e6b7828307">iOS的UniversalLink开发总结</a></p>
<p><a href="https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Access_Guide/iOS.html">微信支持Universal Links指导</a></p>
<h4 id="关注点"><a class="header" href="#关注点">关注点</a></h4>
<ul>
<li>一个应用是可以支持多个Universal Link的</li>
<li><code>apple-app-site-association</code>可以放在<code>https://domain/apple-app-site-association</code>也可以放在<code>https://domain/.well-known/apple-app-site-association</code>，建议放在.well-known路径下，而且苹果会优先下载这个位置的配置文件</li>
<li><code>apple-app-site-association</code>中<code>details</code>字典搜索顺序是从上至下，把希望优先匹配的内容放在前面</li>
<li>path匹配是支持*和?的，*表示匹配任意字符，?表示匹配一个字符，?*表示匹配至少一个字符。</li>
</ul>
<h3 id="其它-2"><a class="header" href="#其它-2">其它</a></h3>
<p><a href="https://swift.gg/2015/11/25/tvos-introduction/">tvOS 入门：开发你的第一个 tvOS 应用</a></p>
<p><a href="http://www.woshipm.com/pd/4150041.html">iOS14新增了ATT权限</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="性能相关"><a class="header" href="#性能相关">性能相关</a></h1>
<h3 id="资料-11"><a class="header" href="#资料-11">资料</a></h3>
<p><a href="https://github.com/skyming/iOS-Performance-Optimization">iOS 性能优化合集</a></p>
<p>手机淘宝对应用启动、运行等性能分析：<a href="http://pstatic.geekbang.org/pdf/593a53d813cef.pdf?e=1497499485&amp;token=eHNJKRTldoRsUX0uCP9M3icEhpbyh3VF9Nrk5UPM:sa-xp_aIeIhtiWbqR-hY4ImMzFc=">手淘iOS性能优化探索</a></p>
<p><a href="http://cdn.cocimg.com/bbs/attachment/Fid_6/6_24457_90eabb4ed5b3863.pdf">Instruments中文手册</a></p>
<p><a href="https://www.huaweicloud.com/articles/4e3d0e49d511fcedb5c7ca4f3e45ceae.html">iOS 线上app性能检测 内存、CPU、FPS</a></p>
<p><a href="https://github.com/Tencent/matrix/wiki/Matrix-for-iOS-macOS-%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86">Matrix for iOS macOS 卡顿监控原理</a></p>
<p><a href="https://developer.apple.com/cn/documentation/xcode/improving_your_app_s_performance/">改进App的性能（官方）</a></p>
<p><a href="https://www.jianshu.com/p/108bd061771e">iOS MetricsKit 收集电量和性能数据</a></p>
<p><a href="https://juejin.cn/post/6844904018846679053">iOS13+ 性能和耗电量信息收集框架</a></p>
<h3 id="安装包大小"><a class="header" href="#安装包大小">安装包大小</a></h3>
<p><a href="https://www.infoq.cn/article/iowjwhbirqeobzf5m2o8">今日头条 iOS 安装包大小优化</a></p>
<h4 id="app-thinning"><a class="header" href="#app-thinning">App Thinning</a></h4>
<p>根据不同设备，下载不同的资源、架构的二进制包。</p>
<p>在Appstore上看到的应用大小，就是经过App Thinning，在本机安装后的大小。</p>
<p>具体分为三种方式：</p>
<ul>
<li>App Slicing：针对不同设备，对App切割成不同变体</li>
<li>Bitcode：针对特定设备进行包大小优化（目前优化不明显，为未来预留可能性）</li>
<li>On-Demand Resources：主要是游戏场景，如关卡资源等使用。</li>
</ul>
<p>通过Asset管理的资源，会自动被App Slicing处理。</p>
<h4 id="资源压缩"><a class="header" href="#资源压缩">资源压缩</a></h4>
<p>ImageOptim</p>
<h3 id="启动过程"><a class="header" href="#启动过程">启动过程</a></h3>
<p><a href="https://time.geekbang.org/column/article/85331">App 启动速度怎么做优化与监控？</a></p>
<p><a href="https://www.jianshu.com/p/108bd061771e">iOS MetricsKit 收集电量和性能数据</a></p>
<p>从大的过程上来说，分为三个阶段：<code>main前</code>、<code>main后</code>、<code>首屏渲染完成</code></p>
<h4 id="main前"><a class="header" href="#main前">main前</a></h4>
<ul>
<li>加载可执行文件</li>
<li>加载动态链接库</li>
<li>OC运行时环境初始化</li>
<li>初始化，包括<code>+load()</code>、<code>创建C++静态全局变量</code>等</li>
</ul>
<p>此阶段可优化工作：</p>
<ul>
<li>减少动态链接库（苹果建议最多使用6个非系统动态库，也可以尝试合并动态库）</li>
<li>减少无用代码</li>
<li>减少+load方法的使用 (可以使用+initialize方法替换，该方法在类的第一个方法调用前才会调用)</li>
<li>减少类似C++全局变量数量</li>
</ul>
<blockquote>
<p>Swift不支持静态库，引用的库必须是framework的，所以Swift代码中引入的第三方，需要编译为framework的</p>
</blockquote>
<h4 id="main后"><a class="header" href="#main后">main后</a></h4>
<p>指main至didFinishLaunchingWithOptions首屏渲染相关方法执行完成。</p>
<ul>
<li>首屏初始化所需配置文件读写操作</li>
<li>首屏列表大数据读取</li>
<li>首屏渲染大量计算</li>
</ul>
<p>此阶段可以优化工作：</p>
<ul>
<li>此阶段只做首屏渲染必要的初始化功能，要从业务逻辑上梳理清楚。</li>
</ul>
<h4 id="首屏渲染完成后"><a class="header" href="#首屏渲染完成后">首屏渲染完成后</a></h4>
<p>此时已经可以看到首屏了。具体优化是跟业务有更强的关联性。</p>
<h4 id="启动耗时监控"><a class="header" href="#启动耗时监控">启动耗时监控</a></h4>
<h5 id="dyld_print_statistics"><a class="header" href="#dyld_print_statistics">DYLD_PRINT_STATISTICS</a></h5>
<p>在<code>Edit scheme -&gt; Run -&gt; Arguments</code>中，设置如下的环境变量，即可查看启动时间</p>
<ul>
<li><code>DYLD_PRINT_STATISTICS</code>设为1</li>
<li><code>DYLD_PRINT_STATISTICS_DETAILS</code>设为1，可以查看更详细的信息</li>
</ul>
<h5 id="metricskit-test"><a class="header" href="#metricskit-test">MetricsKit Test</a></h5>
<pre><code class="language-oc">// 测试代码中测试
- (void)testLaunchPerformance {
    if (@available(macOS 10.15, iOS 13.0, tvOS 13.0, *)) {
        [self measureWithMetrics:@[XCTOSSignpostMetric.applicationLaunchMetric] block:^{
            [[[XCUIApplication alloc] init] launch];
        }];
    }
}
</code></pre>
<h4 id="线上精确度量启动时间"><a class="header" href="#线上精确度量启动时间">线上精确度量启动时间</a></h4>
<p><a href="https://www.jianshu.com/p/c14987eee107">如何精确度量 iOS App 的启动时间</a></p>
<p>iOS13之后，使用 <a href="https://developer.apple.com/cn/documentation/xcode/improving_your_app_s_performance/">MetricsKit</a></p>
<p>MetricsKit使用不错的文档：<a href="https://juejin.cn/post/6844904018846679053">iOS13+ 性能和耗电量信息收集框架</a></p>
<h3 id="性能监控方法"><a class="header" href="#性能监控方法">性能监控方法</a></h3>
<ul>
<li>每隔一段时间截取一下堆栈信息，根据堆栈里的调用栈判断某函数存在的时间（也即执行的时间，Time Profiler也是这种方案）</li>
<li>hook <code>objc_msgSend</code>，统计所有执行耗时</li>
</ul>
<p>hook <code>objc_msgSend</code> 方法：</p>
<ul>
<li>使用fishhook工具 （通过重新绑定符号实现C接口的替换）</li>
<li>写相应的自己的<code>objc_msgSend</code>方法进行替换</li>
</ul>
<h3 id="卡顿监控"><a class="header" href="#卡顿监控">卡顿监控</a></h3>
<p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios">iOS 保持界面流畅的技巧</a></p>
<p>卡顿监控实现方式有两种：</p>
<ul>
<li>监听主线程Runloop来实现</li>
<li>监听<code>CADisplayLink</code>时间间隔来实现</li>
</ul>
<h5 id="利用runloop来监控即可"><a class="header" href="#利用runloop来监控即可">利用Runloop来监控即可</a></h5>
<p>原理：监听主线程的Runloop，监听其开始和结束时间，当消耗的时间超过一定的阈值，就认为卡顿。 (这个是微信的Matrix实现方案)</p>
<blockquote>
<p>在微信的实现中，有使用退火算法来优化。 具体参考：<a href="https://github.com/Tencent/matrix/wiki/Matrix-for-iOS-macOS-%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86">Matrix for iOS macOS 卡顿监控原理</a></p>
</blockquote>
<h5 id="cadisplaylink实现"><a class="header" href="#cadisplaylink实现">CADisplayLink实现</a></h5>
<p>手Q Blue组件，通过<code>CADisplayLink</code>两次回调时间间隔来预测掉的帧。时间间隔为<code>33.2ms~49.8ms</code>认为是掉了一帧。原因是该回调接口至少也有16.6ms的间隔。</p>
<h3 id="内存-1"><a class="header" href="#内存-1">内存</a></h3>
<p>JetSam机制，是操作系统为了控制内存资源过度使用而采用的一种资源管控机制。</p>
<p>从设置 -&gt; 隐私 -&gt; 分析中，查看<code>JetsamEvent</code>开头的日志，可以看到App内存限制。</p>
<h3 id="电量"><a class="header" href="#电量">电量</a></h3>
<p><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/">官方电量优化指南</a></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2017/238/">WWDC2017-优化电量</a></p>
<p>电量的消耗，本质还是计算资源的消耗。</p>
<p>移动端的电量是稀缺品，用户对电量也是非常敏感的。苹果的新系统也支持了查看每个应用对电量的消耗。</p>
<p>要想分析电量的消耗，可以通过如下方法：</p>
<ul>
<li>首先获取所有线程信息。 (<code>task_threads</code>接口可以获取)</li>
<li>获取到的线程信息数组，是<code>thread_basic_info</code>结构数组</li>
<li>在该结构中，有<code>cpu_usage</code>字段，存储了该信息</li>
<li>如果某个线程的该字段，长时间都是高占用，就需要仔细分析该线程</li>
</ul>
<p>电量优化：</p>
<ul>
<li>大数据量的复杂计算，通过<code>dispatch_block_create_with_qos_class</code>指定队列Qos为<code>QOS_CLASS_UTILITY</code>，这个队列里的任务有专门做了电量优化。</li>
<li>利用GPU做密集计算</li>
<li>将一些操作可以放后台计算</li>
<li>利用<code>NSCache</code>，将批量的I/O操作统一写入磁盘</li>
</ul>
<p>官方的其它优化建议：</p>
<ul>
<li>少做后台任务</li>
<li>少用Timer</li>
<li>监听用户是否开了低电量模式，低电量模式可以做不同的优化 （<code>NSProcessInfoPowerStateDidChangeNotification</code>）</li>
<li>……</li>
</ul>
<h3 id="instruments"><a class="header" href="#instruments">Instruments</a></h3>
<p><a href="https://time.geekbang.org/column/article/90546">性能监控：衡量 App 质量的那把尺</a></p>
<p>Instruments能力：（有部分能力在模拟器上是不支持的）</p>
<ul>
<li>
<p>App Launch：统计启动耗时，并有相应接口的耗时细节</p>
</li>
<li>
<p>Activity Monitor：监视CPU、内存、磁盘、网络等信息</p>
</li>
<li>
<p>Allocations：匿名虚拟内存及堆的状态，可以查看内存增长时主要是哪些对象的申请导致的</p>
</li>
<li>
<p>Animation Hitches：动画、滚动等性能检测</p>
</li>
<li>
<p>Energy Log：电量使用信息</p>
</li>
<li>
<p>Leaks：检查泄露内存</p>
</li>
<li>
<p>Zombies：测量一般内存使用情况，并关注过度释放的Zobies对象检测</p>
</li>
<li>
<p>Time Profiler：对相应进程执行进行采样</p>
</li>
</ul>
<p>Instruments支持开发自定义插件</p>
<h4 id="signpost"><a class="header" href="#signpost">Signpost</a></h4>
<p>支持在Instrument中显示自定义事件：<a href="http://blog.chendongnan.com/2019/06/30/WWDC2019Session411-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Instrument/">WWDC 2019 Session 411译文</a></p>
<h3 id="metrics"><a class="header" href="#metrics">Metrics</a></h3>
<p>WWDC：</p>
<ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2019/417">Improving Battery Life and Performance</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2020/10081">What's new in MetricKit</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2021/10181/">Ultimate application performance survival guide</a></li>
</ul>
<p>其它：</p>
<ul>
<li><a href="https://www.raywenderlich.com/20952676-monitoring-for-ios-with-metrickit-getting-started">Monitoring for iOS with MetricKit: Getting Started</a></li>
</ul>
<p>测试指定性能指标：</p>
<pre><code class="language-oc">- (void)testReSizeImagePerformance {
    __auto_type app = [XCUIApplication new];
    [self
        measureWithMetrics:@[
            XCTMemoryMetric.new,
            XCTClockMetric.new,
            XCTCPUMetric.new
        ]
        block:^{
            [app.buttons[@&quot;reSize&quot;] tap];
        }];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui相关"><a class="header" href="#ui相关">UI相关</a></h1>
<h3 id="资料-12"><a class="header" href="#资料-12">资料</a></h3>
<p><a href="https://zhuanlan.zhihu.com/p/72653360">关于iOS离屏渲染的深入研究</a></p>
<p><a href="https://juejin.cn/post/6844903663853387783">iOS性能优化 - 工具Instruments之CoreAnimation</a></p>
<p><a href="https://zsisme.gitbooks.io/ios-/content/index.html">iOS核心动画编程</a></p>
<h3 id="基础概念-4"><a class="header" href="#基础概念-4">基础概念</a></h3>
<h4 id="uiview"><a class="header" href="#uiview">UIView</a></h4>
<ul>
<li>处理触摸事件</li>
<li>可以支持基于Core Graphics绘图</li>
<li>可以做仿射变换</li>
<li>支持简单动画</li>
</ul>
<h4 id="calayer"><a class="header" href="#calayer">CALayer</a></h4>
<ul>
<li>一些属性用来做动画和变化</li>
<li>不处理用户交互</li>
<li>每个UIView都有一个CALayer实例的图层属性</li>
<li>UIView其实只是对CALayer的封装，提供一些触摸处理的功能。具体显示和动画是在CALayer中做的。</li>
</ul>
<h3 id="calayer-1"><a class="header" href="#calayer-1">CALayer</a></h3>
<p>CALayer能力：</p>
<ul>
<li>阴影、圆角、带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>
<p>使用：</p>
<ul>
<li>可以自己创建CALayer，加到UIView的layer上</li>
<li>有<code>contents</code>属性，其可以设置为CGImage</li>
<li>有<code>contentsGravity</code>属性，可以设置图片的布局样式</li>
<li><code>masksToBounds</code>可以裁剪区域之外的部分</li>
<li>……</li>
</ul>
<h3 id="离屏渲染"><a class="header" href="#离屏渲染">离屏渲染</a></h3>
<p>定义：如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域，而这也是GPU存储渲染结果的地方。如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。</p>
<p>常规认为的CPU渲染，只是“软件渲染”，而真正的离屏渲染是发生在GPU中的。</p>
<p>离屏渲染的性能影响：本身GPU是流水线化的操作，当需要离屏渲染时，就需要将当前操作移至另外一个buffer中操作，并且最终做裁剪、混合等。操作完之后再拷贝回来。这本身就是有很大的损耗。</p>
<p>在<a href="https://zhuanlan.zhihu.com/p/72653360">《关于iOS离屏渲染的深入研究》</a>中，将离屏渲染的原因定义为如下：（如圆角会触发离屏渲染）</p>
<ul>
<li>将一个layer的内容裁剪成圆角，可能不存在一次遍历就能完成的方法</li>
<li>容器的子layer因为父容器有圆角，那么也会需要被裁剪，而这时它们还在渲染队列中排队，尚未被组合到一块画布上，自然也无法统一裁剪</li>
</ul>
<p>此时我们就不得不开辟一块独立于frame buffer的空白内存，先把容器以及其所有子layer依次画好，然后把四个角“剪”成圆形，再把结果画到frame buffer中。这就是GPU的离屏渲染。</p>
<p>常见离屏渲染场景：</p>
<ul>
<li>cornerRadius+clipsToBounds （圆角，同时裁剪，原因如上）</li>
<li>shadow</li>
<li>group opacity</li>
<li>mask</li>
<li>UIBlurEffect</li>
</ul>
<p>即刻App优化：</p>
<ul>
<li>使用异步框架 (Texture)</li>
<li>采用“precomposite”的策略</li>
<li>圆角的情况，使用底色的弧形layer来盖住四个角</li>
<li>阴影使用shadowPath来规避离屏渲染</li>
<li>特殊形状的view，打开shouldRasterize进行缓存</li>
<li>高斯模糊，可以自己处理并管理渲染结果</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift"><a class="header" href="#swift">Swift</a></h1>
<h3 id="特性"><a class="header" href="#特性">特性</a></h3>
<h4 id="_functionbuilder"><a class="header" href="#_functionbuilder">@_functionBuilder</a></h4>
<blockquote>
<p>Swift 5.1</p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/148112087">Swift Function Builder @_functionBuilder</a></p>
<p><a href="https://juejin.cn/post/6844903871786008590">SwiftUI 和 Swift 5.1 新特性(4) 苹果先斩后奏？Function Builder 造就 SwiftUI 的 DSL</a></p>
<p>一些利用@_functionBuilder的一些有趣实现：<a href="https://github.com/carson-katri/awesome-function-builders">awesome-function-builders</a></p>
<p>@_functionBuilder就是一个语法糖，可以为builder提供简洁的语法，你可以尝试用它简化任何builder类型的操作。也可以这样来用：</p>
<pre><code class="language-swift">@_functionBuilder struct AddBuilder {
    static func buildBlock&lt;T: Numeric&gt;(_ l: T, _ r: T) -&gt; T {
        return l + r
    }
}

func myadd(@AddBuilder _ builder: () -&gt; Int) -&gt; Int {
    return builder()
}

// 1和2相加
let r = myadd {	// r的结果是3
    1
    2
}
</code></pre>
<h4 id="propertywrapper"><a class="header" href="#propertywrapper">@propertyWrapper</a></h4>
<blockquote>
<p>Swift 5.1</p>
</blockquote>
<p><a href="https://medium.com/jeremy-xue-s-blog/swift-%E8%A3%BD%E4%BD%9C%E4%B8%80%E5%80%8B-userdefault-%E5%B0%88%E5%B1%AC%E7%9A%84%E5%B1%AC%E6%80%A7%E5%8C%85%E8%A3%9D%E5%99%A8%E5%90%A7-6457b2f0d886">Swift — 製作一個 UserDefault 專屬的屬性包裝器吧！</a></p>
<p>简单理解，@propertyWrapper就是用来hook属性，可以加一些自己的操作，让属性变为自己预期中的那样</p>
<pre><code class="language-swift">@propertyWrapper struct Beatiful {
    private var value: String = &quot;&quot;
    // 计算属性
    var wrappedValue: String {
        get { value }
        set { value = newValue.trimmingCharacters(in: .whitespacesAndNewlines) }
    }

    init(wrappedValue initialValue: String) {
        self.wrappedValue = initialValue
    }
}

struct MyData {
    // 让data变得更漂亮，自动将两边多余的空格去掉
    @Beatiful var data: String
}

var d = MyData(data: &quot;  Hello World  &quot;)
d.data  // 变为&quot;Hello World&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objective-c"><a class="header" href="#objective-c">Objective-C</a></h1>
<h3 id="资料-13"><a class="header" href="#资料-13">资料</a></h3>
<p><a href="https://kangzubin.com/nullability-and-objective-c/">Objective-C 中 nullable、__nullable、_Nullable 的区别</a></p>
<p><a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></p>
<p><a href="https://nshipster.cn/__attribute__/">NSHipster <strong>attribute</strong></a></p>
<p><a href="https://juejin.cn/post/6844904101839372295">iOS底层原理：weak的实现原理</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">OC中参数类型定义</a></p>
<h3 id="语法"><a class="header" href="#语法">语法</a></h3>
<h4 id="所有权"><a class="header" href="#所有权">所有权</a></h4>
<p>ARC下支持如下4种所有权：</p>
<ul>
<li>__strong</li>
<li>__weak</li>
<li>__unsafe_unretained</li>
<li>__autoreleasing (修饰当前变量，可以在当前autorelease pool结束时自动释放)</li>
</ul>
<h4 id="const的位置"><a class="header" href="#const的位置">const的位置</a></h4>
<p><a href="https://www.zhihu.com/question/443195492">C++里 const int* 与 int const* 有什么区别？</a></p>
<h4 id="import"><a class="header" href="#import">@import</a></h4>
<p><a href="https://medium.com/@Paris_Meta/include-import%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB-35d7d53f6af7">#include、#import 和 @import 的区别</a></p>
<ul>
<li>不需要像 #import 一样得手动去链接 Framework，@import 会自动去链接</li>
<li>@import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多</li>
<li>@import 导入 Modul 优化文件体积变大、编译速度变慢的问题</li>
<li>可以部分导入（@import Framework.A）或全部导入（@import Framework）</li>
</ul>
<h4 id="clang-attributes"><a class="header" href="#clang-attributes">Clang Attributes</a></h4>
<p><a href="https://blog.sunnyxx.com/2016/05/14/clang-attributes/">Clang Attributes 黑魔法小记</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swiftui"><a class="header" href="#swiftui">SwiftUI</a></h1>
<h3 id="swiftui-demo"><a class="header" href="#swiftui-demo">SwiftUI Demo</a></h3>
<ul>
<li><a href="https://github.com/WillieWangWei/">SwiftUI-Tutorials</a></li>
</ul>
<h3 id="swiftui书籍"><a class="header" href="#swiftui书籍">SwiftUI书籍</a></h3>
<p><a href="https://objccn.io/products/swift-ui">SwiftUI 与 Combine 编程</a></p>
<h3 id="动画"><a class="header" href="#动画">动画</a></h3>
<p>Advanced SwiftUI Animations</p>
<ul>
<li><a href="https://swiftui-lab.com/swiftui-animations-part1">Part 1: Animating Paths</a></li>
<li><a href="https://swiftui-lab.com/swiftui-animations-part2">Part 2: GeometryEffect</a></li>
<li><a href="https://swiftui-lab.com/swiftui-animations-part3">Part 3: AnimatableModifier</a></li>
</ul>
<h3 id="其它资料"><a class="header" href="#其它资料">其它资料</a></h3>
<ul>
<li><a href="https://mp.weixin.qq.com/s/TVn2rCiJCbZwajtHVjxGwg">SwiftUI 学习曲线</a></li>
<li><a href="https://fuckingswiftui.com/">SwiftUI代码片断</a></li>
<li><a href="https://www.hackingwithswift.com/quick-start/swiftui/whats-the-difference-between-observedobject-state-and-environmentobject">@ObservedObject、@State、@EnvironmentObject区别</a></li>
<li><a href="https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-environment-property-wrapper">@Environment与@EnvironmentObject的区别</a></li>
<li><a href="https://www.objc.io/blog/2019/10/29/swiftui-environment/">SwiftUI: Setting Environment Values</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<h3 id="资料-14"><a class="header" href="#资料-14">资料</a></h3>
<ul>
<li>
<p><a href="https://www.jianshu.com/u/988db278abcd">无忘无往的文章列表</a>：对Runtime讲解的非常清晰易读</p>
</li>
<li>
<p><a href="https://blog.csdn.net/businiao_zell/article/details/45872939">SEL类型数据和selector的用法</a>：SEL就是方法的包装，包含了调用地址</p>
</li>
<li>
<p><a href="https://tech.meituan.com/2015/08/12/deep-understanding-object-c-of-method-caching.html">深入理解 Objective-C：方法缓存</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/potato512/article/details/80947303">Runtime消息转发</a></p>
</li>
</ul>
<h3 id="介绍"><a class="header" href="#介绍">介绍</a></h3>
<p>将一些在编译和链接过程中的工作，放到了运行阶段。</p>
<h4 id="能力"><a class="header" href="#能力">能力</a></h4>
<ul>
<li>可以运行时新增类、方法、属性等</li>
<li>可以运行时交换两个方法</li>
<li>获得某个类所有成员方法、成员变量</li>
</ul>
<h4 id="对象--类实现"><a class="header" href="#对象--类实现">对象 &amp; 类实现</a></h4>
<p>所有的类、元类，都是运行时创建的。</p>
<ul>
<li>普通@interface定义的对象，都是从NSObject继承的。其存在一个属性，即<code>Class isa</code>。</li>
<li><code>Class</code>类型，是<code>struct objc_class</code>的定义</li>
<li><code>objc_class</code>继承自<code>objc_object</code></li>
<li><code>objc_class</code>中有三个成员
<ul>
<li><code>Class superclass</code>指向父类</li>
<li><code>cache_t cache</code>优化方法调用的cache</li>
<li><code>class_data_bits_t bits</code>标明Class的属性的</li>
</ul>
</li>
<li><code>objc_object</code>是Runtime层的对象。而类是一种特殊的对象，即对象的继承对象 (OC中id类型也是定义为该结构体类型)</li>
<li><code>objc_object</code>仅有一个<code>isa_t isa</code>属性</li>
<li><code>isa_t</code>是一个联合体，可能描述了对象的属性，也可能指向了一个类</li>
<li>元类不是父类</li>
</ul>
<p>示意图：（来源https://www.jianshu.com/p/b42db8b06088）</p>
<img src="iOS/./images/rt_objc_class.png" style="zoom:50%;" />
<h3 id="消息"><a class="header" href="#消息">消息</a></h3>
<ul>
<li>SEL定义为<code>struct objc_selector</code> （目前仅是一个字符串，苹果将其实现隐藏了）</li>
<li>不同类的同名方法（即使参数不同），它们的SEL也是相同的</li>
<li><code>@selector</code>及<code>sel_registerName</code>可以获取SEL方法选择器</li>
<li>IMP实际上是一个函数指针</li>
<li>在cache中存的是<code>method_t</code>类型，里面包含了SEL和IMP</li>
</ul>
<p>消息调用示意图：（来源：https://www.jianshu.com/p/782d7ce86d0f）</p>
<img src="iOS/./images/rt_method_forward.png" style="zoom:80%;" />
<h4 id="消息调用流程"><a class="header" href="#消息调用流程">消息调用流程</a></h4>
<ul>
<li>实例对象通过isa找到它的类对象</li>
<li>在类对象的缓存方法列表中寻找指定方法</li>
<li>如果缓存中没有，就到当前类的方法列表中寻找</li>
<li>如果方法列表中没有，就通过superclass到父类的方法列表中寻找</li>
<li>如果父类方法类别也没有，那么就动态解析（Method Resolution）</li>
<li>如果消息解析后还没找到，那么就消息转发（Method Forwarding）</li>
<li>如果还是没找到，程序就崩溃，如果2~6步骤中有一个找到，则返回对应的函数实现（IMP）</li>
</ul>
<blockquote>
<p>类方法的调用类似，但是是会去元类中找</p>
</blockquote>
<p>动态解析，需要重写NSObject的<code>resolveInstanceMethod</code>来实现</p>
<p>消息转发，可以分两步处理：</p>
<ul>
<li>先调用<code>forwardingTargetForSelector</code>，返回可以处理的对象</li>
<li>上面不响应，则调用<code>methodSignatureForSelector</code>，返回函数签名，然后调用<code>forwardInvocation</code></li>
</ul>
<p>流程参考：</p>
<p><img src="iOS/./images/method_forward.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多线程"><a class="header" href="#多线程">多线程</a></h1>
<h3 id="多线程方式"><a class="header" href="#多线程方式">多线程方式</a></h3>
<ul>
<li>NSThread</li>
<li>NSOperation</li>
<li>GCD</li>
<li>pthread</li>
</ul>
<h3 id="nsthread"><a class="header" href="#nsthread">NSThread</a></h3>
<p>使用方式：</p>
<pre><code class="language-oc">  NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];
  [thread start];
</code></pre>
<h3 id="gcd"><a class="header" href="#gcd">GCD</a></h3>
<p><a href="https://juejin.cn/post/6844903566398717960">『GCD』详尽总结</a></p>
<ul>
<li>GCD 可用于多核的并行运算；</li>
<li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）；</li>
<li>创建线程简单。</li>
</ul>
<blockquote>
<p>GCD创建的异步任务，虽然有开启新线程的能力，但不一定开启的。比如同步的任务，不会开启线程</p>
</blockquote>
<h4 id="group"><a class="header" href="#group">Group</a></h4>
<ul>
<li>通过group相关接口，gcd可以实现类似promise的all能力。即可以等多个异步任务，执行完毕回调指定接口。</li>
</ul>
<h4 id="barrier"><a class="header" href="#barrier">Barrier</a></h4>
<ul>
<li>栅栏，可以阻隔开多个并发任务</li>
<li>通过dispatch_barrier_async添加的block会等到之前添加所有的block执行完毕再执行</li>
<li>在dispatch_barrier_async之后添加的block会等到dispatch_barrier_async添加的block执行完毕再执行</li>
<li>dispatch_barrier_async的上述特点只在自己创建的concurrent queue有效, 在serial queue和global concurrent queues中的作用和dispatch_sync完全相同</li>
</ul>
<h3 id="nsoperation"><a class="header" href="#nsoperation">NSOperation</a></h3>
<ul>
<li>底层使用gcd来实现</li>
<li>支持创建依赖关系</li>
<li>支持通过KVO观察Operation当前的状态（是否执行，取消）</li>
<li>支持设置优先级</li>
</ul>
<h3 id="锁"><a class="header" href="#锁">锁</a></h3>
<p><a href="https://www.jianshu.com/p/5445411fb53c">ios 锁的种类及性能</a></p>
<p>锁的种类：</p>
<ul>
<li>自旋锁 （os_unfair_lock）</li>
<li>互斥锁
<ul>
<li>递归锁 （NSRecursiveLock、@synchronized、atomic）</li>
<li>非递归锁 （NSLock、NSCondition、NSConditionLock）</li>
</ul>
</li>
</ul>
<p>递归锁：同一线程多次获取该锁，而不会产生死锁。比如在一个递归接口中，多次获取锁，是ok的。</p>
<blockquote>
<p>NSConditionLock，是有条件的互斥锁</p>
<p>OSSpinLock因为安全问题，在iOS10之后，被os_unfair_lock取代</p>
<p>os_unfair_lock实现上是会处于<code>休眠</code>状态，不会忙等。</p>
</blockquote>
<p>锁的关系： (虽然图上将os_unfair_lock划至互斥锁，但其更应该属于自旋锁)</p>
<p><img src="iOS/./images/lock.png" alt="" /></p>
<p>性能从高到底：</p>
<ul>
<li>os_unfair_lock</li>
<li>OSSpinLock (不再使用)</li>
<li>dispatch_semaphore</li>
<li>pthread_mutex(default)</li>
<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>
<li>NSLock</li>
<li>NSCondition</li>
<li>pthread_mutex(recursive)</li>
<li>NSRecursiveLock</li>
<li>NSConditionLock</li>
<li>@synchronized</li>
</ul>
<h4 id="不同锁的使用场景"><a class="header" href="#不同锁的使用场景">不同锁的使用场景</a></h4>
<ul>
<li>互斥锁会改变线程的状态，使得内核不断的调度线程资源，因此效率上比自旋锁要低很多，不适合使用自旋锁的场景都使用互斥锁。</li>
<li>自旋锁在线程的等待过程中是活跃的，避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。因此自旋锁适合用于短时间内的轻量级锁定，主要用在临界区持锁时间非常短且CPU资源不紧张的情况下。</li>
</ul>
<h4 id="信号量"><a class="header" href="#信号量">信号量</a></h4>
<p><a href="https://www.jianshu.com/p/5514fb294d9a">iOS 信号量详解</a></p>
<p>gcd信号量，是特殊的互斥锁，可以控制线程并发访问的数量。其是基于内核信号量的封装。</p>
<h4 id="pthread_rwlock"><a class="header" href="#pthread_rwlock">pthread_rwlock</a></h4>
<p>读写锁，其是一种特殊的自旋锁。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="事件相关"><a class="header" href="#事件相关">事件相关</a></h1>
<p>事件传递顺序：<a href="https://www.jianshu.com/p/ca3cd5306668">iOS-使用hitTest控制点击事件的响应对象</a></p>
<h3 id="手势"><a class="header" href="#手势">手势</a></h3>
<p>离散手势：只发生一次的，比如单击</p>
<p>连续手势：如滑动</p>
<p>详细介绍：https://www.jianshu.com/p/a8c04c70212f</p>
<p>手势冲突的处理，可以参考：<a href="https://www2.zhihu.com/pub/reader/119619068/chapter/1116716476492529664">同时使用多个手势识别器</a></p>
<p>其中有两个方法需要关注：</p>
<pre><code class="language-objective-c">// 设置other的识别，是否要依赖于第一个gesture的失败。如果设置为yes的话，仅当第一个gesture识别错误时，才丢给第二个进行识别
- (BOOL)gestureRecognizer:(UIGestureRecognizer*)gestureRecognizer
    shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer*)otherGestureRecognizer;

// 当前gesture，是否依赖于other的失败。设置为YES时，则other失败后，才会交给第一个gesture处理
- (BOOL)gestureRecognizer:(UIGestureRecognizer*)gestureRecognizer
    shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer*)otherGestureRecognizer;
</code></pre>
<p>如果要支持多个手势同时识别，使用如下接口</p>
<pre><code class="language-objective-c">- (BOOL)gestureRecognizer:(UIGestureRecognizer*)gestureRecognizer
    shouldRecognizeSimultaneouslyWithGestureRecognizer:
        (UIGestureRecognizer*)otherGestureRecognizer;
</code></pre>
<h4 id="delaystouchesbegandelaystouchesended"><a class="header" href="#delaystouchesbegandelaystouchesended">delaysTouchesBegan、delaysTouchesEnded</a></h4>
<p>https://www.jianshu.com/p/714a3140d571</p>
<blockquote>
<p>delaysTouchesBegan: 默认是NO，这种情况下当发生一个touch时，手势识别器先捕捉到到touch，然后发给hit-testview，两者各自做出响应。如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将touch发给hit-test view，即hit-testview不会有任何触摸事件。只有在识别失败之后才会将touch发给hit-testview，这种情况下hit-test view的响应会延迟约0.15ms。</p>
<p>delaysTouchesEnded: 默认为YES。这种情况下发生一个touch时，在手势识别成功后,发送给touchesCancelled消息给hit-test view，手势识别失败时，会延迟大概0.15ms,期间没有接收到别的touch才会发送touchesEnded。如果设置为NO，则不会延迟，即会立即发送touchesEnded以结束当前触摸。</p>
</blockquote>
<p>但是当在View上有多个手势时，有些表现异常的地方，参考Demo: <a href="http://git.code.oa.com/matthewyan/GestureDemo.git">GestureDemo</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wkwebview"><a class="header" href="#wkwebview">WKWebview</a></h1>
<h3 id="可配置能力"><a class="header" href="#可配置能力">可配置能力</a></h3>
<h5 id="wkwebviewconfiguration"><a class="header" href="#wkwebviewconfiguration">WKWebViewConfiguration</a></h5>
<p>是用来初始化时作的配置，可以配置如下项</p>
<ul>
<li>
<p>进程池(<code>WKProcessPool</code>)：多个webview可以配置为同一个进程，这样他们就能共享数据，如Cookie等</p>
</li>
<li>
<p>WKPreferences：最小字号、是否可以运行js等</p>
</li>
<li>
<p>Natvie与Webview交互(<code>WKUserContentController</code>)</p>
<ul>
<li>其中有<code>WKContentRuleList</code>的设置，这个设置的详解：<a href="https://www.jianshu.com/p/8af24e9dc82e">iOS 11：WKWebView内容过滤规则详解</a></li>
</ul>
</li>
<li>
<p>缓存数据的配置(<code>WKWebsiteDataStore</code>)</p>
</li>
<li>
<p>UA名称、在页面完全加载完前，是否禁止渲染、是否支持airplay、页面内视频播放等</p>
</li>
<li>
<p>配置页面优先加载的页面的形式(有: 推荐、desktop、mobile三个选项)</p>
</li>
<li>
<p>配置数据类型识别（如是否自动识别电话号码、链接等）</p>
</li>
<li>
<p>是否允许页面缩放</p>
</li>
<li>
<p>代理设置(非自定义的默认就支持，使用<code>setURLSchemeHandler:forURLScheme:</code>。要处理http/https，参考下面的WKWebview代理实现)</p>
</li>
</ul>
<h3 id="delegate"><a class="header" href="#delegate">Delegate</a></h3>
<h5 id="wknavigationdelegate能力"><a class="header" href="#wknavigationdelegate能力">WKNavigationDelegate能力</a></h5>
<ul>
<li>确认是否允许跳转链接 （包括开始，以及拿到Response数据后来决定）</li>
<li>导航开始、重定向事件</li>
<li>页面加载错误</li>
<li>页面开始有内容到达、内容接收完成事件</li>
<li>验证自签名证书的有效性(<code>webView:didReceiveAuthenticationChallenge:completionHandler:</code>)</li>
</ul>
<h5 id="wkuidelegate能力"><a class="header" href="#wkuidelegate能力">WKUIDelegate能力</a></h5>
<ul>
<li>创建新的Webview或关闭Webview的事件</li>
<li>Alert、Promot、Confirm事件</li>
<li>上下文菜单相关</li>
</ul>
<h3 id="其它能力"><a class="header" href="#其它能力">其它能力</a></h3>
<ul>
<li>设置导航记录 (backForwardList)</li>
<li>自定义UA</li>
<li>前进、后退、重新加载等</li>
<li>Webview截屏能力 (<code>-takeSnapshotWithConfiguration:completionHandler:</code>)</li>
</ul>
<h3 id="wkwebview实现代理"><a class="header" href="#wkwebview实现代理">WKWebview实现代理</a></h3>
<p><a href="https://nemocdz.github.io/post/ios-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86proxy%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/">iOS 设置代理（Proxy）方案总结</a></p>
<p>​	</p>
<h3 id="cookie设置"><a class="header" href="#cookie设置">Cookie设置</a></h3>
<p>WKWebView有三种在终端设置Cookie的方式</p>
<p>一、通过Header中的Cookies字段来设置</p>
<pre><code class="language-swift">var req = URLRequest(url: myURL!)
let cookieValue = &quot;uin=10000; uid=10001&quot;
req.addValue(cookieValue, forHTTPHeaderField: &quot;Cookie&quot;)
self.webView.load(req)
</code></pre>
<blockquote>
<p>这种设置方式，仅在请求头里包含，前端页面通过<code>document.cookie</code>是无法读取到的</p>
</blockquote>
<p>二、通过JS注入的方式来设置</p>
<pre><code class="language-swift">let script = &quot;document.cookie = 'aaaaa=11111; domain=127.0.0.1; path=/; '; document.cookie = 'bbbbbb=22222; domain=127.0.0.1; path=/; ';&quot;
let us = WKUserScript(source: script, injectionTime: .atDocumentStart, forMainFrameOnly: false)
self.webView?.configuration.userContentController.addUserScript(us)
</code></pre>
<blockquote>
<p>这种方式设置的，在域的处理上，会跟第三点有些区别
比如设置的Cookie是<code>qq.com</code>域，但前端页面拿到的域会自动在前面添加上点号，变为<code>.qq.com</code></p>
</blockquote>
<p>三、通过将Cookie存储至<code>WKHTTPCookieStore</code>中</p>
<pre><code class="language-swift">let wkStore = WKWebsiteDataStore.default().httpCookieStore
cookies.forEach { cookie in
	wkStore.setCookie(cookie)
}
</code></pre>
<blockquote>
<p>这种方式设置的Cookie，在域的处理上也需要注意：</p>
<p>如果是访问的<code>docs.qq.com</code>，则<code>qq.com</code>域下的Cookie是不会被设置的，但<code>.qq.com</code>域下的Cookie会被设置(<code>docs.qq.com</code>、<code>.docs.qq.com</code>域的Cookie也都会被设置)</p>
</blockquote>
<p>四、通过Svr端<code>Set-Cookie</code>设置</p>
<pre><code class="language-swift">// node.js
app.get('/', (req, res) =&gt; {
  let options = {
      domain: 'matthewyan1.repl.co',
      maxAge: 30 * 86400000, // 1 months
      httpOnly: true, // The cookie only accessible by the web server
  }

  // Set cookie
  res.cookie('myTestCookie', '223', options)
  res.send('Hello World!!!')
})
</code></pre>
<p>​	</p>
<h3 id="cookie删除"><a class="header" href="#cookie删除">Cookie删除</a></h3>
<p>一、通过<code>WKWebsiteDataStore</code>的<code>removeData</code>接口来删除</p>
<pre><code class="language-swift">let types = Set(arrayLiteral: WKWebsiteDataTypeCookies)
let store = WKWebsiteDataStore.default()
store.fetchDataRecords(ofTypes: types) { cookies in
    store.removeData(ofTypes: types, for: cookies) {
        print(&quot;cookies clear result:\(records.count &gt; 0)&quot;)
    }
}
</code></pre>
<p>二、通过<code>WKWebsiteDataStore</code>中的<code>httpCookieStore</code>提供的<code>delete</code>接口来删除</p>
<pre><code class="language-swift">let wkStore = WKWebsiteDataStore.default().httpCookieStore
wkStore.getAllCookies { cookies in
    cookies.forEach { cookie in
        wkStore.delete(cookie) {
            print(&quot;cookie:\(cookie.name) clear ok&quot;)
        }
    }
}
</code></pre>
<p>三、服务端通过<code>Set-Cookie</code>来清除Cookie</p>
<pre><code class="language-javascript">// 使用的express提供的接口
app.get('/', (req, res) =&gt; {
  let options = {
      domain: 'matthewyan1.repl.co',
      httpOnly: true, // The cookie only accessible by the web server
  }

  /*
  express的clearCookie的实现
  本质是通过将过期时间设置为过去的一个过期时间来实现cookie被清除的
  res.clearCookie = function clearCookie(name, options) {
	  var opts = merge({ expires: new Date(1), path: '/' }, options);
  	return this.cookie(name, '', opts);
	};
  */
  // clear cookie
  res.clearCookie('myTestCookie', options)

  res.send('Clear Ok!!!')
})
</code></pre>
<blockquote>
<p>需要注意的是，在清楚cookie时，<code>max-Age</code>就不要再设置了，如果<code>max-Age</code>也设置了的话，会以<code>max-Age</code>为准了</p>
</blockquote>
<p>​	</p>
<h3 id="wkwebview-302过程"><a class="header" href="#wkwebview-302过程">WKWebview 302过程</a></h3>
<pre><code class="language-swift">// 1. 是否允许首个链接打开
func webView(WKWebView, decidePolicyFor: WKNavigationAction, decisionHandler: (WKNavigationActionPolicy) -&gt; Void)

// 2. 页面开始加载
func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!)

// 3. 是否允许跳转链接打开
func webView(WKWebView, decidePolicyFor: WKNavigationAction, decisionHandler: (WKNavigationActionPolicy) -&gt; Void)

// 4. 允许跳转链接之后，就通知链接跳转事件
func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!)

// 5. 收到请求的响应包之后，决定是否允许跳转
func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: @escaping (WKNavigationResponsePolicy) -&gt; Void)

// 6. 允许跳转之后，就开始接收页面内容
func webView(_ webView: WKWebView, didCommit navigation: WKNavigation!)

// 7. 页面加载完成
func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!)
</code></pre>
<p><strong>302跳转需要注意的事项：</strong></p>
<p>如果在首个url请求的header中设置了cookie，则后续302跳转的请求header，会被重置为开始设置的！</p>
<p>这样就会导致首个url请求，想通过<code>Set-Cookie</code>来设置Cookie，但302时无法带到新的请求中</p>
<h3 id="需要注意的点"><a class="header" href="#需要注意的点">需要注意的点</a></h3>
<p>WebView的goBack接口执行需要时间，如果连接调用goBack，并不能回退多个页面，只能回退到上个页面。参考：<a href="https://nixwang.com/2014/08/03/pits-on-ios/">在 iOS 上踩过的坑</a>。如果需要连续跳转多个页面，需要用如下接口：</p>
<pre><code class="language-swift">open func go(to item: WKBackForwardListItem) -&gt; WKNavigation?
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scheme"><a class="header" href="#scheme">Scheme</a></h1>
<h3 id="canopenurl接口"><a class="header" href="#canopenurl接口">canOpenURL接口</a></h3>
<ul>
<li>仅iOS9之后受限</li>
<li>使用Xcode7及以后版本编译：对于注册的scheme数量不限制，但是只有前50个调用canOpenURL的，返回值才是对的，从第51个开始，canOpenURL返回的值不保证是对的</li>
<li>使用Xcode6及以前版本编译：canOpenURL仅能调用50次，超过50次后就会返回false（应用重装或升级可以重置计数）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="签名相关"><a class="header" href="#签名相关">签名相关</a></h1>
<p>签名实现原理，是基于非对称加密实现的。核心实现是基于公钥加密的数据只能用私钥解，私钥加密的只能用公钥解。</p>
<p>CA数字签名一句话概括：CA机构(可信)用自己的私钥加密第三方的公钥和信息生成的，其可以保证其内容的安全性。（操作系统会内置CA证书）</p>
<h3 id="证书相关点"><a class="header" href="#证书相关点">证书相关点</a></h3>
<ul>
<li>数字证书：是一个经 CA 数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及 CA 的数字签名。</li>
<li>操作系统会内置一份可信的根证书列表，以保证根证书的有效性。</li>
<li>证书机构，可以对你的个人证书进行签名，以保证你的个人证书没有被修改。（如果被修改的话，用根证书的公钥是无法解开的）</li>
<li>只有你的证书是正常情况时，根证书才能解开你的证书，然后再用你的公钥去继续解。</li>
<li>从KeyChain里可以创建CSR文件，即请求证书文件。CSR包含了个人信息和公钥。</li>
<li>私钥和公钥都可以从电脑中导出，默认私钥导出即为P12格式，公钥导出即为pem格式。</li>
<li><code>mobileprovision</code>中包含了：证书、App ID 和 设备 ID (app id就是TeamID + BundleID)</li>
</ul>
<p>参考：<a href="https://www.jianshu.com/p/f582683ef7a2">iOS开发证书相关知识- iOS Provisioning Profile(Certificate)与Code Signing详解</a></p>
<h3 id="ios签名工作步骤"><a class="header" href="#ios签名工作步骤">iOS签名工作步骤</a></h3>
<ul>
<li>在本机生成一对公私钥，分别称为公钥L和私钥L。(公钥即为生成的<code>certSigningRequest</code>后缀的文件。私钥默认存储在本机中，通过<code>keychain</code>可以导出(默认导出为p12))</li>
<li>Apple也有一对公私钥，分别称为公钥A和私钥A。</li>
<li>上传公钥L至Apple后台，Apple使用私钥A加密公钥L，生成<code>cer</code>证书。</li>
<li>苹果后台，将<code>cer</code>证书连同一些其它信息(如App所支持的功能、开发证书注册的设备等)，打包为<code>mobileprovision</code>文件。</li>
<li>编译打包App时，选择对应的<code>mobileprovision</code>相对应的私钥L进行签名，并且最终<code>mobileprovision</code>会存储在App的安装包内。</li>
<li>在用户启动App时，公钥A去解密<code>mobileprovision</code>，能解开说明证书是有效的。</li>
<li>解开<code>mobileprovision</code>后将公钥L取出，然后用公钥L再去验证App的签名是否正确。</li>
</ul>
<p>参考：<a href="https://my.oschina.net/editorial-story/blog/3184897">iOS 打包签名，你真的懂吗？</a></p>
<h3 id="命令-2"><a class="header" href="#命令-2">命令</a></h3>
<ul>
<li>解压ipa之后，进入.app目录：<code>codesign -d --entitlements :- AppName</code>，可以查看当前包的签名信息</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="单元测试-1"><a class="header" href="#单元测试-1">单元测试</a></h1>
<h3 id="xctest"><a class="header" href="#xctest">XCTest</a></h3>
<h5 id="资料-15"><a class="header" href="#资料-15">资料</a></h5>
<p><a href="https://github.com/wangzhengang/XCTest">XCTest示例</a></p>
<h5 id="常用判断接口"><a class="header" href="#常用判断接口">常用判断接口</a></h5>
<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/d5db515373f4">单元测试中关于XCTAssert常用断言</a></p>
</blockquote>
<pre><code class="language-objective-c">XCTFail
XCTAssert
XCTAssertTrue
XCTAssertEqual				// 使用==来判断的
XCTAssertEqualObjects		// 使用isEqual来判断的
XCTAssertEqualWithAccuracy
XCTAssertNil
XCTAssertNotNil
XCTAssertThrows
</code></pre>
<h5 id="setupteardown"><a class="header" href="#setupteardown">setUp、tearDown</a></h5>
<ul>
<li><code>- (void)setUp</code> 是对每个测试接口测试前都会调用的</li>
<li><code>+ (void)setUp</code> 仅会调用一次，在第一个方法测试前调用</li>
</ul>
<h5 id="性能测试"><a class="header" href="#性能测试">性能测试</a></h5>
<pre><code class="language-objective-c">- (void)testPerformanceExample {
    // This is an example of a performance test case.
    [self measureBlock:^{
        // Put the code you want to measure the time of here.
    }];
}
</code></pre>
<h5 id="异步测试"><a class="header" href="#异步测试">异步测试</a></h5>
<pre><code class="language-objective-c">- (void)testAsync {
    XCTestExpectation *expectation = [self expectationWithDescription:@&quot;xx&quot;];
    
    dispatch_queue_t queue = dispatch_queue_create(&quot;group.queue&quot;, DISPATCH_QUEUE_SERIAL);
    dispatch_block_t block = dispatch_block_create(0, ^{
        [NSThread sleepForTimeInterval:1.0f];
        XCTFail();   // 表示验证失败
        [expectation fulfill];	// 完成后需要调用这个接口
    });
    dispatch_async(queue, block);
    
    [self waitForExpectationsWithTimeout:3 handler:^(NSError * _Nullable error) {
        
    }];
}
</code></pre>
<h3 id="ocmock"><a class="header" href="#ocmock">OCMock</a></h3>
<p>资料：</p>
<p><a href="https://www.jianshu.com/p/09bd2ace8610">OCMock使用技巧</a></p>
<p><a href="https://www.jianshu.com/p/fb73f1eae4da">OCMock使用实例</a></p>
<p>http://luoxianming.cn/2016/05/25/ocmock/</p>
<h5 id="使用"><a class="header" href="#使用">使用</a></h5>
<ul>
<li>在Test的Target中，添加<code>pod 'OCMock'</code></li>
<li><code>pod install</code></li>
<li>在测试代码中引入：<code>#import &lt;OCMock/OCMock.h&gt;</code></li>
</ul>
<h5 id="返回值"><a class="header" href="#返回值">返回值</a></h5>
<pre><code class="language-objective-c">id mockClass = OCMClassMock([SomeClass class]);
// 没有参数的方法
OCMStub([mockClass someMethod]).andReturn(anObject);
// 有参数的方法
OCMStub([mockClass someMethod:[OCMArg any]]).andReturn(anObject);
</code></pre>
<h5 id="验证某方法被调用了"><a class="header" href="#验证某方法被调用了">验证某方法被调用了</a></h5>
<pre><code class="language-objective-c">id mockClass = OCMClassMock([SomeClass class]);
//...
//some code
//...
OCMVerify([mockClass someMethod]);
</code></pre>
<h5 id="验证某方法没有被调用"><a class="header" href="#验证某方法没有被调用">验证某方法没有被调用</a></h5>
<pre><code class="language-objective-c">static BOOL isCalled = false;
id mockClass = OCMClassMock([SomeClass class]);
OCMStub([mockClass someMethod]).andDo(^(NSInvocation *invocation) {
	isCalled = YES;
});
//...
//some code
//...
XCTAssertFalse(isCalled);
</code></pre>
<h5 id="验证mock方法传入的参数"><a class="header" href="#验证mock方法传入的参数">验证mock方法传入的参数</a></h5>
<pre><code class="language-objective-c">id mockClass = OCMClassMock([SomeClass class]);
OCMStub([mockClass someMethod:[OCMArg checkWithBlock:^BOOL(id obj) {
	//...
	//some code
	//...
	return YES;
]]);
</code></pre>
<h5 id="mock单例"><a class="header" href="#mock单例">Mock单例</a></h5>
<pre><code class="language-objective-c">id mockManager = OCMClassMock([OKDataManager class]);
OCMStub([mockManager shareManager]).andReturn(mockManager);	// 重点是这句，需要将自身返回
OKUserInfoModel *userModel = [[OKUserInfoModel alloc] init];
userModel.userId = @&quot;123456&quot;; //在测试调用的地方userId返回的就是123456
OKDataManager *manager = [OKDataManager shareManager];
OCMStub([manager userInfoModel]).andReturn(userModel);
</code></pre>
<h5 id="mock-block参数"><a class="header" href="#mock-block参数">Mock block参数</a></h5>
<pre><code class="language-objc">// http://zixun.github.io/blog/2015/04/16/iosdan-yuan-ce-shi-xi-lie-yi-ocmockchang-jian-shi-yong-fang-shi/
// 函数签名为： [[MyManager shareInstance] myCompleteBlock:void (^)(BOOL hasNewVersion, NSString *newBundleVersion)]
id mockClass = OCMClassMock([MyManager class]);
OCMStub([mockClass shareInstance]).andReturn(mockClass);
OCMStub([mockClass myCompleteBlock:[OCMArg any]])
  .andDo(^(NSInvocation *invocation) {
    void (^checkUpdateBlock)(BOOL hasNewVersion, NSString *newBundleVersion);
    // 这儿index需要注意，如果第一个参数是block，就需要填2，因为前面默认有类实例作为第1个参数
    [invocation getArgument:&amp;checkUpdateBlock atIndex:2];	
    checkUpdateBlock(TRUE, @&quot;10.10.10&quot;);
  });
</code></pre>
<h3 id="ui-test"><a class="header" href="#ui-test">UI Test</a></h3>
<h4 id="xcuitest"><a class="header" href="#xcuitest">XCUITest</a></h4>
<h4 id="monkey-test"><a class="header" href="#monkey-test">Monkey Test</a></h4>
<p>iOS上的Monkey Test库：<a href="https://github.com/zalando/SwiftMonkey">SwiftMonkey</a></p>
<p><a href="https://blog.csdn.net/weixin_43843008/article/details/108620640">IOS上的monkey测试探索（一）</a></p>
<h4 id="其它自动化测试工具"><a class="header" href="#其它自动化测试工具">其它自动化测试工具</a></h4>
<p><a href="https://appium.io/docs/cn/about-appium/intro/">Appium</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设备及系统"><a class="header" href="#设备及系统">设备及系统</a></h1>
<h3 id="系统和设备对应关系"><a class="header" href="#系统和设备对应关系">系统和设备对应关系</a></h3>
<table><thead><tr><th>系统</th><th>最低支持到的设备</th><th>最低设备芯片</th></tr></thead><tbody>
<tr><td><a href="https://zh.wikipedia.org/wiki/IOS_5">iOS5</a></td><td>iPhone 3GS, iPad</td><td></td></tr>
<tr><td><a href="https://zh.wikipedia.org/wiki/IOS_6">iOS6</a></td><td>iPhone 3GS，iPad2之后</td><td></td></tr>
<tr><td><a href="https://zh.wikipedia.org/wiki/IOS_7">iOS7</a></td><td>iPhone 4及之后</td><td></td></tr>
<tr><td><a href="https://zh.wikipedia.org/wiki/IOS_8">iOS8</a></td><td>iPhone 4s, iPad 2等 (11年及之后的设备)</td><td>A5</td></tr>
<tr><td><a href="https://zh.wikipedia.org/wiki/IOS_9">iOS9</a></td><td>同iOS8</td><td></td></tr>
<tr><td><a href="https://zh.wikipedia.org/wiki/IOS_10">iOS10</a></td><td>iPhone 5, iPad 4, iPad Mini2等 (12年及之后的设备)</td><td>A6</td></tr>
<tr><td><a href="https://zh.wikipedia.org/wiki/IOS_11">iOS11</a></td><td>iPhone 5s, iPad 5,iPad Mini2等</td><td>A7(64位)</td></tr>
<tr><td><a href="https://zh.wikipedia.org/wiki/IOS_12">iOS12</a></td><td>同iOS11</td><td></td></tr>
<tr><td><a href="https://zh.wikipedia.org/wiki/IOS_13">iOS13</a></td><td>iPhone 6s之后</td><td>A9</td></tr>
<tr><td><a href="https://zh.wikipedia.org/wiki/IOS_14">iOS14</a></td><td>同iOS13</td><td></td></tr>
<tr><td><a href="https://zh.wikipedia.org/wiki/IOS_15">iOS15</a></td><td>同iOS13</td><td></td></tr>
</tbody></table>
<h3 id="设备尺寸及分辨率"><a class="header" href="#设备尺寸及分辨率">设备尺寸及分辨率</a></h3>
<table><thead><tr><th>设备</th><th>渲染像素</th><th>逻辑像素</th><th>物理像素</th><th>尺寸</th><th>屏幕模式</th><th>PPI</th><th>提审需要</th><th>外观</th></tr></thead><tbody>
<tr><td>iPhone 12</td><td>2532 x 1170</td><td>844 x 390</td><td></td><td>6.1英寸</td><td>3x</td><td>460</td><td></td><td></td></tr>
<tr><td>iPhone 12 Mini</td><td>2340 x 1080</td><td>780 x 360</td><td></td><td>5.4英寸</td><td>3x</td><td>476</td><td></td><td></td></tr>
<tr><td>iPhone 12 Pro</td><td>2532 x 1170</td><td>844 x 390</td><td></td><td>6.1英寸</td><td>3x</td><td>460</td><td></td><td></td></tr>
<tr><td>iPhone 12 Pro Max</td><td>2778 x 1284</td><td>926 x 428</td><td></td><td>6.7英寸</td><td>3x</td><td>458</td><td></td><td></td></tr>
<tr><td>iPhone 11 Pro Max</td><td>2688 x 1242</td><td>896 x 414</td><td></td><td>6.5英寸</td><td>3x</td><td>458</td><td>✓</td><td></td></tr>
<tr><td>iPhone 11 Pro</td><td>2436 x 1125</td><td>812 x 375</td><td></td><td>5.8 英寸</td><td>3x</td><td>458</td><td></td><td></td></tr>
<tr><td>iPhone 11</td><td>1792 x 828</td><td>896 x 414</td><td></td><td>6.1英寸</td><td>2x</td><td>326</td><td></td><td></td></tr>
<tr><td>iPhone 8</td><td>1334 x 750</td><td>667 x 375</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>iPhone 8 Plus</td><td>2208 x 1242</td><td>736 x 414</td><td>1920 x 1080 (比较特殊)</td><td>5.5英寸</td><td>3x</td><td></td><td>✓</td><td></td></tr>
<tr><td>iPad Pro(三代)</td><td>2732×2048</td><td></td><td></td><td></td><td>2x</td><td></td><td>✓</td><td>https://www.apple.com.cn/shop/buy-ipad/ipad-pro</td></tr>
<tr><td>iPad Pro(二代)</td><td>2732×2048</td><td></td><td></td><td></td><td>2x</td><td></td><td>✓</td><td>带Home键、大边框</td></tr>
</tbody></table>
<h3 id="参考资料-1"><a class="header" href="#参考资料-1">参考资料</a></h3>
<p><a href="https://zhuanlan.zhihu.com/p/47466485">iPhone &amp; iPad 屏幕尺寸，归纳及分析</a></p>
<p><a href="https://juejin.im/post/5bfddc336fb9a049d441804e">史上最全iPhone分辨率和尺寸</a></p>
<p><a href="https://blog.csdn.net/thelittleboy/article/details/102739069">iPhone 11、iPhone 11 Pro、iPhone 11 Pro Max 屏幕尺寸，分辨率，PPI 详细数据对比</a></p>
<p><a href="https://www.zcool.com.cn/article/ZMTAzNjYyMA==.html">iPhone11的适配</a></p>
<p><a href="https://david-smith.org/iosversionstats/">系统、设备占比</a></p>
<p><a href="https://www.theiphonewiki.com/wiki/Models">设备标识与设备型号的对应</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="框架-1"><a class="header" href="#框架-1">框架</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactiveobjc"><a class="header" href="#reactiveobjc">ReactiveObjC</a></h1>
<p><a href="https://blog.codescv.com/ios/reactive-1.html">ReactiveCocoa 代码阅读笔记 (1) 双向绑定</a></p>
<p><a href="https://www.jianshu.com/p/d7d951a99db8">ReactiveCocoa 中 RACSignal 是如何发送信号的</a></p>
<h3 id="代码"><a class="header" href="#代码">代码</a></h3>
<p>组件属性绑定变量</p>
<pre><code class="language-objc">RAC(self.curVer, text) = RACObserve(self.model, appRNVersion);
</code></pre>
<p>登录按钮状态绑定</p>
<pre><code class="language-objc">// combineLatest
RAC(self.loginBtn, enabled) = [RACSignal combineLatest:@[self.phoneNumber.rac_textSignal, self.password.rac_textSignal] reduce:^id _Nullable(NSString *phone, NSString *password) {
        return @(phone.length &gt;= 11 &amp;&amp; password.length &gt;= 8);
    }];
</code></pre>
<p>RACSignal发送信号</p>
<pre><code class="language-objc">RACSignal *signal = [RACSignal createSignal:
                     ^RACDisposable *(id&lt;RACSubscriber&gt; subscriber)
{
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendNext:@3];
    [subscriber sendCompleted];
    return [RACDisposable disposableWithBlock:^{
        NSLog(@&quot;signal dispose&quot;);
    }];
}];
</code></pre>
<p>RACSubject发送信号</p>
<pre><code class="language-objc">RACSubject&lt;NSString *&gt; *loginMsg;
[loginMsg sendNext:@&quot;login ok&quot;];
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdwebimage"><a class="header" href="#sdwebimage">SDWebImage</a></h1>
<p><a href="https://www.jianshu.com/p/5a0e1e1b1541">SDWebImage的缓存策略</a></p>
<p>内存缓存 + 磁盘缓存</p>
<p>内存缓存：</p>
<ul>
<li>AutoPurgeCache：继承自NSCache，支持内存紧张时释放缓存能力 （因为NSCache在iOS7上，收到警告存在没有释放缓存的问题）</li>
</ul>
<p>NSCache缓存淘汰策略，是使用了LRU，即最早没有使用的缓存被淘汰。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="问题集合"><a class="header" href="#问题集合">问题集合</a></h1>
<h3 id="storyboard"><a class="header" href="#storyboard">Storyboard</a></h3>
<p>Storyboard中，TabbarItem的SelectedImage设置方法：https://stackoverflow.com/a/44646623</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web"><a class="header" href="#web">Web</a></h1>
<h2 id="资料-16"><a class="header" href="#资料-16">资料</a></h2>
<ul>
<li><a href="https://insights.thoughtworks.cn/web-icon-history/">Web技术中图标的演化</a></li>
<li><a href="https://github.com/wx-chevalier/Web-Series">Web系列文章</a></li>
</ul>
<h3 id="浏览器相关"><a class="header" href="#浏览器相关">浏览器相关</a></h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/96986818">深入理解浏览器原理</a></li>
<li><a href="https://blog.poetries.top/browser-working-principle/">浏览器工作原理与实践</a></li>
</ul>
<h3 id="其它-3"><a class="header" href="#其它-3">其它</a></h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/58151131">理解webpack原理，手写一个100行的webpack</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程</a></li>
</ul>
<h3 id="多端框架"><a class="header" href="#多端框架">多端框架</a></h3>
<ul>
<li><a href="https://juejin.im/post/5c90eb366fb9a070d4199cc9">小程序多端框架全面测评</a></li>
<li><a href="https://mp.weixin.qq.com/s/jIDEHfuMnED6HTfNgjsW4w">深入测试一周，主流多端框架大比武</a></li>
</ul>
<h2 id="调试"><a class="header" href="#调试">调试</a></h2>
<h3 id="vscode中调试页面"><a class="header" href="#vscode中调试页面">VSCode中调试页面</a></h3>
<p>如果下载的源码需要用<code>npm run dev</code>来运行的话：</p>
<ul>
<li>先用<code>npm run dev</code>跑起页面来</li>
<li>配置工程调试，环境选<code>chrome</code></li>
<li>编辑<code>launch.json</code>，将url修改为<code>npm run dev</code>后启动的页面url</li>
<li>然后再在VSCode中执行调试，此时下的断点就可以正常断下来了</li>
</ul>
<h2 id="框架-2"><a class="header" href="#框架-2">框架</a></h2>
<p>Svelte</p>
<h3 id="angular"><a class="header" href="#angular">Angular</a></h3>
<p>Angular与AngularJS是有差异的，参考：<a href="https://www.zhihu.com/question/67839941">Angular和AngularJS之间的关系？</a></p>
<p><a href="https://www.zhihu.com/question/383137600/answer/1128792388">Angular 过时了吗? - 谢亚东的回答 - 知乎</a></p>
<h5 id="特性-1"><a class="header" href="#特性-1">特性</a></h5>
<ul>
<li>零配置 CLI，不用关心任何webpack Config</li>
<li>官方提供所有的必须组件</li>
<li>有官方的应用市场</li>
<li>框架100%由TypeScript开发，并且生态内的所有三方库都是（只能用） TypeScript 开发</li>
<li>内置 RxJS</li>
</ul>
<h2 id="ssr框架"><a class="header" href="#ssr框架">SSR框架</a></h2>
<p>Next.js / Nuxt.js</p>
<h2 id="包管理工具"><a class="header" href="#包管理工具">包管理工具</a></h2>
<h3 id="npm"><a class="header" href="#npm">npm</a></h3>
<h3 id="yarn"><a class="header" href="#yarn">yarn</a></h3>
<h3 id="bower-已经渐渐衰落"><a class="header" href="#bower-已经渐渐衰落">bower (已经渐渐衰落)</a></h3>
<h2 id="语言"><a class="header" href="#语言">语言</a></h2>
<h3 id="typescript"><a class="header" href="#typescript">TypeScript</a></h3>
<h3 id="purescript"><a class="header" href="#purescript">PureScript</a></h3>
<p>函数式的js语言，可以转为js，也可以转为其它语言，如go语言。也很适合配合nodejs写后端代码</p>
<h3 id="elm"><a class="header" href="#elm">Elm</a></h3>
<h3 id="reasonml"><a class="header" href="#reasonml">ReasonML</a></h3>
<h3 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h3>
<h2 id="evernote待整理"><a class="header" href="#evernote待整理">Evernote，待整理</a></h2>
<p>https://github.com/wx-chevalier/Web-Series</p>
<p>浏览器工作原理与实践
https://blog.poetries.top/browser-working-principle/</p>
<p>////////////////////////////////////////////////////////////////////////////////</p>
<p>https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver</p>
<p>////////////////////////////////////////////////////////////////////////////////</p>
<p>理解webpack原理，手写一个100行的webpack
https://zhuanlan.zhihu.com/p/58151131</p>
<p>理解async/await
https://segmentfault.com/a/1190000007535316</p>
<p>在vs code中使用flow时的配置
https://stackoverflow.com/questions/48859169/js-types-can-only-be-used-in-a-ts-file-visual-studio-code-using-ts-check</p>
<p>Redux JS库
https://github.com/reduxjs/redux</p>
<p>Redux教程
https://www.redux.org.cn/</p>
<p>JSX转JS代码
https://babeljs.io/repl/#?presets=react&amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA</p>
<p>npm安装失败，可以尝试配置代理：
npm config set proxy &quot;http://web-proxy.tencent.com:8080”
或者尝试删除代理：
npm config delete https-proxy
npm config delete proxy</p>
<p>//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// </p>
<p>多端开发框架比较</p>
<p>小程序多端框架全面测评
https://juejin.im/post/5c90eb366fb9a070d4199cc9</p>
<p>深入测试一周，主流多端框架大比武
https://mp.weixin.qq.com/s/jIDEHfuMnED6HTfNgjsW4w</p>
<p>Taro资料：
https://nervjs.github.io/taro/docs/tutorial.html
https://juejin.im/book/5b73a131f265da28065fb1cd?referrer=5ba228f16fb9a05d3251492d</p>
<p>//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// </p>
<p>JS code
https://github.com/30-seconds/30-seconds-of-code</p>
<p>CDN使用
https://cdnjs.com/</p>
<p>ESLint
https://zhuanlan.zhihu.com/p/32297243</p>
<p>ES2016 - ES2019
https://zhuanlan.zhihu.com/p/59096242</p>
<p>Rollup实践笔记
https://chenshenhai.github.io/rollupjs-note/</p>
<p>WebSocket协议
http://www.ruanyifeng.com/blog/2017/05/websocket.html
https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096</p>
<p>DOM Viewer
http://software.hixie.ch/utilities/js/live-dom-viewer/</p>
<p>Tree shaking介绍
https://webpack.docschina.org/guides/tree-shaking/</p>
<p>Google Closure Compiler高级压缩混淆Javascript代码
https://www.cnblogs.com/DDgougou/p/9355567.html
Closure/Rollup/Webpack压缩代码对比
https://www.syntaxsuccess.com/viewarticle/closure-compiler-vs-rollup-vs-webpack</p>
<p>Dom api
https://harttle.land/2015/10/01/javascript-dom-api.html</p>
<p>前端手册
https://frontendmasters.com/books/front-end-handbook/2019/</p>
<p>Prepack，主要优化代码性能
https://prepack.io/</p>
<p>Closure，主要减小包大小
https://developers.google.com/closure/library/</p>
<p>TypeScript
https://github.com/semlinker/awesome-typescript</p>
<p>//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
Html相关</p>
<p>CSS布局：
https://zh.learnlayout.com/</p>
<p>在线体验
https://codepen.io/pen/?&amp;editable=true</p>
<p>CSS表达长度的不同单位
https://www.w3.org/Style/Examples/007/units.zh_CN.html</p>
<p>http://www.bootcss.com/</p>
<p>https://codepen.io</p>
<p>html支持自定义标签
http://www.ruanyifeng.com/blog/2017/06/custom-elements.html</p>
<p>css的padding会影响元素的宽度的
https://blog.csdn.net/lzhlzz/article/details/52937310
https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing</p>
<p>001
https://codepen.io/alvaromontoro/pen/dwPeNZ</p>
<p>SVG能力
http://www.w3school.com.cn/svg/svg_rect.asp</p>
<p>js代码放的位置也需要注意，body跟head是有区别的
https://www.cnblogs.com/ddyq/archive/2012/03/06/2382816.html</p>
<p>css布局
https://www.jianshu.com/p/c6673f8a6a5a</p>
<p>node中包含一个叫global的全局对象
http://www.runoob.com/nodejs/nodejs-global-object.html</p>
<p>//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
JS相关</p>
<p>标签函数
https://zhuanlan.zhihu.com/p/31687266</p>
<p>官方文档
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference</p>
<p>JS 编码规范：
https://github.com/BingKui/javascript-zh</p>
<p>JS是如何工作的
https://segmentfault.com/blog/zsxuexi
https://segmentfault.com/a/1190000017927665</p>
<p>尽量使用 const</p>
<p>数组也是类，数组的每个数据，都是一个属性，但这个属性没办法直接通过.0、.1这样访问，必须要通过 a[0]、a[1]这样来访问。
访问数组越界也没问题，返回的值就会变成undefined</p>
<p>可以通过数组的方式来将数组赋值给新的名称
var arr = [1, 2, 3]
const [a, b] = arr
console.log(a, b)    // 输出：1 2
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</p>
<p>JS是单线程的
Web Worker，可以为JS创造多线程运行环境
http://www.ruanyifeng.com/blog/2018/07/web-worker.html</p>
<p>JavaScript 秘密花园
http://bonsaiden.github.io/JavaScript-Garden/zh/</p>
<p>JS博客
https://github.com/mqyqingfeng/Blog</p>
<p>es6入门
http://es6.ruanyifeng.com/</p>
<p>es6的generator (协程)
http://es6.ruanyifeng.com/#docs/generator</p>
<p>扩展运算符
https://blog.csdn.net/qq_30100043/article/details/53391308</p>
<p>js代码小片断
https://github.com/30-seconds/30-seconds-of-code</p>
<p>前端日报
http://caibaojian.com/t/前端日报</p>
<p>简单的编译器
https://juejin.im/entry/59cdbe11f265da06633d4ac2</p>
<p>Dart可以转为js
http://www.dartlang.cc/docs/dart-up-and-running/contents/ch04-tools-dart2js.html</p>
<p>typescript练习
http://www.typescriptlang.org/play/</p>
<p>http://www.ruanyifeng.com/blog/2017/09/asmjs_emscripten.html</p>
<p>JS函数式编程指南
https://legacy.gitbook.com/book/llh911001/mostly-adequate-guide-chinese</p>
<p>http://www.ruanyifeng.com/blog/2017/03/ramda.html
http://www.bootcss.com/p/underscore/</p>
<p>http://asmjs.org/</p>
<p>WebAssembly，编译运行
http://web.jobbole.com/95160/</p>
<p>https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</p>
<p>//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
CSS相关</p>
<p>Display: http://www.w3school.com.cn/cssref/pr_class_display.asp
Margin: http://www.w3school.com.cn/cssref/pr_margin.asp
Padding: http://www.w3school.com.cn/cssref/pr_padding.asp</p>
<p>派生选择器
ID选择器
类选择器</p>
<p>CSS的多重选择器
https://pjchender.blogspot.com/2015/03/cssmultiple-selectorsspace.html</p>
<p>Flex 布局教程
http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html
https://www.jianshu.com/p/f82262002f8a</p>
<p>Flex 布局实例
http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</p>
<p>弹性盒子
https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes</p>
<p>Grid布局
https://www.css88.com/archives/8510</p>
<p>css中的 &gt; + ~ 区别
https://www.webdesigns.com.tw/CSS-webdesign-170811.asp</p>
<p>http://zhoon.github.io/css3/2014/08/23/flex.html</p>
<p>Flex Basis与Width的区别
https://www.jianshu.com/p/17b1b445ecd4</p>
<p>http://www.runoob.com/try/try.php?filename=trycss3_flex-basis</p>
<p>CSS相关基础教程
http://www.w3school.com.cn/css/index.asp</p>
<p>CSS编码规范：
https://segmentfault.com/a/1190000002460968</p>
<p>CSS示例
https://github.com/mdn/css-examples</p>
<p>小程序Grid示例
https://juejin.im/entry/5b8c8c346fb9a019d3344d84</p>
<p>CSS Float：
http://www.runoob.com/css/css-float.html
一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</p>
<p>BFC介绍:
https://juejin.im/post/5909db2fda2f60005d2093db</p>
<p>https://github.com/chokcoco/CSS-Inspiration</p>
<p>//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// </p>
<p>前端周报
https://github.com/Tnfe/TNFE-Weekly</p>
<p>https://github.com/Microsoft/frontend-bootcamp</p>
<p>sketch转js代码
https://github.com/ashnkumar/sketch-code</p>
<p>小程序UI库
https://github.com/weilanwl/ColorUI</p>
<p>//////////////////////////////////////////////////////////////////////// </p>
<p>[React技术内幕] key带来了什么
https://juejin.im/post/59abb01c518825243f1b6dad</p>
<p>阮一峰Webpack教程
https://github.com/ruanyf/webpack-demos</p>
<p>深入浅出webpack
http://webpack.wuhaolin.cn/</p>
<p>https://docschina.org/</p>
<p>前端电子书
https://juejin.im/post/5c0098f66fb9a049dd80019e</p>
<p>嵌入式JS模板引擎
https://ejs.bootcss.com/</p>
<p>JS教程
http://wangdoc.com/javascript/index.html</p>
<p>CheckList
https://frontendchecklist.io/</p>
<p>https://github.com/yangshun/front-end-interview-handbook</p>
<p>https://github.com/topics/front-end-development</p>
<p>export、import使用
http://es6.ruanyifeng.com/?search=import&amp;x=0&amp;y=0#docs/module#export-default-%E5%91%BD%E4%BB%A4
import命令是编译阶段执行的，在代码运行之前
一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>
<p>React中文教程
https://react.docschina.org/</p>
<p>VSCode插件
https://segmentfault.com/a/1190000011779959</p>
<p>////////////////////////////////////////////////////////////////////////</p>
<p>小程序相关</p>
<p>要让小程序里支持npm
在工作目录里，要先执行npm init</p>
<p>微信小程序开发资源汇总：
https://github.com/justjavac/awesome-wechat-weapp</p>
<p>mpvue使用
http://mpvue.com/mpvue/quickstart/#_1</p>
<p>////////////////////////////////////////////////////////////////////////</p>
<p>Vue相关</p>
<p>new Vue参数
https://www.jianshu.com/p/cf2611ed1b1f</p>
<p>Vue支持在vscode中直接运行调试：
https://cn.vuejs.org/v2/cookbook/debugging-in-vscode.html</p>
<p>Vue技术内幕
http://hcysun.me/vue-design/</p>
<p>vue组件入门
http://www.cnblogs.com/keepfool/p/5625583.html</p>
<p>vue学习
http://www.runoob.com/vue2/vue-start.html
https://cn.vuejs.org/
https://vuefe.cn/v2/guide/
https://jsfiddle.net/chrisvfritz/50wL7mdz/</p>
<p>vue相关的UI组件比较</p>
<p>////////////////////////////////////////////////////////////////////////////////////////////////////////////</p>
<p>Webpack相关</p>
<p>Webpack中文指南
https://zhaoda.net/webpack-handbook/index.html</p>
<p>Webpack的配置
https://webpack.docschina.org/configuration</p>
<p>web-dev-server使用
https://segmentfault.com/a/1190000006670084</p>
<p>vue、webpack简单模板生成
https://github.com/vuejs-templates/webpack-simple</p>
<p>https://segmentfault.com/q/1010000008881292
路径中@的含义</p>
<p>html-webpack-plugin介绍
https://webpack.docschina.org/plugins/html-webpack-plugin/</p>
<p>webpack-dev-server的使用
https://segmentfault.com/a/1190000006670084</p>
<p>////////////////////////////////////////////////////////////////////////////////////////////////////////////</p>
<p>JS模块 (AMD、CommonJS介绍及对比)
https://zhuanlan.zhihu.com/p/22890374  （最后面介绍的es6的模块管理)</p>
<p>CommonJS
http://javascript.ruanyifeng.com/nodejs/module.html</p>
<p>模块打包
https://zhuanlan.zhihu.com/p/22945985
模块打包，把所有的模块合并到一个或几个文件中，以此来减少HTTP请求数。</p>
<p>package.json配置项文档
https://docs.npmjs.com/files/package.json
https://www.cnblogs.com/tzyy/p/5193811.html</p>
<p>ejs介绍
https://ejs.bootcss.com/</p>
<p>Sass，对css的扩展 (SCSS)
http://sass.bootcss.com/docs/sass-reference/</p>
<p>Node.js笔记
https://github.com/chyingp/nodejs-learning-guide</p>
<p>babel使用
http://es6.ruanyifeng.com/#docs/intro#Babel-%E8%BD%AC%E7%A0%81%E5%99%A8</p>
<p>babel配置参数解释
https://www.vanadis.cn/2017/03/18/babel-stage-x/
https://babeljs.io/docs/en/babel-preset-stage-0/</p>
<p>babel的polyfill和runtime的区别
https://segmentfault.com/q/1010000005596587</p>
<p>////////////////////////////////////////////////////////////////////////</p>
<p>html中使用SVG图像
http://javascript.ruanyifeng.com/htmlapi/svg.html</p>
<p>AST for JavaScript developers
https://github.com/CodeLittlePrince/blog/issues/19</p>
<p>mustache语法
https://www.jianshu.com/p/a4eee37b2849</p>
<p>BOM和DOM的区别
https://blog.csdn.net/xiao__gui/article/details/8315148</p>
<p>////////////////////////////////////////////////////////////////////////</p>
<p>精读周刊
https://github.com/dt-fe/weekly</p>
<p>////////////////////////////////////////////////////////////////////////</p>
<p>H5标准
https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5</p>
<p>H5中可以使用WebGL，来开发相应游戏 (https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API)
微信小游戏也是基于该能力。</p>
<p>three.js是基于WebGL开发的H5 3D库
https://threejs.org/
https://github.com/mrdoob/three.js/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html"><a class="header" href="#html">HTML</a></h1>
<h3 id="html5"><a class="header" href="#html5">HTML5</a></h3>
<p>HTML5类别</p>
<ul>
<li>离线：<code>Local storage</code>、<code>IndexDB</code>、<code>Application Cache</code>（已废弃，被<code>Service Workers</code>代替）</li>
<li>连接：<code>WebSockets</code>、<code>Server-Sent Events</code> (参考：<a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html">Server-Sent Events 教程</a>)</li>
<li>……</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="css"><a class="header" href="#css">CSS</a></h1>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/11/css-paint-api-canvas/">CSS Paint API</a></p>
<p>CSS Paint API目前支持的浏览器：https://caniuse.com/css-paint-api</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="js"><a class="header" href="#js">JS</a></h1>
<h3 id="资料-17"><a class="header" href="#资料-17">资料</a></h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/102284595">JS基础知识测试</a></li>
<li><a href="https://github.com/30-seconds/30-seconds-of-code">JS小片断</a></li>
<li><a href="https://segmentfault.com/a/1190000017927665">JavaScript是如何工作的</a></li>
<li><a href="Web/../Note/ProfessionalJS.html">JavaScript高级程序设计</a></li>
<li><a href="https://github.com/doodlewind/jshistory-cn">JavaScript 20 年</a></li>
</ul>
<h3 id="js动态特性"><a class="header" href="#js动态特性">JS动态特性</a></h3>
<p>JavaScript 虽然被称为是“动态语言”，但确实是拥有静态语义的。</p>
<pre><code class="language-shell"># 这些执行在不同的环境中，表现其实是不一样的，如在node、chrome的控制台中表现也不一样

&gt; [] + {}
'[object Object]'

# 这一行，由于自动分号插入，会被解析成：{}; + []
# +[] 等价于：Number([])
&gt; {} + []
0

&gt; {} + {}
NaN

&gt; [] + []
''
</code></pre>
<ul>
<li>js支持在对象定义之后，动态的 添加 / 修改 / 删除 / 查询</li>
</ul>
<h5 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h5>
<ul>
<li>在算术函数和表达式中，会自动进行 number 类型转换。(如<code>&quot;6&quot; / &quot;2&quot;</code>，结果为3)</li>
<li>任何对象转为boolean类型时，都为true</li>
</ul>
<p>JS中存在两种大的类型，<code>引用类型</code>和<code>值类型</code>。<code>引用类型</code>细分为<code>对象</code>和<code>函数</code>，其它的类型为<code>值类型</code>。</p>
<p>从<code>值</code>到<code>引用</code>，使用<code>Object(x)</code>，这个方法是安全无副作用的。从<code>引用</code>到<code>值</code>，使用<code>x.valueOf()</code></p>
<p>“任何东西都是可以转换为字符串的”，这个在理论上是行的通，但实际是存在一些无法完成转换的情况。这种情况下，转换为字符串，只会得到一个“简单的描述”，仅能表示“这是一个对象”，而没有其它意义。</p>
<p>JavaScript 约定，所有“对象 -&gt; 值”的转换结果要尽量地趋近于 string、number 和 boolean 三者之一。</p>
<h3 id="其它-4"><a class="header" href="#其它-4">其它</a></h3>
<h4 id="jsaot"><a class="header" href="#jsaot">JSAOT</a></h4>
<p>JS/TS转C语言</p>
<p>https://github.com/andrei-markeev/ts2c</p>
<p>https://andrei-markeev.github.io/ts2c/</p>
<p>https://github.com/NectarJS/nectarjs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-1"><a class="header" href="#typescript-1">TypeScript</a></h1>
<h3 id="资料-18"><a class="header" href="#资料-18">资料</a></h3>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1499075">VSCode使用ts-node 调试TypeScript代码</a></li>
<li><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解 TypeScript</a></li>
</ul>
<h3 id="语法-1"><a class="header" href="#语法-1">语法</a></h3>
<ul>
<li>支持可选参数，通过在参数类型后加<code>?</code>。可选参数需要放在参数列表的后面</li>
<li>支持默认参数</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react"><a class="header" href="#react">React</a></h1>
<h3 id="概念-1"><a class="header" href="#概念-1">概念</a></h3>
<h4 id="jsx"><a class="header" href="#jsx">JSX</a></h4>
<p>React建议使用<code>JSX</code>：<a href="https://zh-hans.reactjs.org/docs/introducing-jsx.html">JSX 简介</a></p>
<p>使用JSX有如下优点：</p>
<ul>
<li>
<p>编译为JS时，会进行代码的优化</p>
</li>
<li>
<p>代码更清晰、更易维护</p>
</li>
<li>
<p>类型安全的</p>
</li>
</ul>
<h4 id="virtual-dom"><a class="header" href="#virtual-dom">Virtual DOM</a></h4>
<p>React中很重要的一个概念就是<code>Virtual DOM</code></p>
<p>至于引入VDOM的原因，是因为直接操作DOM的成本太高。参考：<a href="Web/./DOM.html">DOM</a></p>
<p>React的<code>createElement</code>接口，即是创建Virtual DOM的操作</p>
<p><code>ReactDOM.render</code>操作可以将虚拟DOM渲染到真正的DOM中</p>
<p>​	</p>
<h4 id="diff算法"><a class="header" href="#diff算法">Diff算法</a></h4>
<p>Diff采用了一些策略，将时间复杂度降为O(n)</p>
<blockquote>
<p>传统的Diff算法，循环递归对比差异，算法复杂度为O(n3)</p>
<p>但在React中，跨层级的DOM操作非常少，这是Diff算法优化的前提</p>
</blockquote>
<p>一个简单的Virtual DOM的实现，包含了简单的diff：<a href="https://github.com/livoras/blog/issues/13">深度剖析：如何实现一个 Virtual DOM 算法</a></p>
<h4 id="react-hooks"><a class="header" href="#react-hooks">React Hooks</a></h4>
<p>简单来说，<code>React Hooks</code>是一组新的API，目的是为了解决React类层级太深太复杂的问题。React团队希望组件变为纯粹的数据管道，而非组件类。因为提供了<code>React Hooks</code>，可以理解为可以用函数的方式来提供组件，并且函数也可以维护自己的内部状态。</p>
<blockquote>
<p><strong>React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码&quot;钩&quot;进来。</strong> React Hooks 就是那些钩子。</p>
<p>你需要什么功能，就使用什么钩子。React 默认提供了一些常用钩子，你也可以封装自己的钩子。</p>
<p>所有的钩子都是为函数引入外部功能，所以 React 约定，钩子一律使用<code>use</code>前缀命名，便于识别。你要使用 xxx 功能，钩子就命名为 usexxx。</p>
</blockquote>
<p>参考：<a href="https://www.ruanyifeng.com/blog/2019/09/react-hooks.html">React Hooks 入门教程</a></p>
<h3 id="原理-1"><a class="header" href="#原理-1">原理</a></h3>
<h4 id="工作步骤"><a class="header" href="#工作步骤">工作步骤</a></h4>
<p><a href="https://cloud.tencent.com/developer/article/1520009">一文掌握React 渲染原理及性能优化</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vue"><a class="header" href="#vue">Vue</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-1"><a class="header" href="#webassembly-1">WebAssembly</a></h1>
<p><a href="http://webassembly.org.cn/docs/high-level-goals/">WebAssembly的长久目标</a></p>
<p><a href="http://webassembly.org.cn/docs/use-cases/">WebAssembly使用场景</a></p>
<h3 id="支持的语言"><a class="header" href="#支持的语言">支持的语言</a></h3>
<p><a href="http://webassembly.org.cn/docs/c-and-c++/">C/C++</a></p>
<p><a href="https://www.rust-lang.org/zh-CN/">Rust</a></p>
<p><a href="https://github.com/golang/go/wiki/WebAssembly">go</a></p>
<p><a href="https://swiftwasm.org/">Swift</a> (fork后还未合入swift工程)</p>
<p>语言列表：<a href="https://github.com/appcypher/awesome-wasm-langs">awesome-wasm-langs</a></p>
<h3 id="解释引擎"><a class="header" href="#解释引擎">解释引擎</a></h3>
<ul>
<li><a href="https://github.com/wasm3/wasm3">wasm3</a> 支持在iOS上使用</li>
</ul>
<h3 id="asmjs"><a class="header" href="#asmjs">asm.js</a></h3>
<p><code>asm.js</code>可以理解为<code>wasm</code>的前身，也是通过符合指定的条件，来让JS代码在某些JS引擎上执行更快。asm.js更多是面向JS引擎，而非普通开发者的。</p>
<h3 id="资料-19"><a class="header" href="#资料-19">资料</a></h3>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2017/09/asmjs_emscripten.html">asm.js 和 Emscripten 入门教程</a></li>
<li><a href="https://blog.csdn.net/code_for_free/article/details/53674210">asm.js：面向未来的开发</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25865972">WebAssembly 为什么比 asm.js 快？</a></li>
<li><a href="https://github.com/poetries/browser-working-principle/blob/master/docs/guide/part3/lesson14.md">编译器和解析器：V8如何执行一段JavaScript代码的</a></li>
<li><a href="https://www.zhihu.com/people/hu-zi-da-ha/posts">WebAssembly系列</a></li>
<li><a href="https://www.w3.org/2019/12/pressrelease-wasm-rec.html.zh">WebAssembly标准</a></li>
<li><a href="https://webassembly.studio/">Webassembly.studio</a> 创建在线的WASM工程页面，支持C/Rust等</li>
<li><a href="http://mbebenita.github.io/WasmExplorer/">WasmExplorer</a> 可以在线生成WAT和WASM文件</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly">MDN文档</a></li>
<li><a href="https://wapm.io/">WAPM</a> WebAssembly Package Manager</li>
<li><a href="https://hltj.me/wasm/2019/04/04/standardizing-wasi.html">标准化中的 WASI</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="同源策略--跨域"><a class="header" href="#同源策略--跨域">同源策略 &amp; 跨域</a></h1>
<h3 id="跨域访问"><a class="header" href="#跨域访问">跨域访问</a></h3>
<p><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></p>
<p>要跨域访问，需要服务器也支持。在页面跨域访问时，服务器根据Origin字段，来判断访问源是否被允许。</p>
<blockquote>
<p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cookie"><a class="header" href="#cookie">Cookie</a></h1>
<h3 id="规范---a-hrefhttpstoolsietforghtmlrfc6265rfc-6265a"><a class="header" href="#规范---a-hrefhttpstoolsietforghtmlrfc6265rfc-6265a">规范   <a href="https://tools.ietf.org/html/rfc6265">RFC 6265</a></a></h3>
<p>中文版本可以参考：<a href="https://github.com/renaesop/blog/issues/4">cookie规范（RFC 6265）翻译</a></p>
<p>其它中文资料：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">HTTP cookies</a></p>
<ul>
<li>仅name、value是必须的属性外，其它都是可选的</li>
<li>属性名都是大小写不敏感的</li>
<li>Max-Age和expires都是设置过期时间的属性，Max-Age是相对过期时间，单位为秒。当两个都设置时，以Max-Age为准</li>
<li>要删除一个Cookie，可以通过设置相同的domain和path，以及已过期的时间</li>
<li>Secure属性仅在https请求中才带上相关cookie</li>
<li>HttpOnly属性，可以防止js脚本调用（即无法通过<code>Document.cookie</code>来读取），这种只能由浏览器发给服务端</li>
<li>有个新增的属性：<code>SameSite</code>，可以用来阻止跨站请求</li>
</ul>
<h3 id="cookie域"><a class="header" href="#cookie域">Cookie域</a></h3>
<p>Cookie的域使用时需要注意，<code>qq.com</code>和<code>.qq.com</code>是不一样的，简单来说，<code>.qq.com</code>是包含子域名的，比如<code>docs.qq.com</code>可以获取到<code>.qq.com</code>的，但获取不到<code>qq.com</code>的</p>
<p>Web通过<code>Set-Cookie</code>来设置cookie时，如果域上没有带前缀<code>.</code>，则cookie存到本地时会自动带上<code>.</code>。chrome、WKWebview都是这样的表现。</p>
<blockquote>
<p>具体区别可以参考：<a href="https://stackoverflow.com/questions/9618217/what-does-the-dot-prefix-in-the-cookie-domain-mean">What does the dot prefix in the cookie domain mean?</a></p>
</blockquote>
<h3 id="ios-wkwebview-cookie设置"><a class="header" href="#ios-wkwebview-cookie设置">iOS WKWebView Cookie设置</a></h3>
<p>WKWebView有三种设置Cookie的方式</p>
<p>一、通过Header中的Cookies字段来设置</p>
<pre><code class="language-swift">var req = URLRequest(url: myURL!)
let cookieValue = &quot;uin=10000; uid=10001&quot;
req.addValue(cookieValue, forHTTPHeaderField: &quot;Cookie&quot;)
self.webView.load(req)
</code></pre>
<blockquote>
<p>这种设置方式，仅在请求头里包含，前端页面通过<code>document.cookie</code>是无法读取到的</p>
</blockquote>
<p>二、通过JS注入的方式来设置</p>
<pre><code class="language-swift">let script = &quot;document.cookie = 'aaaaa=11111; domain=127.0.0.1; path=/; '; document.cookie = 'bbbbbb=22222; domain=127.0.0.1; path=/; ';&quot;
let us = WKUserScript(source: script, injectionTime: .atDocumentStart, forMainFrameOnly: false)
self.webView?.configuration.userContentController.addUserScript(us)
</code></pre>
<blockquote>
<p>这种方式设置的，在域的处理上，会跟第三点有些区别
比如设置的Cookie是<code>qq.com</code>域，但前端页面拿到的域会自动在前面添加上点号，变为<code>.qq.com</code></p>
</blockquote>
<p>三、通过将Cookie存储至<code>WKHTTPCookieStore</code>中</p>
<pre><code class="language-swift">let wkStore = WKWebsiteDataStore.default().httpCookieStore
cookies.forEach { cookie in
	wkStore.setCookie(cookie)
}
</code></pre>
<blockquote>
<p>这种方式设置的Cookie，在域的处理上也需要注意：</p>
<p>如果是访问的<code>docs.qq.com</code>，则<code>qq.com</code>域下的Cookie是不会被设置的，但<code>.qq.com</code>域下的Cookie会被设置(<code>docs.qq.com</code>、<code>.docs.qq.com</code>域的Cookie也都会被设置)</p>
</blockquote>
<h3 id="其它-5"><a class="header" href="#其它-5">其它</a></h3>
<p>服务端设置Cookie，是通过在响应头里加<code>Set-Cookie</code>字段
参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie">Set Cookie</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dom"><a class="header" href="#dom">DOM</a></h1>
<h3 id="资料-20"><a class="header" href="#资料-20">资料</a></h3>
<ul>
<li><a href="http://software.hixie.ch/utilities/js/live-dom-viewer/">Live DOM Viewer</a>：查看DOM结构的页面</li>
<li><a href="https://harttle.land/2015/10/01/javascript-dom-api.html">DOM操作API</a></li>
</ul>
<p>Virtual DOM的实现，可以参考：<a href="https://github.com/livoras/blog/issues/13">深度剖析：如何实现一个 Virtual DOM 算法</a></p>
<p>对应的实现Demo为: <a href="https://github.com/livoras/simple-virtual-dom">simple-virtual-dom</a></p>
<p><code>simple-virtual-dom</code>的实现思路也比较简单，在修改时，通过一个中间层来减少真实DOM的操作次数。</p>
<p>可以在生产环境中使用的Virtual DOM库：<a href="https://github.com/Matt-Esch/virtual-dom">virtual-dom</a></p>
<h3 id="dom操作成本高的原因"><a class="header" href="#dom操作成本高的原因">DOM操作成本高的原因</a></h3>
<ul>
<li>JS引擎与DOM引擎共享一个主线程，DOM与JS引擎切换过程会涉及非常耗时的操作</li>
<li>很多DOM API的读写涉及页面布局的重新计算</li>
</ul>
<p>单次调用DOM API的成本就较高，当频繁调用时会迅速累积这些损耗</p>
<p>更详细的介绍参考：<a href="https://www.zhihu.com/question/324992717/answer/690011952">前端为什么操作 DOM 是最耗性能的呢？</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="js引擎"><a class="header" href="#js引擎">JS引擎</a></h1>
<h3 id="v8"><a class="header" href="#v8">V8</a></h3>
<p><code>Node.js</code>、<code>deno</code>也是基于V8开发的</p>
<p><a href="https://zhuanlan.zhihu.com/p/27628685">认识 V8 引擎</a></p>
<p><a href="https://github.com/poetries/browser-working-principle/blob/master/docs/guide/part3/lesson14.md">编译器和解析器：V8如何执行一段JavaScript代码的</a></p>
<p><a href="http://newhtml.net/category/v8%e4%b8%93%e9%a2%98/">V8 之旅</a></p>
<p><a href="https://github.com/bluezhan/v8">初探V8 JavaScript引擎</a></p>
<h5 id="v8高效的原因"><a class="header" href="#v8高效的原因">V8高效的原因</a></h5>
<ul>
<li>JIT编译</li>
<li>精确垃圾回收管理</li>
<li>内联缓存</li>
<li>隐藏类</li>
</ul>
<p>来源: <a href="https://www.jianshu.com/p/8290715feec6">Chrome V8 与 Node.js</a></p>
<h3 id="hermes"><a class="header" href="#hermes">Hermes</a></h3>
<p><code>Hermes</code>是Facebook专门针对RN开发的一款JS引擎。其它的引擎设计之初，主要面向的桌面端，所以在移动端上存在一些问题。比如内存占用、引擎大小等。</p>
<p>因为Hermes的定位原因，存在如下特点：</p>
<ul>
<li>使用字节码预编译</li>
<li>放弃了JIT (原因是影响启动时间、引擎大小、内存占用等)</li>
<li>纯文本的JS代码执行效率会降低 (因为放弃了JIT)</li>
</ul>
<h3 id="javascriptcore"><a class="header" href="#javascriptcore">JavaScriptCore</a></h3>
<p>JavaScriptCore是开源的，源码：<a href="https://github.com/WebKit/webkit/tree/master/Source/JavaScriptCore">Source/JavaScriptCore</a></p>
<h4 id="资料-21"><a class="header" href="#资料-21">资料</a></h4>
<p><a href="https://www.jianshu.com/p/b5c6207edb98">如何优化JavaScriptCore</a>：比较详细的介绍了JSCore的劣势</p>
<p><a href="https://ming1016.github.io/2018/04/21/deeply-analyse-javascriptcore/">深入剖析 JavaScriptCore</a>：偏原理和实现的文章</p>
<p><a href="https://zhuanlan.zhihu.com/p/81634837">深入浅出JavaScriptCore</a></p>
<p><a href="https://www.jianshu.com/p/ac534f508fb0">深入浅出JavaScriptCore</a>：偏使用</p>
<h4 id="ios平台上的javascriptcore特性"><a class="header" href="#ios平台上的javascriptcore特性">iOS平台上的JavaScriptCore特性</a></h4>
<p>来源：<a href="https://www.jianshu.com/p/b5c6207edb98">如何优化JavaScriptCore</a></p>
<ul>
<li>性能差，不支持JIT</li>
<li>不支持WASM</li>
</ul>
<p>关于性能差，WKWebview中使用的<code>Nitro</code>要比系统提供的<code>JSCore</code>快<code>2~20</code>倍。 主要原因就是JSCore不支持JIT导致的</p>
<blockquote>
<p>来源：https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/
<em>由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。</em></p>
</blockquote>
<p>在iOS上JavaScriptCore是作为单独的Framework提供的，并且UIWebview默认没有提供JavaScriptCore的接口。</p>
<p>不过还有办法可以从UIWebview中获取到JSContext：</p>
<pre><code class="language-oc">// 获取JSContext
JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];
</code></pre>
<p>但此方法仅对UIWebview适用。在WKWebview上，已经不再使用JavaScriptCore引擎，而是换成了Nitro。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvas"><a class="header" href="#canvas">Canvas</a></h1>
<h3 id="资料-22"><a class="header" href="#资料-22">资料</a></h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial">Canvas教程</a></p>
<p><a href="https://github.com/supperjet/H5-Animation.git">H5 Animation</a></p>
<h3 id="原理-2"><a class="header" href="#原理-2">原理</a></h3>
<ul>
<li>Canvas目前在大部分浏览器上都有使用硬件加速</li>
<li>效率还是要比Native的绘制要差，主要原因在于浏览器中代码执行流程过长：<code>js代码 -&gt; js引擎 -&gt; 浏览器接口逻辑 -&gt; 图形库</code>。性能损耗最大的地方就在<code>js引擎</code>这儿。</li>
</ul>
<h3 id="opengl"><a class="header" href="#opengl">OpenGL</a></h3>
<p>OpenGL是统称，在移动端是指<code>OpenGLES</code>(ES即<code>Embedded Systems</code>)，Web端是指<code>WebGL</code></p>
<p>OpenGLES是OpenGL的子集，去除了历史发展导致的冗余的API。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flutter"><a class="header" href="#flutter">Flutter</a></h1>
<h3 id="资料-23"><a class="header" href="#资料-23">资料</a></h3>
<ul>
<li>
<p><a href="https://www.yuque.com/xytech/flutter">闲鱼技术文章列表</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/adC-YUWd-xuUlzeAPHzJoQ">Flutter包大小治理上的探索与实践</a></p>
</li>
</ul>
<h3 id="命令-3"><a class="header" href="#命令-3">命令</a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>flutter create my_project</code></td><td>创建名称为my_project的工程</td></tr>
<tr><td><code>flutter create --template=package hello</code></td><td>创建名为hello的package工程</td></tr>
<tr><td><code>flutter doctor</code></td><td>查看Flutter的状态，如果有些配置没配置好，也会自动配置</td></tr>
<tr><td><code>flutter upgrade</code></td><td>升级Flutter</td></tr>
<tr><td><code>flutter devices</code></td><td>查看可用设备列表</td></tr>
<tr><td><code>flutter channel</code></td><td>查看flutter分支，以及当前处于哪个分支上</td></tr>
<tr><td><code>flutter channel master</code></td><td>切换flutter至master分支</td></tr>
<tr><td><code>flutter pub get</code></td><td>获取工程依赖包</td></tr>
<tr><td><code>flutter pub upgrade</code></td><td>依赖包更新</td></tr>
<tr><td><code>flutter run</code></td><td>运行工程，可以用-d指定设备，如：<code>flutter run -d macOS</code></td></tr>
<tr><td><code>flutter test --coverage</code></td><td>查看测试覆盖率</td></tr>
</tbody></table>
<p>flutter的分支有如下几种：</p>
<ul>
<li>master: 最新代码分支，是最不稳定的，新增的功能后续也可能删除</li>
<li>dev: 当前最新，且经过充分测试的分支</li>
<li>beta: 每月从dev中选出的最优的作为beta</li>
<li>stable: 当前最稳定的分支</li>
</ul>
<h3 id="android-studio快捷键"><a class="header" href="#android-studio快捷键">Android Studio快捷键</a></h3>
<table><thead><tr><th>快捷键</th><th>含义</th></tr></thead><tbody>
<tr><td><code>Optional + Enter</code></td><td>在某Widget上操作时，可以查看所有可以针对Widget的操作`</td></tr>
<tr><td><code>Cmd + [</code> 及<code>Cmd + ]</code></td><td>浏览代码时的后退和前进</td></tr>
</tbody></table>
<p>Android Studio也可以将快捷键设为其它IDE的，比如可以设置为Visual Studio的：<a href="https://www.jianshu.com/p/2f6248d5842c">Android Studio - 快捷键详解-MAC版</a></p>
<h3 id="工程设置"><a class="header" href="#工程设置">工程设置</a></h3>
<h4 id="依赖设置"><a class="header" href="#依赖设置">依赖设置</a></h4>
<p>在<code>pubspec.yaml</code>中，<code>dependencies</code>项中添加依赖</p>
<table><thead><tr><th>语法</th><th>作用</th></tr></thead><tbody>
<tr><td><code>zefyr:</code></td><td>版本号不限定，尽可能使用新版本。也可以使用<code>zefyr: any</code></td></tr>
<tr><td><code>zefyr: ^0.8</code></td><td>指明可以是兼容0.8的所有版本</td></tr>
<tr><td><code>zefyr: '&gt;=0.8.0 &lt;0.10.0'</code></td><td>指明版本号范围，为大于等于0.8，小于0.10</td></tr>
</tbody></table>
<p>flutter的所有可用依赖包，以及依赖包的更新日志，可以在<a href="https://pub.dev/">pub.dev</a>上搜索查看</p>
<p>​	</p>
<h3 id="vscode-1"><a class="header" href="#vscode-1">VSCode</a></h3>
<p>使用VSCode调试时，要选择不同的设备进行调试：</p>
<ul>
<li><code>Cmd + Shift + P</code>打开命令面板</li>
<li>选择<code>Flutter: Select Device</code></li>
<li>选择指定的设备即可，此时再调试，就会使用指定的设备了</li>
</ul>
<h3 id="开发问题"><a class="header" href="#开发问题">开发问题</a></h3>
<ol>
<li>
<p>遇到: <code>Waiting for another flutter command to release the startup lock</code></p>
<blockquote>
<p>执行 <code>rm -rf ~/dev/flutter/bin/cache/lockfile</code></p>
</blockquote>
<p>路径注意换成自己的flutter安装目录</p>
</li>
<li>
<p>遇到：<code>could not find included file 'Pods/Target Support Files/Pods-Runner</code></p>
<blockquote>
<p>到<code>Podfile</code>所在目录，再手动执行一次<code>pod install</code></p>
</blockquote>
</li>
</ol>
<h3 id="性能优化"><a class="header" href="#性能优化">性能优化</a></h3>
<ul>
<li><a href="https://www.sunmoonblog.com/2020/01/10/flutter-performance-tools/">Flutter Performance 分析工具简介</a></li>
<li><a href="https://www.youtube.com/watch?v=OLjhAl7adGE&amp;t=33s">深入了解 Flutter 的高性能图形渲染</a></li>
</ul>
<p>在真机上跑DevTools：<code>flutter run --profile -d deviceid</code></p>
<blockquote>
<p>跑起来之后，会在控制台中输出查看链接</p>
</blockquote>
<p>在AS中直接跑Profile操作路径为：<code>Run</code> -&gt; <code>Profile</code> (参考：<a href="https://flutter.dev/docs/perf/rendering/ui-performance#run-in-profile-mode">run-in-profile-mode</a>)</p>
<h3 id="参考源码"><a class="header" href="#参考源码">参考源码</a></h3>
<p><a href="https://github.com/X-Wei/flutter_catalog">Flutter_Catalog</a>: Appstore上有提供App，可以边看效果，边看代码</p>
<p><a href="https://github.com/Solido/awesome-flutter">awesome-flutter</a></p>
<h3 id="常用packages"><a class="header" href="#常用packages">常用Packages</a></h3>
<h5 id="a-hrefhttpspubdevpackagesjson_serializablejson_serializablea"><a class="header" href="#a-hrefhttpspubdevpackagesjson_serializablejson_serializablea"><a href="https://pub.dev/packages/json_serializable">json_serializable</a></a></h5>
<p>主要参考：https://www.jianshu.com/p/84a0b551e3eb</p>
<p>这个库的使用有依赖<code>build_runner</code>这个库，并且需要在根目录执行<code>flutter packages pub run build_runner build</code>来生成相应的文件</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flutter框架"><a class="header" href="#flutter框架">Flutter框架</a></h1>
<h3 id="入门文章"><a class="header" href="#入门文章">入门文章</a></h3>
<p><a href="https://flutterchina.club/cookbook/">CookBook</a></p>
<blockquote>
<p>包含了最简单的Image、列表等的使用</p>
</blockquote>
<p><a href="https://book.flutterchina.club/">Flutter实战</a></p>
<blockquote>
<p>包含了比较全面的知识点，这儿为相应源码：https://github.com/wendux/flutter_in_action_source_code.git</p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/58782294">MaterialApp 和 Scaffold</a> :也包含了<code>bottomNavigationBar</code>的使用</p>
<p><a href="https://flutter.cn/docs/development/add-to-app">Flutter混合开发</a></p>
<p>Flutter混合栈管理方案：<a href="https://github.com/hellobike/thrio">thrio</a>、<a href="https://github.com/alibaba/flutter_boost">flutter_boost</a></p>
<p><a href="https://flutter.cn/docs/resources/faq">Flutter常见问题说明</a></p>
<p>Flutter基础概念，如<code>Widget</code>、<code>Context</code>等。
https://juejin.im/post/5c768ad2f265da2dce1f535c</p>
<p><a href="https://zhuanlan.zhihu.com/p/67020528">Flutter 开发实战与前景展望</a></p>
<p><a href="https://codepen.io/flutter">Flutter在线代码</a></p>
<p><a href="https://legacy.gitbook.com/book/wizardforcel/gsyflutterbook/details">Flutter 完整开发实战详解系列</a></p>
<h3 id="能力及组件预览"><a class="header" href="#能力及组件预览">能力及组件预览</a></h3>
<h5 id="组件"><a class="header" href="#组件">组件</a></h5>
<p><a href="https://github.com/toly1994328/FlutterUnit.git">FlutterUnit</a>: 非常好的查看各组件使用的示例</p>
<p><a href="https://flutter-go.pub/flutter_go_web/#WidgetPage">Flutter go组件预览</a>: 可以查看有哪些组件可用，展示效果如何</p>
<p><a href="https://flutter-widget.live/zh_CN/basics/introduction">Flutter组件实时预览</a>：更全面的组件预览，包括动画等</p>
<h5 id="示例"><a class="header" href="#示例">示例</a></h5>
<p><a href="https://github.com/lohanidamodar/flutter_ui_challenges">flutter_ui_challenges</a>: 可以查看各种效果，以及代码如何实现</p>
<p><a href="https://github.com/2d-inc/HistoryOfEverything">HistoryOfEverything</a>: 万物起源的代码，做的很漂亮的应用</p>
<p><a href="https://codepen.io/topic/flutter/templates">Codepen在线示例</a></p>
<h3 id="开发知识点"><a class="header" href="#开发知识点">开发知识点</a></h3>
<h5 id="获取屏幕宽高度"><a class="header" href="#获取屏幕宽高度">获取屏幕宽高度</a></h5>
<pre><code class="language-dart">final size = MediaQuery.of(context).size;
final width = size.width;
final height = size.height; 
</code></pre>
<h5 id="添加图片资源"><a class="header" href="#添加图片资源">添加图片资源</a></h5>
<p>要在pubspec.yaml中进行配置，指定支持的资源目录 (搜索assets关键词，有默认代码，打开之后做相应修改就可以)</p>
<h5 id="获取状态栏高度"><a class="header" href="#获取状态栏高度">获取状态栏高度</a></h5>
<pre><code class="language-dart">double statusBarHeight = MediaQuery.of(context).padding.top;
</code></pre>
<h3 id="常用plugin"><a class="header" href="#常用plugin">常用Plugin</a></h3>
<ul>
<li>
<p><a href="https://pub.dev/packages/assorted_layout_widgets">assorted_layout_widgets</a>: 增强型的Row、Column等</p>
</li>
<li>
<p><a href="https://pub.dev/packages/shimmer">shimmer</a>: 给组件添加微光效果</p>
</li>
<li>
<p><a href="https://pub.dev/packages/flutter_villains">flutter_villains</a>：可以添加页面进入、弹出时的动画</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dart"><a class="header" href="#dart">Dart</a></h1>
<p>在安装了Flutter的情况下，要直接使用dart，只需要将dart sdk配置到环境变量中即可。</p>
<p>dart sdk的位置在<code>$FlutterPATH/cache/dart-sdk/bin</code>，具体使用参考：<a href="https://blog.csdn.net/qq_26287435/article/details/87917289">Dart配置环境变量</a></p>
<h3 id="dart常用命令"><a class="header" href="#dart常用命令">Dart常用命令</a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>dart main.dart</code></td><td>可以直接执行main.dart</td></tr>
<tr><td><code>dart create myproj</code></td><td>创建dart工程</td></tr>
<tr><td><code>dart create --template=package-simple mypackage</code></td><td>创建dart的package工程 （还有其它类型的template，通过<code>dart create --help</code>查看）</td></tr>
<tr><td><code>dart pub add/remove ***</code></td><td>添加/移除包依赖</td></tr>
<tr><td><code>dart pub publish</code></td><td>可以发布包至<code>pub.dev</code>上</td></tr>
<tr><td><code>pub global activate somepackage</code></td><td>安装指定脚本并激活，然后可以使用该package bin目录下的脚本 (如安装并使用fvm)</td></tr>
</tbody></table>
<h3 id="特性列表"><a class="header" href="#特性列表">特性列表</a></h3>
<ul>
<li>Dart是单线程语言 (Dart中的<code>Isolate</code>类似多线程，但不完全一样)</li>
<li>Dart函数也是一等公民</li>
<li>Dart支持内部方法 (函数里再定义函数)</li>
<li>Dart不支持内部类</li>
<li>支持对已有的类进行扩展 (如：<code>extension MyExt on num</code>，就表示扩展num类。Dart 2.7之后的能力)</li>
<li>函数对象也可以被扩展（如：可以将两个参数的函数扩展一个curry的接口）</li>
<li>支持运算符重载</li>
<li>支持泛型</li>
<li>支持协程</li>
<li>支持ffi，可调用c/c++接口：<a href="https://flutter.dev/docs/development/platform-integration/c-interop#step-2-add-cc-sources">Binding to native code using dart:ffi</a></li>
<li>支持反射 (但<a href="https://github.com/flutter/flutter/issues/1150">Flutter中不能使用</a>)：<a href="https://api.dart.dev/stable/2.8.1/dart-mirrors/dart-mirrors-library.html">dart:mirrors</a></li>
<li>支持空安全 (Dart 2.12版本之后)</li>
</ul>
<h3 id="常用语法"><a class="header" href="#常用语法">常用语法</a></h3>
<h4 id="类型"><a class="header" href="#类型">类型</a></h4>
<pre><code class="language-dart">// 类似Swift，所有的类型都是类对象，包括int
int i = 10;
i.toString();

// num类型是比较特殊的，即可以表示int，也可以表示double，并且可以在运行时修改
// 参考：https://juejin.im/post/5b9fc2ce5188255c2f420e1f
// 如下的代码是可以正常运行的
num number = 1;
number = 1.01;
print(number);	// 输出1.01

// dart中也支持泛型，能力和使用上类似swift
// 比如都支持泛型类型的限定
// 参考：https://dart.cn/guides/language/language-tour#generics
var names = List&lt;String&gt;();
names.addAll(['小芸', '小芳', '小民']);

// list的简化初始化方法：
final lst = &lt;int&gt;[];

// map的简化初始化方法：
final m = {};

///////////////////////////////////
// final、const等
final a = 10;	// final表示只能赋值一次。

final lst = &lt;int&gt;[];
lst.add(10);	// 是正常的，可以添加元素

const lst = &lt;int&gt;[];	// const更加类似Swift中的let，但也不完全一样
lst.add(10);	// 会出错，是个运行时错误，而非编译时错误
</code></pre>
<h4 id="list"><a class="header" href="#list">List</a></h4>
<pre><code class="language-dart">// 扩展操作符，向一个list中插入另外一个list
var list = [1, 2, 3];
var list2 = [0, ...list];

// null-aware 扩展操作符，可以防止被添加的list为空
var list;
var list2 = [0, ...?list];

// list中有map、where(类似filter)
// 包括Map、Set类型，也都支持map、where这样的高阶操作
// 这些高阶函数都是lazy的，也即在真正访问数据前，并不会真的过滤或转换数据
var list = [1, 2, 3];
list.where((i) =&gt; i % 2 == 0).toList();
</code></pre>
<blockquote>
<p>还存在<a href="https://api.dart.dev/stable/2.8.3/dart-collection/LinkedList-class.html">LinkedList</a>、<a href="https://api.dart.dev/stable/2.8.3/dart-collection/ListQueue-class.html">ListQueue</a>等集合。ListQueue是一种先进先出的数据结构</p>
</blockquote>
<h4 id="map"><a class="header" href="#map">Map</a></h4>
<pre><code class="language-dart">// 创建空map
var gifts = Map();

// 创建空map后，可以往其中添加不同类型的key及value
var m = Map();
m[2] = 'helium';
m['aaa'] = 'neon';
m['ccc'] = 7;

// 但如果创建map时限定了类型，则后面无法再添加不同类型的key或value
var m = {'first': 'partridge'};
m[2] = 'helium';	// Error!
</code></pre>
<blockquote>
<p>还有其它类型的Map，如：<a href="https://api.dart.dev/stable/2.8.3/dart-collection/LinkedHashMap-class.html">LinkedHashMap</a>，是有序的map。可以参考：<a href="https://juejin.im/post/5c7aaa7e6fb9a049aa6fccba">简单谈谈dart中几种Map的不同</a></p>
</blockquote>
<h4 id="set"><a class="header" href="#set">Set</a></h4>
<pre><code class="language-dart">// 创建空set
var names = &lt;String&gt;{};
names.add('green');	// 添加元素

// 创建非空set
var names = {'lucy', 'jim'};
</code></pre>
<blockquote>
<p>在<a href="https://api.dart.dev/stable/2.8.3/dart-collection/dart-collection-library.html">dart:collection library</a>中有更详细的集合列表</p>
</blockquote>
<h4 id="function"><a class="header" href="#function">Function</a></h4>
<pre><code class="language-dart">// 函数也是对象，也支持作为参数传递给另外的函数。
// 也即函数也是一等公民，就支持了函数式编程，以及高阶方法
// bool Function(int)即是定义了函数类型
// 参数类型，也可以简写为 Function
void myfun(bool Function(int) f) {
  // do sth
}

/////////////////////
// 参数相关
// 普通函数参数使用
void _funParam1(int p1, int p2) {
  print(p1 + p2);
}

// 命名参数，用{}来包括起来，调用时就要指定参数名
void _funParam2({int p1, int p2}) {
  print(p1 + p2);
}

// 使用命名参数时，参数也就是可选的，有些参数可以设置上默认值
// 如果可选参数不设置默认值时，则要在函数体内部判断参数是否为null，否则会执行异常
void _funParam3({int p1, int p2 = 2}) {
  print(p1 + p2);
}

// @required可以表示参数是必须的，如果调用时不填的话，编译期就可以检测出来
// 要使用@required，需要引入meta包：
// import 'package:meta/meta.dart';
void _funParam4({@required int p1, int p2 = 2}) {
  print(p1 + p2);
}

// {}可以只括某个参数，表示该参数是命名可选参数
void _funParam5(int p1, {int p2}) {
  print(p1 + p2);
}

// []与{}的区别是，它只表示可选，并不存在命名。称为可选位置参数。
void _funParam6(int p1, [int p2]) {
  if (p2 == null) {
    print(p1);
  } else {
    print(p1 + p2);
  }
}

void _paramTest() {
  _funParam1(1, 2);
  _funParam2(p1: 1, p2: 2); // 使用上要指定参数名
  _funParam2(p2: 2, p1: 1); // 使用命名参数时，参数的位置可以随意调整
  _funParam3(p1: 1);
  // _funParam4(); // 限定了required的参数，如果不填写，编辑器就可以提示出来不对
  _funParam4(p1: 1);
  _funParam5(1, p2: 2);
  _funParam6(1, 2); // _funParam6与_funParam5的调用区别
  _funParam6(1);
}
</code></pre>
<h4 id="运算符"><a class="header" href="#运算符">运算符</a></h4>
<pre><code class="language-dart">// as、is、is! 运算符是在运行时判断对象类型的运算符。
(emp as Person).firstName = 'Bob';	// 将obj转为Person后再赋值

// 类型检查 (is!是判断类型不为指定类型时，为true)
if (emp is Person) {
  emp.firstName = 'Bob';
}

// 赋值运算符，且仅当 b 为 null 时才赋值
b ??= value;

//////////////////////////////
// dart支持运算符重载
// 更类似C++的运算符重载，表达能力上要弱于Swift的自定义运算符
class Man {
  int a; 
  int b;
  Man(this.a, this.b);

  Man operator +(Man v) {
    return new Man(a + v.a, b + v.b);
  }
}

var man1 = new Man(1, 2);
var man2 = new Man(3, 4);

var r = man1 + man2;
print('${r.a}, ${r.b}');	// 输出：4, 6
</code></pre>
<h4 id="异常"><a class="header" href="#异常">异常</a></h4>
<pre><code class="language-dart">// dart可以将任何非null的对象作为异常拋出，而不局限于Exception或Error类型
throw FormatException('Expected at least 1 section');
throw 'Out of llamas!';

// rethrow可以将接收到的异常重新拋出去
void misbehave() {
  try {
    dynamic foo = true;
    print(foo++); // 运行时错误
  } catch (e) {
    print('misbehave() partially handled ${e.runtimeType}.');
    rethrow; // 将异常重新拋到外面
  }
}
</code></pre>
<h4 id="class"><a class="header" href="#class">Class</a></h4>
<pre><code class="language-dart">// 普通的成员变量直接用.来访问即可，但为了防止实例为空，可以用：?. 来访问属性
Point p;		// 需要引入math库：import 'dart:math';
print(p?.x);	// 输出null

// Dart2中，创建对象时可以省略new关键字
Point p = Point(1, 2);

////////////////////////////////
// 构造函数
class MyPoint {
  num x, y;

  // 如果不声明构造函数的话，系统会默认创建一个无参数的构造函数，并且会调用父类的无参构造函数

  // 默认构造函数的形式
  // 这个语法，可以简化为：
  // MyPoint(this.x, this.y);
  // 这种也要“生成式构造函数”
  MyPoint(num x, num y) {
    this.x = x;
    this.y = y;
  }
  
  // Dart也支持初始化参数列表
  MyPoint() : x = 0, y = 0;

  // 命名式构造函数，可以用来表达更明确的意图
  // https://dart.cn/guides/language/language-tour#named-constructors
  // 构造函数不能被子类继承，所以类似命名式构造函数，
  MyPoint.origin() {
    x = 0;
    y = 0;
  }

  // 初始化列表的使用，在构造函数体执行之前初始化实例变量
  MyPoint.fromJson(Map&lt;String, num&gt; json)
      : x = json['x'],
        y = json['y'] {
    print('In Point.fromJson(): ($x, $y)');
  }

  // 重定向构造函数。委托实现给主构造函数。
  MyPoint.alongXAxis(num x) : this(x, 0);

  // 除此之外，还有工厂构造方法等
  // 参考：https://dart.cn/guides/language/language-tour#constructors
}
</code></pre>
<h4 id="隐式接口"><a class="header" href="#隐式接口">隐式接口</a></h4>
<pre><code class="language-dart">class AClass {
  // 非构造函数的方法，以及所有实例成员，都有生成默认的接口
  void sayHello() {
    print(&quot;Hello&quot;);
  }

  void sayWorld() {
    print(&quot;World&quot;);
  }
}

// 使用implements关键词，就表示需要实现AClass的接口
// implements后可以指定多个类
class BClass implements AClass {
  @override
  void sayHello() {
    print(&quot;BClass: Hello&quot;);
  }

  @override
  void sayWorld() {
    print(&quot;BClass: World&quot;);
  }
}

void runCode() {
  BClass cls = BClass();
  cls.sayHello();	// BClass: Hello
  cls.sayWorld();	// BClass: World
}
</code></pre>
<h4 id="mixin"><a class="header" href="#mixin">Mixin</a></h4>
<pre><code class="language-dart">// Dart中的Mixin，类似Swift中的Protocol默认实现
// dart的Mixin使用参考：https://juejin.im/post/5d25a6d7f265da1b725c2b2a

// mixin类有两种定义方式：
// 一、定义没有构造器的class类，可以拿来作为mixin类使用（如下使用）
// 二、直接使用mixin关键字代替class类
// 即可以这样来定义： mixin MixinCls {}
class MixinCls {
  void sayWorld() {
    print(&quot;World&quot;);
  }
}

class Father {
  void sayHello() {
    print('Hello');
  }
}

class Son1 extends Father {
}

// 用with关键词，来加上Mixin类，接入Mixin类的实现
class Son2 extends Father with MixinCls {
  // 子类跟Mixin中的方法签名相同时，子类的实现有更高的优先级
  // void sayWorld() {
  //   print(&quot;Son2: World&quot;);
  // }
}

void runClasses() {
  Son1 son1 = Son1();
  son1.sayHello();
  // son1.sayWorld();   // son1是调用不了sayWorld的

  Son2 son2 = Son2();
  son2.sayHello();
  son2.sayWorld();    // 可以正常输出World
}
</code></pre>
<h4 id="异步"><a class="header" href="#异步">异步</a></h4>
<pre><code class="language-dart">////////////////////////////////
// Future就是iOS开发中理解的Promise，表示未来会产生值或会产生错误
Future&lt;String&gt; loadData() {
  sleep(Duration(seconds: 1));	// 延迟1秒

  // 随机产生成功或失败
  if (Random().nextInt(10) % 2 == 0) {
    return Future.value('Hello');
  } else {
    return Future.error('Error!');
  }
}

void runFuture() {
  // 1秒后会输出: Hello 或: Warnning! Error!
  loadData().then((v) {
    print(v);
  }).catchError((err) {
    print('Warnning! ${err}');
  });
}

////////////////////////////////
// await/async可以理解为协程的支持
// await要配合Future来使用
// 会同步的获取等待Future的结果返回，才会继续往下走
void runAwait() async {
  // 使用await来同步获取结果时，产生的错误要通过try来捕获
  try {
    String data = await loadData();
    print(data);
  } catch (e) {
    print(e);
  }
}

////////////////////////////////
// Stream类似RxSwift中的Observable，表示未来的一系列数据，能力上要强于Future
// RxDart在实现时，就没有实现Observable类，而是基于Stream扩展的
// 示例参考：https://juejin.im/post/5baa4b90e51d450e6d00f12e
Stream&lt;String&gt; readFile() async* {
  // 该方法其实是用的异步生成器来生成的Stream对象
  for (int i = 1; i &lt;= 3; i++) {
    sleep(Duration(seconds: 1));
    yield 'line ${i}';
  }
}

void runStream() {
  // 输出结果上，会每隔1秒打印一次
  readFile().listen((v) {
    print(v);
  });
}
</code></pre>
<h4 id="生成器"><a class="header" href="#生成器">生成器</a></h4>
<pre><code class="language-dart">// 生成器分同步生成器、异步生成器
// 异步生成器生成的结果就是上面提的Stream
Stream&lt;int&gt; asynchronousNaturalsTo(int n) async* {
  int k = 0;
  while (k &lt; n) yield k++;
}

// 同步生成器返回的结果是Iterable对象 (即可以使用moveNext进行迭代的对象)
// 可以通过for来枚举里面的所有元素的集合对象
// 使用同步生成器的好处在于，只有调用moveNext时，才会真正执行相应的逻辑。可以理解为lazy类型的操作
Iterable&lt;int&gt; naturalsTo(int n) sync* {
  var k = 0;
  while (k &lt; n) {
    print('Iterable count $k');
    yield k++;
  }
}

// 同步生成器真正执行的结果：
// Iterable count 0
// i:0
// Iterable count 1
// i:1
// Iterable count 2
final v = naturalsTo(10);
for (final i in v) { 
  if (i == 2) {
    break
  }
  print('i:$i');
}
</code></pre>
<h4 id="extension"><a class="header" href="#extension">Extension</a></h4>
<pre><code class="language-dart">// dart 2.7
class MyClass {
  int value;
  MyClass(this.value);
}

extension MyClsExt on MyClass {
  // 目前extension中还不支持static方法 (2021.4.15)
  // 但目前是有计划: https://github.com/dart-lang/language/blob/master/accepted/2.7/static-extension-methods/feature-specification.md
  void outputInfo() {
    print(value);
  }
}

main() {
  final c = MyClass(10);
  c.outputInfo();	// 输出10
}

</code></pre>
<h4 id="null-safety"><a class="header" href="#null-safety">Null Safety</a></h4>
<pre><code class="language-dart">// dart 2.12
// 能力及使用上非常类似于Swift中的Optional
void myfunc(int v) {
  print(v);
}

main() {
  int? v1;
  myfunc(v1);  // 编译错误
  myfunc(v1!); // 无编译错误，但会挂掉：Null check operator used on a null value

  int v2;
  myfunc(v2); // 编译错误
  
  int? v3 = 5;
  myfunc(v3); // ok
}
</code></pre>
<h4 id="const"><a class="header" href="#const">Const</a></h4>
<p><code>const</code>关键字使用需要注意：</p>
<ul>
<li>被const修饰的对象，内部所有数据都是不可更改的</li>
<li>必须由编译时可计算的数据所初始化</li>
<li>函数可选参数的默认值必须是<code>const</code>的</li>
<li>可选参数默认值，用一个<code>const</code>类型的构造器构造的对象，也必须再用<code>const</code>修饰一下</li>
<li><code>const</code>类型的构造函数，初始化列表参数中，默认初始化数据也必须用<code>const</code>来修饰 (非<code>const</code>构造函数没有这个限制)</li>
</ul>
<h3 id="高级使用"><a class="header" href="#高级使用">高级使用</a></h3>
<p><a href="https://github.com/dart-lang/sdk/blob/master/runtime/docs/pragmas.md">VM特定语法注释</a></p>
<p>在Dart库中大量使用了VM编译语法，如：<a href="https://github.com/dart-lang/sdk/blob/f04757f6ea7eab74057a1739ca37072ccbb3f733/sdk/lib/_internal/vm/lib/array.dart">_List</a>实现</p>
<h3 id="其它需要关注点"><a class="header" href="#其它需要关注点">其它需要关注点</a></h3>
<ul>
<li>List、Map中，可以添加null的 (map的key也可以为null，并且也是一个有效key)</li>
<li>一个实体类的子类，仍然可以定义为抽象类</li>
<li>所有的函数都有返回值，如果函数返回值定义为void，则接收到的返回值其实是null</li>
<li>mixin的顺序是比较重要的，后面的mixin实现会覆盖前面的实现</li>
<li><a href="https://dart.dev/tools/diagnostic-messages">dart警告</a>可以通过在代码上方加上：<code>// ignore: ***</code> 来禁用相应警告 (不建议)</li>
</ul>
<h3 id="资料-24"><a class="header" href="#资料-24">资料</a></h3>
<p><a href="https://dart.cn/guides/language/effective-dart">Dart编码规范</a></p>
<p><a href="https://dart.cn/">Dart中文文档</a></p>
<p><a href="https://dart.cn/guides/language/effective-dart/usage">高效的编码指南</a></p>
<p><a href="https://dartpad.dartlang.org/">Dart在线练习</a></p>
<p><a href="https://juejin.im/post/5c506a7c51882525c71333d2">Dart vs Swift</a></p>
<p><a href="https://github.com/arcticfox1919/learn-dart/blob/master/Dart%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3.md">Dart 异步编程详解</a>	讲Isolate非常好的文章</p>
<p><a href="https://github.com/dart-lang/dart_style/wiki/Formatting-Rules">dartfmt执行规则</a></p>
<p><a href="https://stackoverflow.com/questions/50431055/what-is-the-difference-between-the-const-and-final-keywords-in-dart">Dart中const关键词</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布局"><a class="header" href="#布局">布局</a></h1>
<p>Flutter布局比较全面的讲解：https://github.com/yang7229693/flutter-study</p>
<p>对布局原理讲解比较清晰的文章：<a href="https://mp.weixin.qq.com/s/2GFKxfAtnOozLsUiRUQPHg">必读 | 深入理解布局约束</a></p>
<h3 id="核心概念"><a class="header" href="#核心概念">核心概念</a></h3>
<h4 id="约束类型"><a class="header" href="#约束类型">约束类型</a></h4>
<p>Flutter中有<code>有限制约束</code>和<code>无限制约束</code>，有限制的含义是指，大小受限，比如Row、Column，大小受限于屏幕大小。无限制的含义是指，它本身的尺寸是不可确定的，比如ListView、ScrollView。</p>
<blockquote>
<p><a href="https://juejin.im/post/5ba1af55e51d450ea3632ab4">Flutter Container Widget 布局详解</a> 解释了各种场景的表现</p>
<p><a href="https://proandroiddev.com/understanding-flutter-layout-box-constraints-292cc0d5e807">Understanding Flutter Layout (Box)Constraints</a>: 很通俗的介绍</p>
</blockquote>
<p>这儿会导致一些表现差异，需要注意：</p>
<ul>
<li>在有限制约束中，组件会尽可能大，因为maxWidth和maxHeight是有效值</li>
<li>在无限制约束中，组件会尽可能小</li>
</ul>
<p>例如：</p>
<ul>
<li>不指定宽高的Container，放到ConstrainedBox中时，会采用ConstrainedBox的最大区间</li>
<li>不指定宽高的Container，放在ListView中时，会让Container尽可能小（此时size会为0)</li>
</ul>
<h3 id="需要关注的点"><a class="header" href="#需要关注的点">需要关注的点</a></h3>
<ul>
<li>MaterialApp的home(或routes)指定的widget，自己设置宽高是不生效，会全屏显示</li>
<li>Container的布局是比较复杂的，具体表现参考：<a href="https://api.flutter.dev/flutter/widgets/Container-class.html">Container class</a></li>
</ul>
<h3 id="相关package"><a class="header" href="#相关package">相关Package</a></h3>
<ul>
<li><a href="https://pub.dev/packages/assorted_layout_widgets">assorted_layout_widgets</a>: 提供了<code>ColumnSuper</code>、<code>RowSuper</code>等，对这些组件进行了能力扩展</li>
<li><a href="https://pub.dev/packages/flutter_screenutil">flutter_screenutil</a>： 通过设置设计稿基于的尺寸，在不同设备上比较好的显示元素</li>
<li><a href="https://github.com/Rannie/flui">flui</a>: 支持根据json来渲染UI的框架</li>
</ul>
<h3 id="代码片断"><a class="header" href="#代码片断">代码片断</a></h3>
<h5 id="padding可以控制与四周其他元素的约束"><a class="header" href="#padding可以控制与四周其他元素的约束">Padding可以控制与四周其他元素的约束</a></h5>
<pre><code class="language-dart">Padding(
    padding: EdgeInsets.only(left: 30, right: 30),
    child: Container(height: 30, color: Colors.red),
)
</code></pre>
<h5 id="部分widget固定宽度一个widget占满剩余空间"><a class="header" href="#部分widget固定宽度一个widget占满剩余空间">部分Widget固定宽度，一个Widget占满剩余空间</a></h5>
<pre><code class="language-dart">Row(
    children: &lt;Widget&gt;[
        // 左右两边有50宽度的两个元素，中间的占满剩余空间
        Container(height: 30, width: 50, color: Colors.yellow,),
        Expanded(
            child: Container(height: 30, color: Colors.red),
        ),
        Container(height: 30, width: 50, color: Colors.blueGrey,),
    ],
),
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动画-1"><a class="header" href="#动画-1">动画</a></h1>
<h3 id="资料-25"><a class="header" href="#资料-25">资料</a></h3>
<ul>
<li>
<p><a href="https://flutterchina.club/tutorials/animation/">Flutter中的动画</a></p>
</li>
<li>
<p><a href="https://flutterchina.club/animations/hero-animations/">Flutter Hero动画</a></p>
</li>
</ul>
<h3 id="核心概念-1"><a class="header" href="#核心概念-1">核心概念</a></h3>
<h5 id="tween"><a class="header" href="#tween">Tween</a></h5>
<p>Tween是插值器。Tween在实现上是简单的线性插值。Tween除了实现数据类型的线性插值，它也默认实现了其它类型的插值，如Color、Size等。</p>
<blockquote>
<p>Tween子类实现的核心是<code>lerp</code>函数。关于lerp可以参考：<a href="https://robin-front.github.io/2017/03/20/lerp-application-uses-simple-linear-interpolation-to-smooth-animation-effects.html">Lerp的应用-利用简单线性插值来平滑动画效果</a></p>
</blockquote>
<p>要使用Tween的动画，可以直接调用animate来生成相应animation对象：</p>
<pre><code class="language-dart">final ani = IntTween(begin: 0, end: 255).animate(controller);
</code></pre>
<h5 id="curve"><a class="header" href="#curve">Curve</a></h5>
<p>Curve也是插值器。相比Tween、Curve只支持double，但Curve支持比较复杂的曲线。</p>
<p><a href="https://api.flutter.dev/flutter/animation/Curves-class.html">Curves class</a>，这里面大部分定义的都是三次贝塞尔曲线。非贝塞尔的曲线有Bounce、Elastic类型的</p>
<blockquote>
<p>贝塞尔曲线的原理：https://leovan.me/cn/2019/02/bezier-curve/</p>
<p>如果要实现自己的贝塞尔曲线，可以直接用<code>Cubic</code>类，这个类的4个参数，即是4个控制点</p>
<p>Curve子类实现核心是<code>transformInternal</code>函数</p>
</blockquote>
<p>要使用Curves的效果，直接用CurvedAnimation类来构建即可</p>
<p>Tween是可以和Curve结合起来，比如实现颜色的曲线变化。如下代码：（理论上也可以在实现lerp时，利用curve返回的值实现)</p>
<pre><code class="language-dart">animation = Tween&lt;Offset&gt;(
    begin: Offset.zero,
    end: const Offset(0.8, 0.0),
).animate(CurvedAnimation(
    parent: controller,
    curve: Curves.elasticIn,
));
</code></pre>
<h3 id="动画组件"><a class="header" href="#动画组件">动画组件</a></h3>
<p>除了自己写动画逻辑，系统也预设了很多现成的动画组件，可以很方便的简化动画代码。</p>
<p>最简单的动画组件：<a href="https://api.flutter.dev/flutter/widgets/AnimatedWidget-class.html">AnimatedWidget</a>，可以用来简化动画的代码。继承自AnimatedWidget的组件，可以在实现动画时，不需要专门监听动画事件进行状态更新。</p>
<p>除此之外，还有很多动画组件，通过指定child，来给某个Widget添加动画效果。（有些组件是重载自AnimatedWidget)</p>
<ul>
<li><a href="https://api.flutter.dev/flutter/widgets/AnimatedPositioned-class.html">AnimatedPositioned</a>：Positioned的动画版，线性变化。仅工作在Stack内。</li>
<li><a href="https://api.flutter.dev/flutter/widgets/PositionedTransition-class.html">PositionedTransition</a>：AnimatedPositioned的自定义版本，可以指定变化曲线。</li>
<li><a href="https://api.flutter.dev/flutter/widgets/FadeTransition-class.html">FadeTransition</a>：渐变动画组件</li>
<li><a href="https://api.flutter.dev/flutter/widgets/SlideTransition-class.html">SlideTransition</a>：对子组件使用Offset动画</li>
<li><a href="https://api.flutter.dev/flutter/widgets/AlignTransition-class.html">AlignTransition</a>：Align的动画版本</li>
</ul>
<p>以及其他很多类似的，如<a href="https://api.flutter.dev/flutter/widgets/ScaleTransition-class.html">ScaleTransition</a>、<a href="https://api.flutter.dev/flutter/widgets/SizeTransition-class.html">SizeTransition</a>等</p>
<p>动画组件也可以相互组合，比如：</p>
<pre><code class="language-dart">// 组合ani1和ani2
FadeTransition(
  opacity: ani1,
  child: ScaleTransition(
    scale: ani2,
    child: widget
  )
)
</code></pre>
<h4 id="其它动画组件"><a class="header" href="#其它动画组件">其它动画组件</a></h4>
<ul>
<li><a href="https://flutterchina.club/catalog/samples/animated-list/">AnimatedList</a>: 可以为List的Item添加或删除时设置动画</li>
</ul>
<h3 id="页面切换动画"><a class="header" href="#页面切换动画">页面切换动画</a></h3>
<ul>
<li><a href="https://book.flutterchina.club/chapter9/route_transition.html">自定义路由切换动画</a></li>
<li><a href="https://api.flutter.dev/flutter/widgets/ModalRoute/buildTransitions.html">buildTransitions</a></li>
</ul>
<p>切换动画主要是<code>PageRouteBuilder</code>的使用，其中<code>pageBuilder</code>和<code>transitionsBuilder</code>参数是比较关键的。pageBuilder用来创建子页面,transitionBuilder用来创建动画组件。标准的做法，就是<a href="https://api.flutter.dev/flutter/widgets/ModalRoute/buildTransitions.html">buildTransitions</a>中示例代码的做法。不过，也可以省略transitionsBuilder参数，直接在pageBuilder中返回动画组件。</p>
<blockquote>
<p>如果要自定义动画时，把builder调用参数里的animation拿来作为parent就可以</p>
</blockquote>
<h3 id="hero动画"><a class="header" href="#hero动画">Hero动画</a></h3>
<h4 id="能力-1"><a class="header" href="#能力-1">能力</a></h4>
<ul>
<li>在同一个Page中，是支持多个Hero组件的</li>
<li>同一个Page中的每个Hero组件，都可以有自己的动画方式</li>
<li>通过手势滑动返回时，也可以支持Hero动画 (<code>transitionOnUserGestures</code>)</li>
</ul>
<h4 id="原理-3"><a class="header" href="#原理-3">原理</a></h4>
<p>Hero动画在执行时，实际上是有一个中间页面来操作动画。简单描述如下：</p>
<ol>
<li>在开始执行时，会先把目标Hero widget放在中间层上，然后大小和位置和源相同。</li>
<li>算出中间动画路线，并且在中间层上执行</li>
<li>执行完成后，将Hero widget放到目标页面上，然后清理中间层</li>
</ol>
<p>可以在这儿查看详细的说明：<a href="https://flutterchina.club/animations/hero-animations/#%E5%9C%A8%E5%B9%95%E5%90%8E">Flutter Hero动画 - 在幕后</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="组件-1"><a class="header" href="#组件-1">组件</a></h1>
<h3 id="scroll"><a class="header" href="#scroll">Scroll</a></h3>
<h5 id="监听scrollview的事件"><a class="header" href="#监听scrollview的事件">监听ScrollView的事件</a></h5>
<p>通过两个类来监听Scroll事件，一种是<code>Notification</code>，一种是<code>ScrollController</code></p>
<ul>
<li><a href="https://book.flutterchina.club/chapter8/notification.html">Notification</a>：可以监听滚动开始、结束、到达边界等</li>
<li><a href="https://book.flutterchina.club/chapter6/scroll_controller.html">ScrollController</a>：滚动进行时，会不变的回调，此时通过获取controller中的信息来进一步操作</li>
</ul>
<p>滚动组件到达边界后，继续滑动的效果，SDK默认提供了三种效果：iOS、安卓、不响应继续滑动。这儿也可以自己重载<code>ScrollPhysics</code>来实现不同的效果。</p>
<h3 id="nestedscrollview"><a class="header" href="#nestedscrollview">NestedScrollView</a></h3>
<ul>
<li><code>headerSliverBuilder</code>的<code>innerBoxIsScrolled</code>参数，可以很明确的知道body是否处于滚动状态，比如值为false时，当前的滚动事件，肯定是outter的scrollView发出的。</li>
<li><code>NestedScrollView</code>中设置的自定义<code>ScrollPhysics</code>是不生效的</li>
</ul>
<h3 id="sliverappbar"><a class="header" href="#sliverappbar">SliverAppBar</a></h3>
<p>可以用这个来实现导航栏展开和收起的效果: https://juejin.im/post/5c909cd3f265da610d0cbd4d</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="状态管理"><a class="header" href="#状态管理">状态管理</a></h1>
<h3 id="provider-1"><a class="header" href="#provider-1">Provider</a></h3>
<p><a href="https://flutter.cn/docs/development/data-and-backend/state-mgmt/simple">Provder Sample</a></p>
<p>实现上：</p>
<ul>
<li>基于<code>InheritedWidget</code>实现</li>
<li>数据监听使用了SDK中的<code>ChangeNotifier</code></li>
</ul>
<p>使用上：</p>
<ul>
<li>需要监听数据的Widget，外层（或其父Widget）需要用<code>ChangeNotifierProvider</code>来包装 （或者<code>MultiProvider</code>，来包装多个数据）</li>
<li>使用<code>Consumer</code>来进行数据的监听。</li>
</ul>
<pre><code class="language-dart">// 外层包装
void main() {
  runApp(
    ChangeNotifierProvider(
      create: (context) =&gt; CartModel(),
      child: MyApp(),
    ),
  );
}

// 内层使用
return Consumer&lt;CartModel&gt;(
  builder: (context, cart, child) {
    return Text(&quot;Total price: ${cart.totalPrice}&quot;);
  },
);
</code></pre>
<h3 id="bloc-1"><a class="header" href="#bloc-1">BloC</a></h3>
<ul>
<li><a href="https://github.com/felangel/bloc/blob/4dbfd4c6e28f5cb5e4115c4a6e33db70cc24a80f/docs/zh-cn/flutterbloccoreconcepts.md">Flutter Bloc的核心理念</a></li>
</ul>
<p>最简单的理解，BloC就是利用了 <code>StreamBuilder</code> + <code>Stream</code> 来管理状态的。具体可以参看该Demo:<a href="https://github.com/OpenFlutter/Flutter-Notebook/tree/master/mecury_project/example/bloc_demo">block_demo</a>,   Demo对应的文章：<a href="https://juejin.im/post/5bb6f344f265da0aa664d68a">状态管理探索篇——BLoC(三)</a></p>
<p>但被广泛使用的<a href="https://pub.dev/packages/flutter_bloc">flutter_bloc</a>，没有直接使用StreamBuilder，而是自己实现了类似StreamBuilder的<code>BlocBuilder</code>。在实现上，<code>flutter_bloc</code>也有类似<code>Redux</code>的状态转换的<code>纯方法</code>。</p>
<h3 id="redux"><a class="header" href="#redux">Redux</a></h3>
<h3 id="其它-6"><a class="header" href="#其它-6">其它</a></h3>
<ul>
<li><a href="https://www.reddit.com/r/FlutterDev/comments/brz0nu/scoped_model_vs_provider/">Scoped model vs Provider</a>: Scoped model与Provider的区别</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="主题"><a class="header" href="#主题">主题</a></h1>
<h3 id="material及cupertino风格"><a class="header" href="#material及cupertino风格">Material及Cupertino风格</a></h3>
<p>在Flutter中，存在两种风格，一种是<a href="https://material.io/">Material</a>风格，一种是Cupertino(iOS)风格。Cupertino主题默认色值等都是源自苹果官方资源：<a href="https://developer.apple.com/design/resources/">Apple Design Resources</a></p>
<p>两种风格差异较大，除了样式上不一样，还有交互上的不同。</p>
<p>在开发上，<code>Cupertino</code>风格的组件都有Cupertino的前缀。两种组件，有些可以相互使用，但有些组件，比如<code>AppBar</code>，只能在<code>MaterialApp</code>中使用的，否则就会出错。</p>
<h4 id="两种风格对比"><a class="header" href="#两种风格对比">两种风格对比</a></h4>
<table><thead><tr><th>Material</th><th>Cupertino</th></tr></thead><tbody>
<tr><td>组件较多</td><td>组件较少</td></tr>
<tr><td>开发体验好，可控制的参数多</td><td>开发体验一般</td></tr>
<tr><td>主题支持好：在MaterialApp中，Material Widget和类似Text这种不属于具体风格的Widget，在Material中支持也更好</td><td>主题支持一般：CupertinoApp中，仅Cupertino组件被主题所控制。</td></tr>
<tr><td>兼容性好：如MaterialApp跳转的子页面，appbar可以使用<code>CupertinoNavigationBar</code></td><td>兼容性差：如CupertinoApp跳转的子页面，appbar只能使用<code>CupertinoNavigationBar</code></td></tr>
</tbody></table>
<p>​	</p>
<p>Flutter中Material风格，与&quot;Material&quot;设计原则强烈相关。</p>
<p>比如，<a href="https://api.flutter.dev/flutter/material/ThemeData-class.html">ThemeData</a>中的<code>primaryColor</code>和<code>accentColor</code>，就是Material风格中的主要颜色和辅助颜色的使用。这儿在Material官网中对这两种颜色的使用说的非常清楚：<a href="https://material.io/design/color/#">The Color System</a></p>
<p>简单来说就是：主色及其变种色，用来定下基调，会在大量元素上使用。辅助色，一般用来表示强调，比如选中文本、进度条的进度、打开的开关等。</p>
<p>Material风格的简单介绍：<a href="https://zhuanlan.zhihu.com/p/34410688">Material Design的前世今生</a></p>
<h3 id="material--cupertino混用"><a class="header" href="#material--cupertino混用">Material &amp; Cupertino混用</a></h3>
<h5 id="在android上页面也能左滑返回则使用cupertinopageroute"><a class="header" href="#在android上页面也能左滑返回则使用cupertinopageroute">在Android上，页面也能左滑返回，则使用<code>CupertinoPageRoute</code></a></h5>
<pre><code class="language-dart"> Navigator.push(context, CupertinoPageRoute(  
   builder: (context)=&gt;PageB(),
 ));
</code></pre>
<p>参考：<a href="https://book.flutterchina.club/chapter9/route_transition.html">自定义路由切换动画</a></p>
<h3 id="开发设置"><a class="header" href="#开发设置">开发设置</a></h3>
<p>主题的简单使用参考：<a href="https://book.flutterchina.club/chapter7/theme.html">颜色和主题</a></p>
<p>如果需要根据系统是否黑暗模式来影响App的表现，则代码简单设为如下形式即可</p>
<pre><code class="language-dart">return MaterialApp(
    themeMode: ThemeMode.system,	// 表示使用系统设置
    darkTheme: ThemeData(
        brightness: Brightness.dark,
        primarySwatch: Colors.yellow	// 仅指定了主色盘（其它颜色基于这个来生成）
    ),
    theme: ThemeData(
        brightness: Brightness.light,
        primarySwatch: Colors.blue,
    ),
    home: MyHomePage(title: 'Flutter Theme Demo'),
);
</code></pre>
<p>如果程序只希望通过应用内来修改，则只保留theme参数即可，通过修改ThemeData的brightness参数来表示是否黑暗模式。</p>
<blockquote>
<p>主题的设置中，可以只设置主色盘，其它都采用默认的生成方式来生成。此时主色、辅助色等，会参考色盘来生成。（如果设置了具体的颜色，则会优先使用开发者设置的颜色）</p>
<p>但黑暗模式和普通模式主色、辅色等设置，并不是一样的。比如黑暗模式的主色会固定为黑色，但普通模式就是色盘的主色。</p>
<p>这儿可以直接查看ThemeData的构造函数来看具体的使用及差异。</p>
</blockquote>
<p>​	</p>
<p>Theme也可以仅对某个Widget进行设置的，这样的话，当前Widget的样式会优先采用当前主题风格</p>
<pre><code class="language-dart">// 这种情况下，Card组件是dark的，展示上Card就会展示为黑底白字
Theme(
    data: ThemeData(
        brightness: Brightness.dark,
        primarySwatch: Colors.teal
    ),
    child: Card(
        child: Text('Card Widget'),
    ),
)
</code></pre>
<p>如果要使用某个字体主题，可以直接从当前context中获取：</p>
<pre><code class="language-dart">var style = Theme.of(context).textTheme.headline1;
</code></pre>
<h3 id="资料-26"><a class="header" href="#资料-26">资料</a></h3>
<p>字体主题的几种效果：<a href="https://api.flutter.dev/flutter/material/TextTheme-class.html">TextTheme Class</a></p>
<p><a href="https://codelabs.flutter-io.cn/codelabs/flutter-cupertino-cn/index.html">使用 Flutter 构建 iOS 风格的应用</a></p>
<p><a href="https://flutterchina.club/widgets/cupertino/">Cupertino风格主组件</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="源码--原理"><a class="header" href="#源码--原理">源码 &amp; 原理</a></h1>
<ul>
<li><a href="https://www.jianshu.com/p/a9364f778bf8">Flutter源码分析系列（一）：runApp方法究竟做了什么</a></li>
<li><a href="https://blog.zhoulujue.com/Widget-Element-RenderObject/">从源码了解Flutter的渲染基础：Widget/Element/RenderObject</a></li>
<li><a href="https://www.cnblogs.com/lxlx1798/articles/11174987.html">Flutter核心原理之RenderObject和RenderBox</a></li>
<li><a href="http://gityuan.com/flutter/">Flutter 跨平台演进及架构开篇</a>: 包含了Flutter应用、引擎等启动分析的链接</li>
<li><a href="https://zhuanlan.zhihu.com/p/100677736">Dart VM 是如何运行你的代码的</a></li>
</ul>
<h3 id="引擎调试"><a class="header" href="#引擎调试">引擎调试</a></h3>
<p>参考：<a href="https://juejin.im/post/5e1f27726fb9a0300a450161">探究Flutter Engine调试</a>、<a href="https://github.com/flutter/flutter/wiki/Compiling-the-engine">Compiling the engine</a></p>
<ul>
<li><code>git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</code>安装depot工具包，并将其导出</li>
<li>新建engine目录，并在目录下新建<code>.gclient</code>文件，内容如下</li>
</ul>
<pre><code class="language-json">solutions = [
  {
    &quot;managed&quot;: False,
    &quot;name&quot;: &quot;src/flutter&quot;,
    &quot;url&quot;: &quot;https://github.com/flutter/engine.git&quot;,	# 这儿也可以换成自己fork的仓库
    &quot;custom_deps&quot;: {},
    &quot;deps_file&quot;: &quot;DEPS&quot;,
    &quot;safesync_url&quot;: &quot;&quot;,
  },
]
</code></pre>
<ul>
<li>在engine目录中执行：<code>gclient sync</code></li>
<li>查看flutter框架所依赖的引擎版本：<code>cat $FLUTTER_SDK_PATH/bin/internal/engine.version</code></li>
<li>将更新下来的engine代码(<code>src/flutter</code>目录)修改为flutter依赖的版本：<code>git reset --hard $engineVersion</code> (engineVersion替换为上一步engine.version的内容)</li>
<li>基于新的engine代码，重新更新依赖：<code>gclient sync --with_branch_heads --with_tags</code></li>
<li>进入到src目录，并且生成模拟器所用的工程：<code>./flutter/tools/gn --ios --simulator --unoptimized</code> (如果需要真机的，用：<code>./flutter/tools/gn --ios --unoptimized</code>)</li>
<li>编译代码，生成Flutter的framework: <code>ninja -C out/ios_debug_sim_unopt &amp;&amp; ninja -C out/host_debug_unopt</code>   (一定要编译host_debug_unopt，否则在尝试运行时会提示找不到dart工具等)</li>
<li>创建测试工程(或使用已有所需的工程): <code>flutter create my_project</code></li>
<li>在测试flutter工程中，执行如下命令：<code>flutter run -d 589BAE64-D728-41E4-90C2-F090F069DE67 --local-engine-src-path $path/engine/src --local-engine=ios_debug_sim_unopt</code> (其中path换成engine所在的绝对目录)。(目的是为了修改Flutter的工程配置，将flutter引擎指向我们所需的位置，主要是<code>./ios/Flutter/Generated.xcconfig</code>配置文件的修改)</li>
<li>打开example工程里的Xcode工程，并且把<code>out/ios_debug_sim_unopt</code>目录下的<code>products.xcodeproj</code>工程拖到示例主工程中。此时就可以直接在Flutter引擎代码里下断点进行调试了</li>
<li>如果修改了引擎的代码，需要看到效果的话，需要在src目录下，再执行该命令：<code>ninja -C out/ios_debug_sim_unopt</code></li>
</ul>
<h3 id="引擎源码"><a class="header" href="#引擎源码">引擎源码</a></h3>
<ul>
<li><a href="http://gityuan.com/img/flutter_boot/ClassEngine.jpg">引擎类图</a></li>
<li><a href="https://api.flutter.dev/objcdoc/index.html">Flutter Reference</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/137460524">Flutter引擎源码解读-Flutter是如何在iOS上运行起来的</a></li>
</ul>
<h4 id="todo"><a class="header" href="#todo">TODO</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
确认核心类有哪些</li>
<li><input disabled="" type="checkbox"/>
每个核心类的作用都是什么</li>
<li><input disabled="" type="checkbox"/>
Dart JIT相关逻辑，应该不属于Engine中的？</li>
<li><input disabled="" type="checkbox"/>
DartVM与引擎什么区别？</li>
<li><input disabled="" type="checkbox"/>
如何做的任务管理</li>
</ul>
<h5 id="shell-1"><a class="header" href="#shell-1">Shell</a></h5>
<p>引擎中最重要的类</p>
<h5 id="flutterengine"><a class="header" href="#flutterengine">FlutterEngine</a></h5>
<p>真正可以用来执行dart代码的类（通过<code>run</code>方法）</p>
<h5 id="flutterviewcontroller"><a class="header" href="#flutterviewcontroller">FlutterViewController</a></h5>
<p>Flutter的页面窗口，引擎源码执行入口类</p>
<p>是如何将Skia的内容显示在该VC上的？</p>
<h5 id="dartisolate"><a class="header" href="#dartisolate">DartIsolate</a></h5>
<p>一个<code>Isolate</code>就是一个Dart的执行上下文</p>
<h5 id="dartvm"><a class="header" href="#dartvm">DartVM</a></h5>
<h5 id="platformview--platformviewios"><a class="header" href="#platformview--platformviewios">PlatformView / PlatformViewIOS</a></h5>
<h5 id="taskrunners--taskrunner"><a class="header" href="#taskrunners--taskrunner">TaskRunners / TaskRunner</a></h5>
<p>任务管理类</p>
<h5 id="flutterdartproject"><a class="header" href="#flutterdartproject">FlutterDartProject</a></h5>
<p>Flutter/Dart的资源管理类</p>
<h5 id="window"><a class="header" href="#window">Window</a></h5>
<h5 id="runtimecontroller"><a class="header" href="#runtimecontroller">RuntimeController</a></h5>
<h3 id="布局--绘制"><a class="header" href="#布局--绘制">布局 &amp; 绘制</a></h3>
<h4 id="builderowner"><a class="header" href="#builderowner">BuilderOwner</a></h4>
<p>Widget的管理类，全局的BuilderOwner被WidgetsBinding所持有。</p>
<p>如果要做离屏渲染的话，可以新创建一个BuildOwner</p>
<h4 id="pipelineowner"><a class="header" href="#pipelineowner">PipelineOwner</a></h4>
<p>这个是渲染流水线的管理类，它的根结点是RenderView（RenderView是RenderObject树的根结点）</p>
<h4 id="abstractnode"><a class="header" href="#abstractnode">AbstractNode</a></h4>
<p>树对象的顶点，仅定义了树操作的一些接口。比如设置子节点深度、设置子对象等，以及设置结点所依附的对象</p>
<p>其中对象的深度与一般的理解有些差异，只保证子对象深度比父对象深度高，并不保证兄弟对象深度的关系。具体解释参考：<a href="https://api.flutter.dev/flutter/foundation/AbstractNode-class.html">AbstractNode</a></p>
<h4 id="renderobject"><a class="header" href="#renderobject">RenderObject</a></h4>
<p>渲染库的核心。RenderObject中两个重要成员，parent、parentData</p>
<p>parent就是指向父的RenderObject</p>
<p>而parentData是保留给父类进行设置的数据，并且自己知道该数据类型，在渲染时，父对象会设置该值，自己会读取该值。比如父类知道我的偏移数据，设置进来。我从这里面读取后自己做相应处理</p>
<p>对象中也定义了布局等操作的抽象处理。</p>
<h4 id="renderbox"><a class="header" href="#renderbox">RenderBox</a></h4>
<p>继承自RenderObject，使用笛卡尔坐标系。</p>
<p>平常开发中，打交道较多的对象。要实现一些新组件时，往往要从RenderBox继承。</p>
<p>在继承RenderBox时，需要注意<code>markNeedsLayout</code>要少调用，布局重算的成本会较高，仅必须时才调用。</p>
<h4 id="boxconstraints"><a class="header" href="#boxconstraints">BoxConstraints</a></h4>
<p>重要的约束类，给RenderBox使用，提供了一些约束处理的工具方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试-1"><a class="header" href="#测试-1">测试</a></h1>
<h3 id="资料-27"><a class="header" href="#资料-27">资料</a></h3>
<ul>
<li>简单介绍：<a href="https://flutterchina.club/testing/">测试Flutter App</a></li>
<li><a href="https://github.com/flutter/flutter/tree/master/packages/flutter/test">官方测试代码</a>: 有很详细的测试代码可以参考</li>
<li><a href="https://medium.com/@lihsinplayer/flutter-widget%E6%B8%AC%E8%A9%A6%E8%A7%A3%E6%9E%90-6219ff85c1ef">Flutter Widget測試解析</a>: 参考官方测试用例代码，整理的常用测试方法</li>
<li><a href="https://www.youtube.com/watch?v=q3hqKgwZbvg">Flutter 的性能测试和理论</a></li>
</ul>
<h3 id="使用测试工具"><a class="header" href="#使用测试工具">使用测试工具</a></h3>
<ul>
<li>
<p>安装<code>genhtml</code>工具：<code>brew install lcov</code></p>
</li>
<li>
<p>在工程目录执行：<code>flutter test --coverage</code>，此时会在coverage目录下生成lcov.info文件</p>
</li>
<li>
<p>执行：<code>genhtml coverage/lcov.info -o coverage/html</code>，生成相应可视化的html文件</p>
</li>
</ul>
<blockquote>
<p>安装<code>genhtml</code>时，可能出现没有权限的错误:</p>
<p>按提示，可能要执行<code>sudo chown -R $(whoami) /usr/local/share/man/man7</code></p>
</blockquote>
<h5 id="mock"><a class="header" href="#mock">Mock</a></h5>
<p><a href="https://pub.dev/packages/mockito">mockito</a>：可以在预编译阶段生成Mock对象</p>
<h3 id="测试实践"><a class="header" href="#测试实践">测试实践</a></h3>
<ul>
<li>Fake仓库的使用
<ul>
<li><a href="https://pub.dev/packages/fake_async">fake_async</a>：可以人为控制时间流逝</li>
<li><a href="https://pub.dev/packages/faker">faker</a>：可以生成一些假数据</li>
</ul>
</li>
<li>可以通过<code>@Timeout(Duration(seconds: 45))</code>来更改测试默认的超时时间</li>
<li>测试组或单个的测试用例也可以设置自己的超时时间</li>
<li>Dart是支持对测试做一些配置的，配置内容放在根目录的<code>dart_test.yaml</code>中，参考：<a href="https://github.com/dart-lang/test/blob/master/pkgs/test/doc/configuration.md">Test configuration</a>
<ul>
<li>支持配置<code>tags</code>，来将测试用例进行打标签，比如仅测试指定标签的测试，或者不测指定标签的测试用例</li>
</ul>
</li>
</ul>
<h3 id="测试代码片断"><a class="header" href="#测试代码片断">测试代码片断</a></h3>
<h5 id="异步测试-1"><a class="header" href="#异步测试-1">异步测试</a></h5>
<pre><code class="language-dart">test('Future.value() returns the value', () async {
  var value = await Future.value(10);
  expect(value, equals(10));
});

test('Future.value() returns the value', () {
  expect(Future.value(10), completion(equals(10)));
});

test('Future.error() throws the error', () {
  expect(Future.error('oh no'), throwsA(equals('oh no')));
  expect(Future.error(StateError('bad state')), throwsStateError);
});

test('Stream.fromIterable() emits the values in the iterable', () {
  var stream = Stream.fromIterable([1, 2, 3]);

  stream.listen(expectAsync1((number) {
    expect(number, inInclusiveRange(1, 3));
  }, count: 3));
});
</code></pre>
<h5 id="stream测试"><a class="header" href="#stream测试">Stream测试</a></h5>
<pre><code class="language-dart">test('process emits status messages', () {
    // Dummy data to mimic something that might be emitted by a process.
    var stdoutLines = Stream.fromIterable([
        'Ready.',
        'Loading took 150ms.',
        'Succeeded!'
    ]);

    expect(stdoutLines, emitsInOrder([
        // Values match individual events.
        'Ready.',

        // Matchers also run against individual events.
        startsWith('Loading took'),

        // Stream matchers can be nested. This asserts that one of two events are
        // emitted after the &quot;Loading took&quot; line.
        emitsAnyOf(['Succeeded!', 'Failed!']),

        // By default, more events are allowed after the matcher finishes
        // matching. This asserts instead that the stream emits a done event and
        // nothing else.
        emitsDone
    ]));
});
</code></pre>
<h5 id="基础widget测试"><a class="header" href="#基础widget测试">基础Widget测试</a></h5>
<pre><code class="language-dart">// 点击按钮
tester.tap(find.text('Go'));

// 获取某类型的第一个组件。（先添加的组件会先被获取到）
tester.firstWidget(find.byType(Text));

// 获取某类型的第二个组件
tester.widgetList(find.byType(Text)).elementAt(1);

// 获取组件位置 (通过组件的位置及大小，验证组件布局正常)
Offset textFieldTopLeft = tester.getTopLeft(find.byType(TextField));

// 获取组件大小
Size size = tester.getSize(find.byType(TextField));
</code></pre>
<h5 id="在ui测试中使用buildcontext"><a class="header" href="#在ui测试中使用buildcontext">在UI测试中使用BuildContext</a></h5>
<pre><code class="language-dart">// 方式1
await tester.pumpWidget(MaterialApp(
    home: Material(
        child: Center(
            child: Builder(builder: (BuildContext context) {
                return RaisedButton(
                    onPressed: () {
                        // use context
                    },
                    child: const Text('Go'),
                );
            }),
        ),
    ),
));

await tester.tap(find.text('Go'));
await tester.pump();
</code></pre>
<pre><code class="language-dart">// 方式2
await tester.pumpWidget(
    const MaterialApp(
        home: Material(
            child: Center(
                child: RaisedButton(
                    onPressed: null,
                    child: Text('Go'),
                ),
            ),
        ),
    ),
);

// Element就是BuildContext的实现。通过获取按钮的Element，就拿到了context
final BuildContext context = tester.element(find.text('Go'));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="性能相关-1"><a class="header" href="#性能相关-1">性能相关</a></h1>
<h3 id="性能工具devtools"><a class="header" href="#性能工具devtools">性能工具（DevTools）</a></h3>
<ul>
<li>可以逐帧分析UI性能</li>
</ul>
<h3 id="动画帧率提升"><a class="header" href="#动画帧率提升">动画帧率提升</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flutter-web"><a class="header" href="#flutter-web">Flutter Web</a></h1>
<h3 id="资料-28"><a class="header" href="#资料-28">资料</a></h3>
<ul>
<li><a href="https://www.zhihu.com/question/323439136/answer/850516697">如何评价 Flutter for Web?</a></li>
<li><a href="https://mp.weixin.qq.com/s/NGqF2OTvsV1A2KLiMXE2PQ">Flutter web 最新进展: 发掘更多可能！</a></li>
</ul>
<h3 id="flutter-web使用"><a class="header" href="#flutter-web使用">Flutter Web使用</a></h3>
<pre><code class="language-sh"># 1. Flutter 1.12版本，需要先切为beta版本才可以使用web功能
# 如果无法使用，请注意开代理
flutter channel beta
flutter upgrade
flutter config --enable-web

# 2. 然后重启vscode

# 3. 查看device是否出现了chrome
flutter devices

# 4. Cmd + Shift + P，即可创建Flutter工程了

# 5. 如果是之前创建的工程，现在执行如下命令即可使工程支持web
flutter create .

# 6. 运行即可
flutter run -d chrome

# 7. 生成发布版本
flutter build web	# 在工程的build/web目录下，就会生成可以发布的资源

</code></pre>
<p>如果遇到错误 <code>websocket not upgraded error</code>，采用这篇文章的解决方案：
<a href="https://github.com/flutter/flutter/issues/11444">websocket not upgraded error</a>
即通过设置<code>NO_PROXY</code>环境变量</p>
<pre><code class="language-sh">export NO_PROXY=127.0.0.1,localhost
</code></pre>
<p>发布资源，是html + main.dart.js等，其中main.dart.js较大，默认demo就有1.1M</p>
<h3 id="flutter-for-web实现原理"><a class="header" href="#flutter-for-web实现原理">Flutter For Web实现原理</a></h3>
<p><a href="https://zhuanlan.zhihu.com/p/71042536">Flutter for Web 详细预研</a></p>
<p>Dart转为JS，界面上部分转换成标准的html标签，部分转换成通过Canvas绘制的自定义标签，最终构成一个dom树。</p>
<h3 id="参考"><a class="header" href="#参考">参考</a></h3>
<p><a href="https://flutter.cn/docs/get-started/web">Flutter Web开启方式</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flutter-desktop"><a class="header" href="#flutter-desktop">Flutter Desktop</a></h1>
<h3 id="flutter-desktop开发方案"><a class="header" href="#flutter-desktop开发方案">Flutter Desktop开发方案</a></h3>
<h4 id="官方方案"><a class="header" href="#官方方案">官方方案</a></h4>
<p>https://flutter.dev/desktop</p>
<h4 id="go-flutter方案"><a class="header" href="#go-flutter方案">go-flutter方案</a></h4>
<p>https://github.com/go-flutter-desktop/go-flutter</p>
<p>两种方案对比: 
<a href="https://juejin.im/post/5cfd1ad86fb9a07ebf4b625b">Flutter 开发桌面应用——迁移已有App应用到桌面版</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="后台"><a class="header" href="#后台">后台</a></h1>
<h3 id="相关链接"><a class="header" href="#相关链接">相关链接</a></h3>
<p><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md">系统设计入门</a></p>
<h3 id="基础概念-5"><a class="header" href="#基础概念-5">基础概念</a></h3>
<h4 id="rpc"><a class="header" href="#rpc">RPC</a></h4>
<p><a href="https://www.zhihu.com/question/25536695">谁能用通俗的语言解释一下什么是 RPC 框架？</a></p>
<h3 id="最简单的httpsvr"><a class="header" href="#最简单的httpsvr">最简单的HttpSvr</a></h3>
<h4 id="js-1"><a class="header" href="#js-1">JS</a></h4>
<pre><code class="language-js">let express = require(&quot;express&quot;);
let app = express();
 
 // 加载指定目录作为静态页面目录
app.use(express.static(&quot;../develop/_book&quot;));
 
app.listen(8080, ()=&gt;{
    console.log(&quot;listen 8080&quot;);
})
</code></pre>
<h4 id="go"><a class="header" href="#go">GO</a></h4>
<pre><code class="language-go">package main

import (
	&quot;log&quot;
	&quot;net/http&quot;
)

func main() {
    // 使用_book作为静态页面目录
	h := http.FileServer(http.Dir(&quot;./_book&quot;))
	err := http.ListenAndServe(&quot;:9090&quot;, h)
	if err != nil {
		log.Fatal(&quot;ListenAndServe: &quot;, err)
	}
}
</code></pre>
<h3 id="其它资料-1"><a class="header" href="#其它资料-1">其它资料</a></h3>
<p><a href="https://blog.csdn.net/SL_ideas/article/details/73648378">WebSocket 和socket、HTTP的区别和联系</a></p>
<p>基于go实现的websocket库：<a href="https://github.com/gorilla/websocket">gorilla/websocket</a></p>
<p>基于websocket库实现的非常简单的聊天demo: <a href="https://github.com/scotch-io/go-realtime-chat">go-realtime-chat</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/53260098">10分钟看懂Docker和K8S</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<h3 id="资料-29"><a class="header" href="#资料-29">资料</a></h3>
<p>Linux命令大全：<a href="https://github.com/jaywcjlove/linux-command">linux-command</a></p>
<h3 id="系统命令"><a class="header" href="#系统命令">系统命令</a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>ps auxf</code></td><td>查看所有进程</td></tr>
<tr><td><code>disown</code></td><td>执行一个命令后，再执行disown，可以来保持后台一直执行</td></tr>
<tr><td><code>crontab</code></td><td>定时任务，参考: <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html">crontab 定时任务</a></td></tr>
<tr><td><code>kill -9 pid</code></td><td>杀死指定id的进程</td></tr>
</tbody></table>
<h3 id="普通命令"><a class="header" href="#普通命令">普通命令</a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>ls -lR \| grep '.svg' \|wc -l</code></td><td>统计当前目录下，指定类型文件的个数</td></tr>
<tr><td><code>ln dir/src.txt other/dest.txt</code></td><td>创建硬链接 (第一个参数是源，第二个参数是目的)</td></tr>
<tr><td><code>which cmd</code></td><td>查看cmd命令所在的位置</td></tr>
</tbody></table>
<h3 id="工具"><a class="header" href="#工具">工具</a></h3>
<table><thead><tr><th>名称</th><th>示例</th><th>作用</th></tr></thead><tbody>
<tr><td><code>serve</code></td><td>serve -l 80 -s build</td><td>在80端口上启动一个简单的httpsvr，加载build目录</td></tr>
<tr><td><code>scp</code></td><td>scp /home/a.zip root@129.20.0.2:/work/a.zip</td><td>拷贝本地相应目录的a.zip文件，至远程服务器的相应目录下</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go语言"><a class="header" href="#go语言">GO语言</a></h1>
<p>Go一共只有25个关键字，继承了C的简单、暴力的编程哲学:
<a href="https://blog.csdn.net/K346K346/article/details/90265765">Golang 25 个保留关键字</a></p>
<p>go中的数组是不可变的，切片是可变的。go的切片是更类似于Swift中的数组的集合。具体可参考：<a href="https://juejin.im/post/5c89bdd0f265da2de165e3a1">详解go语言的array和slice</a></p>
<pre><code class="language-go">// 数组
var arr [3]int

// 切片
var arr = []string{1, 2, 3}
</code></pre>
<p>go中有多值返回，也有多值赋值，看起来像元组，但并没有元组类型</p>
<pre><code class="language-go">// 多值赋值
var a, b = true, &quot;sss&quot;  // 分别为 bool, string 类型

// 多值返回
func myfunc() (int, int) {
    return 3, 7
}
</code></pre>
<p>go中也有可变参数，类似swift</p>
<pre><code class="language-go">// go
func sum(nums ...int) {
}
</code></pre>
<p>go中，函数也是一等公民</p>
<p>Go的函数名首字母大小写，来表示函数是否导出（大写为导出，小写为私有）</p>
<h3 id="资料-30"><a class="header" href="#资料-30">资料</a></h3>
<p><a href="https://github.com/gobyexample-cn/gobyexample">Go By Example</a>
<strong>通过例子学习Go基础，非常好的示例！</strong></p>
<p><a href="https://www.runoob.com/go/go-tutorial.html">Go基础教程</a></p>
<p><a href="https://chai2010.cn/advanced-go-programming-book/">Go语言高级编程</a></p>
<p><a href="https://github.com/Alikhll/golang-developer-roadmap">Go RoadMap</a></p>
<p><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md">Go Web编程</a> : 包含了基本的安装等信息</p>
<hr />
<h3 id="a-hrefhttpsgithubcomastaxiebuild-web-application-with-golangblobmasterzh013mdgo命令列表a"><a class="header" href="#a-hrefhttpsgithubcomastaxiebuild-web-application-with-golangblobmasterzh013mdgo命令列表a"><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.3.md">Go命令列表</a></a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>go get</code></td><td>更新指定的代码包及其依赖包，会安装在<code>GOPATH</code>环境变量指定的目录下面</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs"><a class="header" href="#nodejs">Node.js</a></h1>
<h3 id="资料-31"><a class="header" href="#资料-31">资料</a></h3>
<p><a href="https://segmentfault.com/a/1190000004139342">express中cookie的使用和cookie-parser的解读</a></p>
<h3 id="代码-1"><a class="header" href="#代码-1">代码</a></h3>
<p>测试cookie代码</p>
<pre><code class="language-javascript">// 代码：https://repl.it/@matthewyan1/OilyDraftyHashfunction#index.js
const express = require('express')
const app = express()
var cookieParser = require('cookie-parser');

const port = 8888

app.get('/', (req, res) =&gt; {
  // 当存在maxAge或expire字段时，就会存储为permanent类型的cookie
  // 当这两个字段都不存在时，就会是session类型的cookie，即关闭浏览器之后，cookie就会被清除
  let options = {
      domain: 'oilydraftyhashfunction.matthewyan1.repl.co',
      maxAge: 30 * 86400000, // 1 months
      httpOnly: true, // The cookie only accessible by the web server
      // signed: true // Indicates if the cookie should be signed
  }

  // 清除cookie
  res.clearCookie('myTestCookie', {domain: 'matthewyan1.repl.co'})

  // Set cookie
  res.cookie('myTestCookie', '222', options)

  res.redirect('/redirect_path');
})

app.use(cookieParser())

app.get('/redirect_path', (req, res, next) =&gt; {
  console.log(`cookies: ${JSON.stringify(req.cookies)}`)
  res.send('Redirect Hello World!!!')
})

app.listen(port, () =&gt; {
  console.log(`Example app listening at port ${port}`)
})
</code></pre>
<p>express配置https</p>
<pre><code class="language-javascript">// https://blog.csdn.net/CHENYUFENG1991/article/details/60340006
var express = require('express'); // 项目服务端使用express框架
var app = express();
var path = require('path');
var fs = require('fs');

// 使用nodejs自带的http、https模块
var http = require('http');
var https = require('https');

// 根据项目的路径导入生成的证书文件
var privateKey  = fs.readFileSync(path.join(__dirname, './cert/https.key'), 'utf8');  // 私钥
var certificate = fs.readFileSync(path.join(__dirname, './cert/https.crt'), 'utf8');
var credentials = {key: privateKey, cert: certificate};

var httpServer = http.createServer(app);
var httpsServer = https.createServer(credentials, app);

var PORT = 8000;
var SSLPORT = 8001;

// 创建http服务器
httpServer.listen(PORT, function() {
    console.log('HTTP Server is running on: %s', PORT);
});

// 创建https服务器
httpsServer.listen(SSLPORT, function() {
    console.log('HTTPS Server is running on: %s', SSLPORT);
});

// 可以根据请求判断是http还是https
app.get('/', function (req, res) {
    if (req.protocol === 'https') {
        res.status(200).send('This is https visit!');
    } else {
        res.status(200).send('This is http visit!');
    }
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker入门</a></p>
<p><a href="https://github.com/yeasy/docker_practice">Docker从入门到实践</a></p>
<p><a href="https://www.cnblogs.com/zhangxingeng/p/11236968.html">Docker1 架构原理及简单使用</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="k8s"><a class="header" href="#k8s">K8S</a></h1>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4Nzc4MjI4MQ==&amp;mid=2652403349&amp;idx=1&amp;sn=0e2ea122519125f466076393230496bf&amp;chksm=8bd8f073bcaf79652a045131cf106ab37112be95e485c9f94c633da5e759263c7ab4473218cd&amp;token=1554267214&amp;lang=zh_CN#rd">图解 Kubernetes</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-语言"><a class="header" href="#6-语言">6. 语言</a></h1>
<h3 id="抽象"><a class="header" href="#抽象">抽象</a></h3>
<p>语言的抽象，往往意味着一定的性能损耗，但类似Rust语言，将抽象带来的损耗尽可能往编译期移，所以提出了<code>zero-cost abstraction</code>。</p>
<p><a href="https://www.zhihu.com/question/38845620/answer/78396508">编程语言中有哪些抽象手段，这些抽象的cost怎么衡量？ - KE meng的回答 - 知乎</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/20482423">函数式非凡的抽象能力</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-1"><a class="header" href="#swift-1">Swift</a></h1>
<h3 id="特性-2"><a class="header" href="#特性-2">特性</a></h3>
<h4 id="_functionbuilder-1"><a class="header" href="#_functionbuilder-1">@_functionBuilder</a></h4>
<blockquote>
<p>Swift 5.1</p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/148112087">Swift Function Builder @_functionBuilder</a></p>
<p><a href="https://juejin.cn/post/6844903871786008590">SwiftUI 和 Swift 5.1 新特性(4) 苹果先斩后奏？Function Builder 造就 SwiftUI 的 DSL</a></p>
<p>一些利用@_functionBuilder的一些有趣实现：<a href="https://github.com/carson-katri/awesome-function-builders">awesome-function-builders</a></p>
<p>@_functionBuilder就是一个语法糖，可以为builder提供简洁的语法，你可以尝试用它简化任何builder类型的操作。也可以这样来用：</p>
<pre><code class="language-swift">@_functionBuilder struct AddBuilder {
    static func buildBlock&lt;T: Numeric&gt;(_ l: T, _ r: T) -&gt; T {
        return l + r
    }
}

func myadd(@AddBuilder _ builder: () -&gt; Int) -&gt; Int {
    return builder()
}

// 1和2相加
let r = myadd {	// r的结果是3
    1
    2
}
</code></pre>
<h4 id="propertywrapper-1"><a class="header" href="#propertywrapper-1">@propertyWrapper</a></h4>
<blockquote>
<p>Swift 5.1</p>
</blockquote>
<p><a href="https://medium.com/jeremy-xue-s-blog/swift-%E8%A3%BD%E4%BD%9C%E4%B8%80%E5%80%8B-userdefault-%E5%B0%88%E5%B1%AC%E7%9A%84%E5%B1%AC%E6%80%A7%E5%8C%85%E8%A3%9D%E5%99%A8%E5%90%A7-6457b2f0d886">Swift — 製作一個 UserDefault 專屬的屬性包裝器吧！</a></p>
<p>简单理解，@propertyWrapper就是用来hook属性，可以加一些自己的操作，让属性变为自己预期中的那样</p>
<pre><code class="language-swift">@propertyWrapper struct Beatiful {
    private var value: String = &quot;&quot;
    // 计算属性
    var wrappedValue: String {
        get { value }
        set { value = newValue.trimmingCharacters(in: .whitespacesAndNewlines) }
    }

    init(wrappedValue initialValue: String) {
        self.wrappedValue = initialValue
    }
}

struct MyData {
    // 让data变得更漂亮，自动将两边多余的空格去掉
    @Beatiful var data: String
}

var d = MyData(data: &quot;  Hello World  &quot;)
d.data  // 变为&quot;Hello World&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dart-1"><a class="header" href="#dart-1">Dart</a></h1>
<p>在安装了Flutter的情况下，要直接使用dart，只需要将dart sdk配置到环境变量中即可。</p>
<p>dart sdk的位置在<code>$FlutterPATH/cache/dart-sdk/bin</code>，具体使用参考：<a href="https://blog.csdn.net/qq_26287435/article/details/87917289">Dart配置环境变量</a></p>
<h3 id="dart常用命令-1"><a class="header" href="#dart常用命令-1">Dart常用命令</a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>dart main.dart</code></td><td>可以直接执行main.dart</td></tr>
<tr><td><code>dart create myproj</code></td><td>创建dart工程</td></tr>
<tr><td><code>dart create --template=package-simple mypackage</code></td><td>创建dart的package工程 （还有其它类型的template，通过<code>dart create --help</code>查看）</td></tr>
<tr><td><code>dart pub add/remove ***</code></td><td>添加/移除包依赖</td></tr>
<tr><td><code>dart pub publish</code></td><td>可以发布包至<code>pub.dev</code>上</td></tr>
<tr><td><code>pub global activate somepackage</code></td><td>安装指定脚本并激活，然后可以使用该package bin目录下的脚本 (如安装并使用fvm)</td></tr>
</tbody></table>
<h3 id="特性列表-1"><a class="header" href="#特性列表-1">特性列表</a></h3>
<ul>
<li>Dart是单线程语言 (Dart中的<code>Isolate</code>类似多线程，但不完全一样)</li>
<li>Dart函数也是一等公民</li>
<li>Dart支持内部方法 (函数里再定义函数)</li>
<li>Dart不支持内部类</li>
<li>支持对已有的类进行扩展 (如：<code>extension MyExt on num</code>，就表示扩展num类。Dart 2.7之后的能力)</li>
<li>函数对象也可以被扩展（如：可以将两个参数的函数扩展一个curry的接口）</li>
<li>支持运算符重载</li>
<li>支持泛型</li>
<li>支持协程</li>
<li>支持ffi，可调用c/c++接口：<a href="https://flutter.dev/docs/development/platform-integration/c-interop#step-2-add-cc-sources">Binding to native code using dart:ffi</a></li>
<li>支持反射 (但<a href="https://github.com/flutter/flutter/issues/1150">Flutter中不能使用</a>)：<a href="https://api.dart.dev/stable/2.8.1/dart-mirrors/dart-mirrors-library.html">dart:mirrors</a></li>
<li>支持空安全 (Dart 2.12版本之后)</li>
</ul>
<h3 id="常用语法-1"><a class="header" href="#常用语法-1">常用语法</a></h3>
<h4 id="类型-1"><a class="header" href="#类型-1">类型</a></h4>
<pre><code class="language-dart">// 类似Swift，所有的类型都是类对象，包括int
int i = 10;
i.toString();

// num类型是比较特殊的，即可以表示int，也可以表示double，并且可以在运行时修改
// 参考：https://juejin.im/post/5b9fc2ce5188255c2f420e1f
// 如下的代码是可以正常运行的
num number = 1;
number = 1.01;
print(number);	// 输出1.01

// dart中也支持泛型，能力和使用上类似swift
// 比如都支持泛型类型的限定
// 参考：https://dart.cn/guides/language/language-tour#generics
var names = List&lt;String&gt;();
names.addAll(['小芸', '小芳', '小民']);

// list的简化初始化方法：
final lst = &lt;int&gt;[];

// map的简化初始化方法：
final m = {};

///////////////////////////////////
// final、const等
final a = 10;	// final表示只能赋值一次。

final lst = &lt;int&gt;[];
lst.add(10);	// 是正常的，可以添加元素

const lst = &lt;int&gt;[];	// const更加类似Swift中的let，但也不完全一样
lst.add(10);	// 会出错，是个运行时错误，而非编译时错误
</code></pre>
<h4 id="list-1"><a class="header" href="#list-1">List</a></h4>
<pre><code class="language-dart">// 扩展操作符，向一个list中插入另外一个list
var list = [1, 2, 3];
var list2 = [0, ...list];

// null-aware 扩展操作符，可以防止被添加的list为空
var list;
var list2 = [0, ...?list];

// list中有map、where(类似filter)
// 包括Map、Set类型，也都支持map、where这样的高阶操作
// 这些高阶函数都是lazy的，也即在真正访问数据前，并不会真的过滤或转换数据
var list = [1, 2, 3];
list.where((i) =&gt; i % 2 == 0).toList();
</code></pre>
<blockquote>
<p>还存在<a href="https://api.dart.dev/stable/2.8.3/dart-collection/LinkedList-class.html">LinkedList</a>、<a href="https://api.dart.dev/stable/2.8.3/dart-collection/ListQueue-class.html">ListQueue</a>等集合。ListQueue是一种先进先出的数据结构</p>
</blockquote>
<h4 id="map-1"><a class="header" href="#map-1">Map</a></h4>
<pre><code class="language-dart">// 创建空map
var gifts = Map();

// 创建空map后，可以往其中添加不同类型的key及value
var m = Map();
m[2] = 'helium';
m['aaa'] = 'neon';
m['ccc'] = 7;

// 但如果创建map时限定了类型，则后面无法再添加不同类型的key或value
var m = {'first': 'partridge'};
m[2] = 'helium';	// Error!
</code></pre>
<blockquote>
<p>还有其它类型的Map，如：<a href="https://api.dart.dev/stable/2.8.3/dart-collection/LinkedHashMap-class.html">LinkedHashMap</a>，是有序的map。可以参考：<a href="https://juejin.im/post/5c7aaa7e6fb9a049aa6fccba">简单谈谈dart中几种Map的不同</a></p>
</blockquote>
<h4 id="set-1"><a class="header" href="#set-1">Set</a></h4>
<pre><code class="language-dart">// 创建空set
var names = &lt;String&gt;{};
names.add('green');	// 添加元素

// 创建非空set
var names = {'lucy', 'jim'};
</code></pre>
<blockquote>
<p>在<a href="https://api.dart.dev/stable/2.8.3/dart-collection/dart-collection-library.html">dart:collection library</a>中有更详细的集合列表</p>
</blockquote>
<h4 id="function-1"><a class="header" href="#function-1">Function</a></h4>
<pre><code class="language-dart">// 函数也是对象，也支持作为参数传递给另外的函数。
// 也即函数也是一等公民，就支持了函数式编程，以及高阶方法
// bool Function(int)即是定义了函数类型
// 参数类型，也可以简写为 Function
void myfun(bool Function(int) f) {
  // do sth
}

/////////////////////
// 参数相关
// 普通函数参数使用
void _funParam1(int p1, int p2) {
  print(p1 + p2);
}

// 命名参数，用{}来包括起来，调用时就要指定参数名
void _funParam2({int p1, int p2}) {
  print(p1 + p2);
}

// 使用命名参数时，参数也就是可选的，有些参数可以设置上默认值
// 如果可选参数不设置默认值时，则要在函数体内部判断参数是否为null，否则会执行异常
void _funParam3({int p1, int p2 = 2}) {
  print(p1 + p2);
}

// @required可以表示参数是必须的，如果调用时不填的话，编译期就可以检测出来
// 要使用@required，需要引入meta包：
// import 'package:meta/meta.dart';
void _funParam4({@required int p1, int p2 = 2}) {
  print(p1 + p2);
}

// {}可以只括某个参数，表示该参数是命名可选参数
void _funParam5(int p1, {int p2}) {
  print(p1 + p2);
}

// []与{}的区别是，它只表示可选，并不存在命名。称为可选位置参数。
void _funParam6(int p1, [int p2]) {
  if (p2 == null) {
    print(p1);
  } else {
    print(p1 + p2);
  }
}

void _paramTest() {
  _funParam1(1, 2);
  _funParam2(p1: 1, p2: 2); // 使用上要指定参数名
  _funParam2(p2: 2, p1: 1); // 使用命名参数时，参数的位置可以随意调整
  _funParam3(p1: 1);
  // _funParam4(); // 限定了required的参数，如果不填写，编辑器就可以提示出来不对
  _funParam4(p1: 1);
  _funParam5(1, p2: 2);
  _funParam6(1, 2); // _funParam6与_funParam5的调用区别
  _funParam6(1);
}
</code></pre>
<h4 id="运算符-1"><a class="header" href="#运算符-1">运算符</a></h4>
<pre><code class="language-dart">// as、is、is! 运算符是在运行时判断对象类型的运算符。
(emp as Person).firstName = 'Bob';	// 将obj转为Person后再赋值

// 类型检查 (is!是判断类型不为指定类型时，为true)
if (emp is Person) {
  emp.firstName = 'Bob';
}

// 赋值运算符，且仅当 b 为 null 时才赋值
b ??= value;

//////////////////////////////
// dart支持运算符重载
// 更类似C++的运算符重载，表达能力上要弱于Swift的自定义运算符
class Man {
  int a; 
  int b;
  Man(this.a, this.b);

  Man operator +(Man v) {
    return new Man(a + v.a, b + v.b);
  }
}

var man1 = new Man(1, 2);
var man2 = new Man(3, 4);

var r = man1 + man2;
print('${r.a}, ${r.b}');	// 输出：4, 6
</code></pre>
<h4 id="异常-1"><a class="header" href="#异常-1">异常</a></h4>
<pre><code class="language-dart">// dart可以将任何非null的对象作为异常拋出，而不局限于Exception或Error类型
throw FormatException('Expected at least 1 section');
throw 'Out of llamas!';

// rethrow可以将接收到的异常重新拋出去
void misbehave() {
  try {
    dynamic foo = true;
    print(foo++); // 运行时错误
  } catch (e) {
    print('misbehave() partially handled ${e.runtimeType}.');
    rethrow; // 将异常重新拋到外面
  }
}
</code></pre>
<h4 id="class-1"><a class="header" href="#class-1">Class</a></h4>
<pre><code class="language-dart">// 普通的成员变量直接用.来访问即可，但为了防止实例为空，可以用：?. 来访问属性
Point p;		// 需要引入math库：import 'dart:math';
print(p?.x);	// 输出null

// Dart2中，创建对象时可以省略new关键字
Point p = Point(1, 2);

////////////////////////////////
// 构造函数
class MyPoint {
  num x, y;

  // 如果不声明构造函数的话，系统会默认创建一个无参数的构造函数，并且会调用父类的无参构造函数

  // 默认构造函数的形式
  // 这个语法，可以简化为：
  // MyPoint(this.x, this.y);
  // 这种也要“生成式构造函数”
  MyPoint(num x, num y) {
    this.x = x;
    this.y = y;
  }
  
  // Dart也支持初始化参数列表
  MyPoint() : x = 0, y = 0;

  // 命名式构造函数，可以用来表达更明确的意图
  // https://dart.cn/guides/language/language-tour#named-constructors
  // 构造函数不能被子类继承，所以类似命名式构造函数，
  MyPoint.origin() {
    x = 0;
    y = 0;
  }

  // 初始化列表的使用，在构造函数体执行之前初始化实例变量
  MyPoint.fromJson(Map&lt;String, num&gt; json)
      : x = json['x'],
        y = json['y'] {
    print('In Point.fromJson(): ($x, $y)');
  }

  // 重定向构造函数。委托实现给主构造函数。
  MyPoint.alongXAxis(num x) : this(x, 0);

  // 除此之外，还有工厂构造方法等
  // 参考：https://dart.cn/guides/language/language-tour#constructors
}
</code></pre>
<h4 id="隐式接口-1"><a class="header" href="#隐式接口-1">隐式接口</a></h4>
<pre><code class="language-dart">class AClass {
  // 非构造函数的方法，以及所有实例成员，都有生成默认的接口
  void sayHello() {
    print(&quot;Hello&quot;);
  }

  void sayWorld() {
    print(&quot;World&quot;);
  }
}

// 使用implements关键词，就表示需要实现AClass的接口
// implements后可以指定多个类
class BClass implements AClass {
  @override
  void sayHello() {
    print(&quot;BClass: Hello&quot;);
  }

  @override
  void sayWorld() {
    print(&quot;BClass: World&quot;);
  }
}

void runCode() {
  BClass cls = BClass();
  cls.sayHello();	// BClass: Hello
  cls.sayWorld();	// BClass: World
}
</code></pre>
<h4 id="mixin-1"><a class="header" href="#mixin-1">Mixin</a></h4>
<pre><code class="language-dart">// Dart中的Mixin，类似Swift中的Protocol默认实现
// dart的Mixin使用参考：https://juejin.im/post/5d25a6d7f265da1b725c2b2a

// mixin类有两种定义方式：
// 一、定义没有构造器的class类，可以拿来作为mixin类使用（如下使用）
// 二、直接使用mixin关键字代替class类
// 即可以这样来定义： mixin MixinCls {}
class MixinCls {
  void sayWorld() {
    print(&quot;World&quot;);
  }
}

class Father {
  void sayHello() {
    print('Hello');
  }
}

class Son1 extends Father {
}

// 用with关键词，来加上Mixin类，接入Mixin类的实现
class Son2 extends Father with MixinCls {
  // 子类跟Mixin中的方法签名相同时，子类的实现有更高的优先级
  // void sayWorld() {
  //   print(&quot;Son2: World&quot;);
  // }
}

void runClasses() {
  Son1 son1 = Son1();
  son1.sayHello();
  // son1.sayWorld();   // son1是调用不了sayWorld的

  Son2 son2 = Son2();
  son2.sayHello();
  son2.sayWorld();    // 可以正常输出World
}
</code></pre>
<h4 id="异步-1"><a class="header" href="#异步-1">异步</a></h4>
<pre><code class="language-dart">////////////////////////////////
// Future就是iOS开发中理解的Promise，表示未来会产生值或会产生错误
Future&lt;String&gt; loadData() {
  sleep(Duration(seconds: 1));	// 延迟1秒

  // 随机产生成功或失败
  if (Random().nextInt(10) % 2 == 0) {
    return Future.value('Hello');
  } else {
    return Future.error('Error!');
  }
}

void runFuture() {
  // 1秒后会输出: Hello 或: Warnning! Error!
  loadData().then((v) {
    print(v);
  }).catchError((err) {
    print('Warnning! ${err}');
  });
}

////////////////////////////////
// await/async可以理解为协程的支持
// await要配合Future来使用
// 会同步的获取等待Future的结果返回，才会继续往下走
void runAwait() async {
  // 使用await来同步获取结果时，产生的错误要通过try来捕获
  try {
    String data = await loadData();
    print(data);
  } catch (e) {
    print(e);
  }
}

////////////////////////////////
// Stream类似RxSwift中的Observable，表示未来的一系列数据，能力上要强于Future
// RxDart在实现时，就没有实现Observable类，而是基于Stream扩展的
// 示例参考：https://juejin.im/post/5baa4b90e51d450e6d00f12e
Stream&lt;String&gt; readFile() async* {
  // 该方法其实是用的异步生成器来生成的Stream对象
  for (int i = 1; i &lt;= 3; i++) {
    sleep(Duration(seconds: 1));
    yield 'line ${i}';
  }
}

void runStream() {
  // 输出结果上，会每隔1秒打印一次
  readFile().listen((v) {
    print(v);
  });
}
</code></pre>
<h4 id="生成器-1"><a class="header" href="#生成器-1">生成器</a></h4>
<pre><code class="language-dart">// 生成器分同步生成器、异步生成器
// 异步生成器生成的结果就是上面提的Stream
Stream&lt;int&gt; asynchronousNaturalsTo(int n) async* {
  int k = 0;
  while (k &lt; n) yield k++;
}

// 同步生成器返回的结果是Iterable对象 (即可以使用moveNext进行迭代的对象)
// 可以通过for来枚举里面的所有元素的集合对象
// 使用同步生成器的好处在于，只有调用moveNext时，才会真正执行相应的逻辑。可以理解为lazy类型的操作
Iterable&lt;int&gt; naturalsTo(int n) sync* {
  var k = 0;
  while (k &lt; n) {
    print('Iterable count $k');
    yield k++;
  }
}

// 同步生成器真正执行的结果：
// Iterable count 0
// i:0
// Iterable count 1
// i:1
// Iterable count 2
final v = naturalsTo(10);
for (final i in v) { 
  if (i == 2) {
    break
  }
  print('i:$i');
}
</code></pre>
<h4 id="extension-1"><a class="header" href="#extension-1">Extension</a></h4>
<pre><code class="language-dart">// dart 2.7
class MyClass {
  int value;
  MyClass(this.value);
}

extension MyClsExt on MyClass {
  // 目前extension中还不支持static方法 (2021.4.15)
  // 但目前是有计划: https://github.com/dart-lang/language/blob/master/accepted/2.7/static-extension-methods/feature-specification.md
  void outputInfo() {
    print(value);
  }
}

main() {
  final c = MyClass(10);
  c.outputInfo();	// 输出10
}

</code></pre>
<h4 id="null-safety-1"><a class="header" href="#null-safety-1">Null Safety</a></h4>
<pre><code class="language-dart">// dart 2.12
// 能力及使用上非常类似于Swift中的Optional
void myfunc(int v) {
  print(v);
}

main() {
  int? v1;
  myfunc(v1);  // 编译错误
  myfunc(v1!); // 无编译错误，但会挂掉：Null check operator used on a null value

  int v2;
  myfunc(v2); // 编译错误
  
  int? v3 = 5;
  myfunc(v3); // ok
}
</code></pre>
<h4 id="const-1"><a class="header" href="#const-1">Const</a></h4>
<p><code>const</code>关键字使用需要注意：</p>
<ul>
<li>被const修饰的对象，内部所有数据都是不可更改的</li>
<li>必须由编译时可计算的数据所初始化</li>
<li>函数可选参数的默认值必须是<code>const</code>的</li>
<li>可选参数默认值，用一个<code>const</code>类型的构造器构造的对象，也必须再用<code>const</code>修饰一下</li>
<li><code>const</code>类型的构造函数，初始化列表参数中，默认初始化数据也必须用<code>const</code>来修饰 (非<code>const</code>构造函数没有这个限制)</li>
</ul>
<h3 id="高级使用-1"><a class="header" href="#高级使用-1">高级使用</a></h3>
<p><a href="https://github.com/dart-lang/sdk/blob/master/runtime/docs/pragmas.md">VM特定语法注释</a></p>
<p>在Dart库中大量使用了VM编译语法，如：<a href="https://github.com/dart-lang/sdk/blob/f04757f6ea7eab74057a1739ca37072ccbb3f733/sdk/lib/_internal/vm/lib/array.dart">_List</a>实现</p>
<h3 id="其它需要关注点-1"><a class="header" href="#其它需要关注点-1">其它需要关注点</a></h3>
<ul>
<li>List、Map中，可以添加null的 (map的key也可以为null，并且也是一个有效key)</li>
<li>一个实体类的子类，仍然可以定义为抽象类</li>
<li>所有的函数都有返回值，如果函数返回值定义为void，则接收到的返回值其实是null</li>
<li>mixin的顺序是比较重要的，后面的mixin实现会覆盖前面的实现</li>
<li><a href="https://dart.dev/tools/diagnostic-messages">dart警告</a>可以通过在代码上方加上：<code>// ignore: ***</code> 来禁用相应警告 (不建议)</li>
</ul>
<h3 id="资料-32"><a class="header" href="#资料-32">资料</a></h3>
<p><a href="https://dart.cn/guides/language/effective-dart">Dart编码规范</a></p>
<p><a href="https://dart.cn/">Dart中文文档</a></p>
<p><a href="https://dart.cn/guides/language/effective-dart/usage">高效的编码指南</a></p>
<p><a href="https://dartpad.dartlang.org/">Dart在线练习</a></p>
<p><a href="https://juejin.im/post/5c506a7c51882525c71333d2">Dart vs Swift</a></p>
<p><a href="https://github.com/arcticfox1919/learn-dart/blob/master/Dart%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3.md">Dart 异步编程详解</a>	讲Isolate非常好的文章</p>
<p><a href="https://github.com/dart-lang/dart_style/wiki/Formatting-Rules">dartfmt执行规则</a></p>
<p><a href="https://stackoverflow.com/questions/50431055/what-is-the-difference-between-the-const-and-final-keywords-in-dart">Dart中const关键词</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c"><a class="header" href="#c">C++</a></h1>
<h3 id="资料-33"><a class="header" href="#资料-33">资料</a></h3>
<ul>
<li><a href="https://changkun.de/modern-cpp/">现代 C++ 教程：高速上手 C++ 11/14/17/20</a></li>
<li><a href="https://github.com/kelthuzadx/EffectiveModernCppChinese">《Effective Modern C++ 》</a></li>
<li><a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference.com</a></li>
</ul>
<h3 id="特性-3"><a class="header" href="#特性-3">特性</a></h3>
<ul>
<li>支持默认参数 (如果某个参数是默认参数，那么它后面的参数必须都是默认参数)</li>
<li>支持类型的自动推断 (auto)</li>
<li>支持闭包 (lambda)</li>
<li>支持泛型 (模板)</li>
<li>闭包支持作为函数参数传递（当闭包捕获列表为空时支持）</li>
<li>支持运算符重载 (<a href="https://blog.csdn.net/afei__/article/details/82082003">C++ 运算符重载详解</a>，运算重载实质还是定义了一个函数)</li>
<li>支持<code>类型转换函数(type conversion function)</code>（<a href="https://www.jianshu.com/p/27a2f8658a53">C++中的类型转换函数</a>）</li>
<li>支持类型别名 (<code>using foo = void(int);</code>)</li>
<li>支持偏函数，提前绑定函数参数 (<code>std::bind</code>)</li>
<li>支持Promise/Future (<code>std::promise</code>及<code>std::future</code>)</li>
<li>支持内部类</li>
<li>支持拷贝构造函数和赋值构造函数</li>
</ul>
<h3 id="技术点"><a class="header" href="#技术点">技术点</a></h3>
<ul>
<li>左值：有内存位置的对象，例如: <code>int var = 4;</code>中，var就是左值。(参考：<a href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">理解 C/C++ 中的左值和右值</a>)</li>
<li>右值：除左值之外的，例如：常量<code>4</code>就是右值</li>
<li>函数对象包装器(<code>std::function</code>)支持将任何可调用目标实体进行存储、复制与调用。</li>
<li><code>default</code>关键字，可以生成默认的函数。(可以解决添加了其他有参数的构造函数，编译器就不再生成缺省的构造函数的问题)</li>
<li><code>noexcept</code>，声明不会发生异常。(<a href="https://www.cnblogs.com/sword03/p/10020344.html">C++11 带来的新特性 （3）—— 关键字noexcept</a>)</li>
<li><code>友元函数</code>：定义在类外部，但有权访问类的所有私有成员和保护成员。（用<code>friend</code>来修饰）</li>
<li><code>友元类</code>：友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息。</li>
<li><code>struct</code>和<code>class</code>的区别：1. 默认继承权限不同，class默认<code>private</code>，struct默认<code>public</code>。2. 成员默认访问权限不同，class成员默认为<code>private</code>，struct成员默认为<code>public</code></li>
</ul>
<h3 id="标准库"><a class="header" href="#标准库">标准库</a></h3>
<ul>
<li><code>std::once_flag</code>、<code>std::call_once</code>：<a href="https://zhuanlan.zhihu.com/p/71900518">C++中once_flag、call_once使用</a></li>
<li>支持纳秒级精度的<code>std::chrono</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<h3 id="资料-34"><a class="header" href="#资料-34">资料</a></h3>
<ul>
<li>
<p><a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a> | <a href="https://kaisery.gitbooks.io/trpl-zh-cn/content/">gitbooks版本</a></p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a> | <a href="https://rustwiki.org/zh-CN/rust-by-example/index.html">中文版</a>：非常好的学习方式</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/reference/introduction.html">The Rust Reference</a> | <a href="https://minstrel1977.gitee.io/rust-reference/introduction.html">中文版</a>：更加全面与简单的指导手册</p>
</li>
<li>
<p><a href="https://rust-cookbook.budshome.com/intro.html#rust-cookbook-%E4%B8%AD%E6%96%87%E7%89%88">Rust Cookbook 中文版</a></p>
</li>
<li>
<p><a href="https://share.weiyun.com/UmgqIyo4">Rust跨平台客户端的实践</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/73890910">Rust on iOS</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/108308284">Rust + Flutter 高性能的跨端尝试</a></p>
</li>
<li>
<p><a href="https://www.rust-lang.org/zh-CN/">Rust官网</a></p>
</li>
<li>
<p><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust.html">Rust性能对比</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/TPV6uG7StvSQIj3lxufU0Q">连续 3 年最受欢迎：Rust，香！</a></p>
</li>
</ul>
<h3 id="链接"><a class="header" href="#链接">链接</a></h3>
<ul>
<li><a href="https://docs.rs/">docs</a></li>
<li><a href="https://crates.io/">crates</a></li>
</ul>
<h3 id="命令-4"><a class="header" href="#命令-4">命令</a></h3>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>rustc main.rs</code></td><td>编译main.rs为二进制文件</td></tr>
<tr><td><code>cargo new hello</code></td><td>创建命为hello的Rust项目</td></tr>
<tr><td><code>cargo build</code></td><td>构建Rust项目</td></tr>
<tr><td><code>cargo run</code></td><td>运行Rust项目</td></tr>
<tr><td><code>cargo build --release</code></td><td>构建可发布的Rust项目</td></tr>
<tr><td><code>cargo run --example example_name</code></td><td>运行工程中的指定示例</td></tr>
<tr><td><code>cargo run -- args</code></td><td>使用指定参数执行应用</td></tr>
</tbody></table>
<h3 id="rust介绍"><a class="header" href="#rust介绍">Rust介绍</a></h3>
<p>四大目标：</p>
<ul>
<li>内存安全</li>
<li>一致性</li>
<li>明确语义</li>
<li>零成本抽象表达能力</li>
</ul>
<p>类型种类：</p>
<ul>
<li>基本类型</li>
<li>自定义复合类型</li>
<li>容器类型</li>
<li>泛型</li>
<li>特定类型</li>
</ul>
<h3 id="rust特性"><a class="header" href="#rust特性">Rust特性</a></h3>
<ul>
<li>支持<code>可变</code> / <code>不可变</code>类型</li>
<li>支持元组 （Rust也支持命名元组，使用Struct来定义）</li>
<li>标准库中，支持 <code>Option</code> 类型，也支持 <code>Result</code> 类型。区别在于 <code>Option</code> 是由 <code>Some</code> 和 <code>None</code> 来区分，<code>Result</code> 由 <code>Ok</code> 与 <code>Err</code> 区分结果</li>
<li>支持模式匹配</li>
<li>枚举中也支持定义函数类型</li>
<li>支持泛型 (与C++的template比较像，编译时生成多个方法)</li>
<li>支持一种特殊泛型，<code>所有权泛型</code>，使用方式类似：<code>struct Renderer&lt;'a&gt;</code></li>
<li>支持协议 (Rust中叫<code>Trait</code>，Swift中叫<code>Protocol</code>)，两者的协议能力非常类似</li>
<li>没有提供继承，通过组合来实现代码复用</li>
<li>测试代码可以写在源文件中</li>
<li>注释文档中可以也可以写测试代码</li>
<li>面向表达式的语言。（除了<code>use</code>这种声明语句，其它基本都是表达式）</li>
<li>没有 <code>三元操作符</code></li>
<li><code>内存字节对齐</code>在Rust中会进一步优化，进行字段重排，以优化内存占用</li>
<li>函数、闭包是不同的，调用语法也不一样。闭包是这种形式：<code>|e| e +1</code>  （闭包也分不同类型，可以参考：<a href="https://dengjianping.github.io/2019/03/05/%E8%B0%88%E4%B8%80%E8%B0%88Fn,-FnMut,-FnOnce%E7%9A%84%E5%8C%BA%E5%88%AB.html">谈一谈Fn, FnMut, FnOnce的区别</a> )</li>
<li>仅字符串类型就分很多种，根据不同类型使用不同字符串</li>
</ul>
<h3 id="概念-2"><a class="header" href="#概念-2">概念</a></h3>
<p><code>package</code>：</p>
<p><code>crate</code>：一个或一批文件，编译后可以生成一个可执行文件或库</p>
<h3 id="语法-2"><a class="header" href="#语法-2">语法</a></h3>
<h4 id="宏"><a class="header" href="#宏">宏</a></h4>
<p><code>#[macro_use]</code> 将其它模块中的宏加载到本模块中使用</p>
<p><code>#[macro_export]</code> 支持将包中的宏导出，给外部使用</p>
<h4 id="类型-2"><a class="header" href="#类型-2">类型</a></h4>
<p>DST：动态大小类型</p>
<p>ZST：0大小类型</p>
<p>存在<code>Sized</code>的trait，用来表示是否可以在编译期确定大小。</p>
<ul>
<li><code>Sized</code>：确定的大小</li>
<li><code>!Sized</code>：不能确定大小</li>
<li><code>?Sized</code>：都可</li>
</ul>
<h3 id="内存相关"><a class="header" href="#内存相关">内存相关</a></h3>
<h4 id="deref"><a class="header" href="#deref">Deref</a></h4>
<p><code>Deref</code> 是 <code>deref</code> 操作符 <code>*</code> 的 trait，比如 <code>*v</code>。<code>*v</code> 操作，是 <code>&amp;v</code> 的反向操作，即试图由资源的引用获取到资源的拷贝。</p>
<p><a href="https://wiki.jikexueyuan.com/project/rust-primer/intoborrow/deref.html">Deref</a></p>
<h4 id="asref--asmut"><a class="header" href="#asref--asmut">AsRef / AsMut</a></h4>
<p><code>AsRef</code>可以从<code>T</code>得到了一个类型为 <code>&amp;U</code> 的新引用，并且T不会被消耗。</p>
<p><code>AsMut</code>是<code>AsRef</code>的可变引用版本。</p>
<h4 id="borrow-borrowmut-toowned"><a class="header" href="#borrow-borrowmut-toowned">Borrow, BorrowMut, ToOwned</a></h4>
<p><code>Borrow</code> 是 <code>AsRef</code> 的严格版本，前后类型之间要求必须有内部等价性。</p>
<p><code>ToOwned</code>是<code>Clone</code>的普适版本，<code>Clone</code>只能从<code>T</code>生成<code>T</code>，但<code>ToOwned</code>可以从<code>T</code>生成<code>U</code>，没有限制。</p>
<h4 id="cow"><a class="header" href="#cow">Cow</a></h4>
<p><code>Clone-on-write</code>的缩写</p>
<p><a href="https://wiki.jikexueyuan.com/project/rust-primer/intoborrow/cow.html">Cow</a></p>
<h4 id="move"><a class="header" href="#move">Move</a></h4>
<p>在绑定数据时，当类型实现了拷贝时，默认会进行对象的拷贝。如果不希望其拷贝，则可以使用<code>move</code>来修饰</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x: String = String::from(&quot;abc&quot;);
    {
        // 这儿使用括号括起来，是为了让x用完之后将所有权释放，以便后续继续使用x
        let mut some_closure = |c: char| x.push(c);
        some_closure('d');
    }
    println!(&quot;x={:?}&quot;, x);  // 打印：x=&quot;abcd&quot;
}
</code></pre></pre>
<h4 id="lifetime"><a class="header" href="#lifetime">Lifetime</a></h4>
<p>借用：借用方的生命周期不能比出借方的生命周期还要长。</p>
<h5 id="函数中的生命周期参数"><a class="header" href="#函数中的生命周期参数">函数中的生命周期参数</a></h5>
<p><code>fn max_num&lt;'a&gt;(x: &amp;'a i32, y: &amp;'a i32) -&gt; &amp;'a i32</code>，当x和y的生命周期不一样长时，会取x和y的<strong>重叠部分</strong>，即x和y都有效的时间段，是'a的生命周期。</p>
<p><a href="https://learnku.com/articles/44644">细说 rust 生命周期参数</a></p>
<p><a href="https://wiki.jikexueyuan.com/project/rust-primer/ownership-system/lifetime.html">生命周期</a></p>
<h3 id="rust实现原则"><a class="header" href="#rust实现原则">Rust实现原则</a></h3>
<ul>
<li>迫使你处理结果</li>
<li>不提供继承，迫使你优先使用组合来实现代码复用</li>
</ul>
<h3 id="工程开发"><a class="header" href="#工程开发">工程开发</a></h3>
<ul>
<li><a href="https://learnku.com/articles/31161">Rust模块和文件</a>：对模块说的非常清晰的文章</li>
</ul>
<h3 id="其它-7"><a class="header" href="#其它-7">其它</a></h3>
<ul>
<li>Rust后端也是LLVM</li>
</ul>
<h3 id="细节"><a class="header" href="#细节">细节</a></h3>
<ul>
<li>支持问号操作符，简化Result处理</li>
<li>不使用的变量，可以通过加<code>下划线</code>前缀，来关闭警告</li>
<li>使用 <code>r&quot;&quot;</code> 来包裹的字符串，里面可以使用特殊字符而不需要转义（<code>r</code>表示原始字符串）</li>
<li>使用 <code>r#&quot;&quot;#</code> 来包裹的字符串，里面即可以有特殊字符，也可以有 <code>&quot;</code> 而不需要转义</li>
</ul>
<table><thead><tr><th>能力</th><th>Rust</th><th>Swift</th></tr></thead><tbody>
<tr><td>不可变类型</td><td><code>let x = 5</code></td><td><code>let x = 5</code></td></tr>
<tr><td>可变类型</td><td><code>let mut x = 5</code></td><td><code>var x = 5</code></td></tr>
<tr><td>支持元组</td><td><code>(1, true)</code></td><td><code>(1, true)</code></td></tr>
</tbody></table>
<h3 id="有趣特性"><a class="header" href="#有趣特性">有趣特性</a></h3>
<h5 id="loop中的break后可以跟数值"><a class="header" href="#loop中的break后可以跟数值">loop中的break后可以跟数值</a></h5>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut counter = 0;
let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2;
    }
};
<span class="boring">}
</span></code></pre></pre>
<h5 id="方法与函数做了明确的区分"><a class="header" href="#方法与函数做了明确的区分">方法与函数做了明确的区分</a></h5>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 方法是定义在结构体/枚举等中定义的，其首个参数总是self
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="调试-1"><a class="header" href="#调试-1">调试</a></h3>
<ul>
<li>安装<code>codelldb</code>扩展</li>
<li>利用vscode生成<code>launch.json</code>文件</li>
<li>如果是想调试example，找到：name为<code>Debug example</code>的项，如果需要参数的话，在<code>args</code>中添加上相应的参数</li>
</ul>
<h3 id="开源库"><a class="header" href="#开源库">开源库</a></h3>
<ul>
<li><a href="https://crates.io/crates/quick-xml">quick-xml</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="js-2"><a class="header" href="#js-2">JS</a></h1>
<h3 id="资料-35"><a class="header" href="#资料-35">资料</a></h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/102284595">JS基础知识测试</a></li>
<li><a href="https://github.com/30-seconds/30-seconds-of-code">JS小片断</a></li>
<li><a href="https://segmentfault.com/a/1190000017927665">JavaScript是如何工作的</a></li>
<li><a href="Language/../Note/ProfessionalJS.html">JavaScript高级程序设计</a></li>
<li><a href="https://github.com/doodlewind/jshistory-cn">JavaScript 20 年</a></li>
</ul>
<h3 id="js动态特性-1"><a class="header" href="#js动态特性-1">JS动态特性</a></h3>
<p>JavaScript 虽然被称为是“动态语言”，但确实是拥有静态语义的。</p>
<pre><code class="language-shell"># 这些执行在不同的环境中，表现其实是不一样的，如在node、chrome的控制台中表现也不一样

&gt; [] + {}
'[object Object]'

# 这一行，由于自动分号插入，会被解析成：{}; + []
# +[] 等价于：Number([])
&gt; {} + []
0

&gt; {} + {}
NaN

&gt; [] + []
''
</code></pre>
<ul>
<li>js支持在对象定义之后，动态的 添加 / 修改 / 删除 / 查询</li>
</ul>
<h5 id="类型转换-1"><a class="header" href="#类型转换-1">类型转换</a></h5>
<ul>
<li>在算术函数和表达式中，会自动进行 number 类型转换。(如<code>&quot;6&quot; / &quot;2&quot;</code>，结果为3)</li>
<li>任何对象转为boolean类型时，都为true</li>
</ul>
<p>JS中存在两种大的类型，<code>引用类型</code>和<code>值类型</code>。<code>引用类型</code>细分为<code>对象</code>和<code>函数</code>，其它的类型为<code>值类型</code>。</p>
<p>从<code>值</code>到<code>引用</code>，使用<code>Object(x)</code>，这个方法是安全无副作用的。从<code>引用</code>到<code>值</code>，使用<code>x.valueOf()</code></p>
<p>“任何东西都是可以转换为字符串的”，这个在理论上是行的通，但实际是存在一些无法完成转换的情况。这种情况下，转换为字符串，只会得到一个“简单的描述”，仅能表示“这是一个对象”，而没有其它意义。</p>
<p>JavaScript 约定，所有“对象 -&gt; 值”的转换结果要尽量地趋近于 string、number 和 boolean 三者之一。</p>
<h3 id="其它-8"><a class="header" href="#其它-8">其它</a></h3>
<h4 id="jsaot-1"><a class="header" href="#jsaot-1">JSAOT</a></h4>
<p>JS/TS转C语言</p>
<p>https://github.com/andrei-markeev/ts2c</p>
<p>https://andrei-markeev.github.io/ts2c/</p>
<p>https://github.com/NectarJS/nectarjs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-2"><a class="header" href="#typescript-2">TypeScript</a></h1>
<h3 id="资料-36"><a class="header" href="#资料-36">资料</a></h3>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1499075">VSCode使用ts-node 调试TypeScript代码</a></li>
<li><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解 TypeScript</a></li>
</ul>
<h3 id="语法-3"><a class="header" href="#语法-3">语法</a></h3>
<ul>
<li>支持可选参数，通过在参数类型后加<code>?</code>。可选参数需要放在参数列表的后面</li>
<li>支持默认参数</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-2"><a class="header" href="#webassembly-2">WebAssembly</a></h1>
<p><a href="http://webassembly.org.cn/docs/high-level-goals/">WebAssembly的长久目标</a></p>
<p><a href="http://webassembly.org.cn/docs/use-cases/">WebAssembly使用场景</a></p>
<h3 id="支持的语言-1"><a class="header" href="#支持的语言-1">支持的语言</a></h3>
<p><a href="http://webassembly.org.cn/docs/c-and-c++/">C/C++</a></p>
<p><a href="https://www.rust-lang.org/zh-CN/">Rust</a></p>
<p><a href="https://github.com/golang/go/wiki/WebAssembly">go</a></p>
<p><a href="https://swiftwasm.org/">Swift</a> (fork后还未合入swift工程)</p>
<p>语言列表：<a href="https://github.com/appcypher/awesome-wasm-langs">awesome-wasm-langs</a></p>
<h3 id="解释引擎-1"><a class="header" href="#解释引擎-1">解释引擎</a></h3>
<ul>
<li><a href="https://github.com/wasm3/wasm3">wasm3</a> 支持在iOS上使用</li>
</ul>
<h3 id="asmjs-1"><a class="header" href="#asmjs-1">asm.js</a></h3>
<p><code>asm.js</code>可以理解为<code>wasm</code>的前身，也是通过符合指定的条件，来让JS代码在某些JS引擎上执行更快。asm.js更多是面向JS引擎，而非普通开发者的。</p>
<h3 id="资料-37"><a class="header" href="#资料-37">资料</a></h3>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2017/09/asmjs_emscripten.html">asm.js 和 Emscripten 入门教程</a></li>
<li><a href="https://blog.csdn.net/code_for_free/article/details/53674210">asm.js：面向未来的开发</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25865972">WebAssembly 为什么比 asm.js 快？</a></li>
<li><a href="https://github.com/poetries/browser-working-principle/blob/master/docs/guide/part3/lesson14.md">编译器和解析器：V8如何执行一段JavaScript代码的</a></li>
<li><a href="https://www.zhihu.com/people/hu-zi-da-ha/posts">WebAssembly系列</a></li>
<li><a href="https://www.w3.org/2019/12/pressrelease-wasm-rec.html.zh">WebAssembly标准</a></li>
<li><a href="https://webassembly.studio/">Webassembly.studio</a> 创建在线的WASM工程页面，支持C/Rust等</li>
<li><a href="http://mbebenita.github.io/WasmExplorer/">WasmExplorer</a> 可以在线生成WAT和WASM文件</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly">MDN文档</a></li>
<li><a href="https://wapm.io/">WAPM</a> WebAssembly Package Manager</li>
<li><a href="https://hltj.me/wasm/2019/04/04/standardizing-wasi.html">标准化中的 WASI</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="haskell"><a class="header" href="#haskell">Haskell</a></h1>
<h3 id="安装"><a class="header" href="#安装">安装</a></h3>
<p>一、
<code>stack install intero QuickCheck hlint brittany ghcid</code></p>
<p>二、</p>
<pre><code class="language-sh">code \
--install-extension ucl.haskelly \
--install-extension hoovercj.haskell-linter \
--install-extension maxgabriel.brittany \
--install-extension jcanero.hoogle-vscode
</code></pre>
<p>重启VSCode就可以了</p>
<p>参考：<a href="https://dev.to/egregors/vscode-for-haskell-in-2020-5dn8">VS Code for Haskell in 2020</a></p>
<h3 id="使用-1"><a class="header" href="#使用-1">使用</a></h3>
<p>创建新工程：<code>stack new my-project</code></p>
<p>配置工程：<code>stack setup</code></p>
<p>编译：<code>stack build</code></p>
<p>执行：<code>stack exec my-project-exe</code></p>
<p>使用cabal安装第三方库：<code>cabal install packagename</code></p>
<p>删除Stack：删除这两个目录即可，<code>~/.stack</code>和<code>/usr/local/bin/stack</code></p>
<h3 id="资料-38"><a class="header" href="#资料-38">资料</a></h3>
<ul>
<li><a href="https://aducode.github.io/posts/2015-07-02/learn_haskell_lession1.html">haskell学习总结(一)::初级篇</a></li>
<li><a href="https://learnyouahaskell.mno2.org/zh-cn">HASKELL 趣学指南</a></li>
<li><a href="http://cnhaskell.com/">Real World Haskell 中文版</a></li>
<li><a href="https://github.com/krispo/awesome-haskell">Asesome Haskell</a></li>
<li><a href="http://hackage.haskell.org/package/base">haskell的标准库</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arm汇编"><a class="header" href="#arm汇编">ARM汇编</a></h1>
<h3 id="资料-39"><a class="header" href="#资料-39">资料</a></h3>
<p><a href="https://blog.cnbluebox.com/blog/2017/07/24/arm64-start/">iOS开发同学的arm64汇编入门</a></p>
<p><a href="https://mp.weixin.qq.com/s/yUHakSmU7zcJvTzjBvQDuQ">iOS逆向第五篇(ARM64 汇编)</a></p>
<p><a href="https://juejin.im/post/6844903582139940877">iOS汇编入门教程（二）在Xcode工程中嵌入汇编代码</a></p>
<p><a href="https://zhuanlan.zhihu.com/c_142064221">iOS调试进阶</a></p>
<p><a href="https://juejin.im/post/6844903693700202509">iOS逆向之旅</a></p>
<h3 id="xcode-1"><a class="header" href="#xcode-1">Xcode</a></h3>
<p>Xcode可以在调试时永远展示为汇编：<code>Debug</code> -&gt; <code>Debug Workflow</code> -&gt; <code>Always Show Disassembly</code></p>
<h3 id="arm"><a class="header" href="#arm">ARM</a></h3>
<ul>
<li>有31个通用寄存器，<code>r0 - r30</code>，汇编访问分别通过<code>x0 - x30</code>(读取64位数据)或<code>w0 - w30</code>(读取32位数据)</li>
<li>有32个向量寄存器，为<code>v0 - v31</code>，为128位的寄存器。可以通过<code>Bn Hn Sn Dn Qn</code>来分别访问8/16/32/64/128比特</li>
</ul>
<h3 id="指令"><a class="header" href="#指令">指令</a></h3>
<table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody>
<tr><td><code>mov x0 x1</code> / <code>mov x0 #3</code></td><td>x0 = x1 / x0 = 3</td></tr>
<tr><td><code>add x0 x1 #10</code> / <code>add x0 x1 x2</code></td><td>x0 = x1 + 10 / x0 = x1 + x2</td></tr>
<tr><td><code>sub x0 x1 #10</code> / <code>sub x0 x1 x2</code></td><td>x0 = x1 - 10 / x0 = x1 - x2</td></tr>
<tr><td><code>and x0 x1 x2</code></td><td>x0 = x1 &amp; x2</td></tr>
<tr><td><code>or x0 x1 x2</code></td><td>x0 = x1 | x2</td></tr>
<tr><td><code>B</code>、<code>BL</code></td><td>跳转</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编译器"><a class="header" href="#编译器">编译器</a></h1>
<h3 id="资料-40"><a class="header" href="#资料-40">资料</a></h3>
<p><a href="https://github.com/jamiebuilds/the-super-tiny-compiler">The Super Tiny Compiler</a>：几百行的非常简单的用来解释编译器工作的JS代码</p>
<p><a href="https://ruslanspivak.com/lsbasi-part1/">Let’s Build A Simple Interpreter</a></p>
<h3 id="基础概念-6"><a class="header" href="#基础概念-6">基础概念</a></h3>
<p><a href="http://sighingnow.github.io/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/bnf.html">BNF范式</a></p>
<p><a href="https://www.zhihu.com/question/21833944/answer/307309365">上下文无关文法(CFG)</a></p>
<p><a href="https://zh.wikipedia.org/wiki/LR%E5%89%96%E6%9E%90%E5%99%A8">LR分析器</a></p>
<p><a href="https://zh.wikipedia.org/wiki/LL%E5%89%96%E6%9E%90%E5%99%A8">LL分析器</a></p>
<p><a href="https://zh.wikipedia.org/wiki/LALR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">LALR语法</a></p>
<h3 id="虚拟机"><a class="header" href="#虚拟机">虚拟机</a></h3>
<p>资料：<a href="https://www.yuque.com/sukha/rf1pdg/vf52fk">虚拟机随谈</a></p>
<p>VM根据指令集架构分为<code>基于栈</code>和<code>寄存器</code>类型。vm的指令集如果只有零地址指令, 那么就只需要栈+PC寄存器就可以实现语义; 而如果还是有多地址指令, 那么就还要模拟寄存器.  这就是基于栈的虚拟机和基于寄存器的虚拟机的区别.</p>
<h3 id="ast"><a class="header" href="#ast">AST</a></h3>
<ul>
<li><a href="https://mp.weixin.qq.com/s/-pvoF4vd9jaUEdj0w2zOzA">一文助你搞懂 AST</a></li>
<li><a href="https://swift.gg/2019/01/25/nshipster-swiftsyntax/">SwiftSyntax</a></li>
<li><a href="https://astexplorer.net/">JS版AST Explorer</a></li>
<li><a href="https://swift-ast-explorer.kishikawakatsumi.com/">Swift版AST Explorer</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/36301857">前端要以正确的姿势学习编译原理（上篇）</a></li>
</ul>
<h4 id="a-hrefhttpsgithubcomjqueryesprimaesprimaa"><a class="header" href="#a-hrefhttpsgithubcomjqueryesprimaesprimaa"><a href="https://github.com/jquery/esprima">esprima</a></a></h4>
<p>比较简单的JS代码生成AST的库，解析为AST的过程，并没有严格把词法分析和语法分析分开，而是一起进行的。</p>
<p>源码分析：https://esprima.readthedocs.io/en/latest/getting-started.html</p>
<h4 id="a-hrefhttpsgithubcombenjamnrecastrecasta"><a class="header" href="#a-hrefhttpsgithubcombenjamnrecastrecasta"><a href="https://github.com/benjamn/recast">recast</a></a></h4>
<p>可以对代码做修改。实现上使用了<code>esprima</code>来生成AST，对AST做修改之后，再对其进行反向生成代码。</p>
<h3 id="lex--yacc"><a class="header" href="#lex--yacc">LEX &amp; YACC</a></h3>
<p><a href="https://segmentfault.com/a/1190000000396608">如何使用Lex/YACC</a> (文章对应的示例，可以从这儿下载：<a href="https://github.com/konieshadow/lex-yacc-examples">lex-yacc-examples</a>)</p>
<p><a href="https://my.oschina.net/fileoptions/blog/1647222">Lex和Yacc学习笔记</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/20178871">如何愉快地写个小parser</a>：讲了一些LEX &amp; YACC的其它应用</p>
<p><a href="https://sighingnow.github.io/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/lex_yacc.html">Lex和Yacc</a>：YYSTYPE定义等解释的比较清晰</p>
<p><a href="https://www.omegaxyz.com/2019/01/24/flex-bision-cal/">Mac下利用Flex和Bison实现控制台计算器</a></p>
<p><a href="http://dinosaur.compilertools.net/">The Lex &amp; Yacc Page</a></p>
<p><a href="https://github.com/zaach/jison">JS版本的Bison实现:Jison</a></p>
<p><a href="https://github.com/dabeaz/ply">Python版本的Lex&amp;Yacc实现:Ply</a></p>
<h3 id="antlr4"><a class="header" href="#antlr4">ANTLR4</a></h3>
<p><code>ANTRL</code>和<code>yacc</code>的主要区别，在于语法上，<code>yacc</code>是<code>LALR</code>语法，ANTRL是<code>LL(*)</code>语法。参考：<a href="https://cloud.tencent.com/developer/ask/67028">相对于Lex/yacc/bison，Antlr的优势？</a></p>
<p><a href="http://icejoywoo.github.io/2019/01/16/intro-to-antlr4.html">Antlr4 简介</a>：实现了一个简单的计算器</p>
<p><a href="https://www.scriptol.com/programming/antlr4-javascript.php">Making a compiler with the JavaScript runtime</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/31644101">编程语言试验之Antlr4+JavaScript实现&quot;圈4&quot;</a></p>
<p><a href="https://abcdabcd987.com/notes-on-antlr4/">ANTLR4 笔记</a></p>
<p><a href="https://www.antlr.org/">官网</a></p>
<p>安装步骤如下：</p>
<pre><code class="language-sh">$ cd /usr/local/lib
$ sudo curl -O https://www.antlr.org/download/antlr-4.8-complete.jar
$ export CLASSPATH=&quot;.:/usr/local/lib/antlr-4.8-complete.jar:$CLASSPATH&quot;
$ alias antlr4='java -jar /usr/local/lib/antlr-4.8-complete.jar'
$ alias grun='java org.antlr.v4.gui.TestRig'
</code></pre>
<h3 id="peg"><a class="header" href="#peg">PEG</a></h3>
<p>PEG是<code>解析表达文法</code>，具体解释可以参见：<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95">解析表达文法</a></p>
<p>Lex&amp;Yacc是基于CFG(上下文无关文法)实现的，但类似<a href="https://pegjs.org/">pegjs</a>是基于PEG来实现的</p>
<p><a href="https://zhuanlan.zhihu.com/p/49833910">PEG.js 介绍与基础使用</a></p>
<h3 id="llvm"><a class="header" href="#llvm">LLVM</a></h3>
<h5 id="基础"><a class="header" href="#基础">基础</a></h5>
<p><a href="http://llvm.org/docs/index.html">官方文档</a></p>
<p><a href="http://www.nagain.com/activity/article/4/">llvm之旅第一站 － 编译及简单使用</a></p>
<h5 id="llvm-ir"><a class="header" href="#llvm-ir">LLVM IR</a></h5>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/66793637">A Tour to LLVM IR（上）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/66909226">A Tour to LLVM IR（下）</a></li>
</ul>
<p><strong>注意</strong>：iOS中<code>bitcode</code>，即是IR中的<code>bc</code>后缀的格式</p>
<p>关于bitcode的解释，可以参考：<a href="https://juejin.im/post/6844903572568539143">Xcode 7 Bitcode的工作流程及安全性评估</a>、<a href="https://juejin.im/post/6844903843797401608">iOS 编译详解 LLVM Clang</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数式编程"><a class="header" href="#函数式编程">函数式编程</a></h1>
<h3 id="资料-41"><a class="header" href="#资料-41">资料</a></h3>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html">函数式编程入门教程</a></li>
<li><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/think_reactive.html">函数响应式编程简单介绍</a></li>
<li><a href="https://www.zhihu.com/pub/book/119565028">函数式编程思维</a></li>
<li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">JS函数式编程指南</a></li>
<li><a href="https://zhuanlan.zhihu.com/c_1189851586737033216">Haskell使用介绍</a> (偏实践)</li>
<li><a href="https://zhuanlan.zhihu.com/damotou">Haskell概念介绍</a></li>
<li><a href="https://www.zhihu.com/topic/19585411/top-answers">知乎函数式编程精华问答</a></li>
</ul>
<h3 id="核心概念-2"><a class="header" href="#核心概念-2">核心概念</a></h3>
<ul>
<li><a href="https://github.com/hemanth/functional-programming-jargon">函数式术语</a>：有中文版本</li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/monad.html">图解Monad</a></li>
<li><a href="https://www.jianshu.com/p/f935e54faad3">有趣的Monoid</a>：基于Swift讲解</li>
</ul>
<h4 id="functor-函子"><a class="header" href="#functor-函子">Functor (函子)</a></h4>
<p>参考：<a href="https://www.jianshu.com/p/001ff0dd3c30">一篇文章概述Functor(函子)、Monad(单子)、Applicative</a></p>
<blockquote>
<p>你可以把Functor、Applicative、Monad想象成Swift中的Protocol(协议)，它们可以成为某种数据结构（Context）的抽象。要将某个Context实现成Functor、Applicative、Monad，你必须实现其中特定的函数。</p>
</blockquote>
<p>Functor：使一个只能运算值的函数，用来运算一个包有这个值类型的Context，最后返回一个包有运算结果的Context</p>
<p>这个运算函数，就是<code>map</code>，所以可以说Functor是实现了 map 函数并遵守一些特定规则的容器类型。</p>
<p>Swiftz中fmap的定义：
<code>func fmap(_ f : (A) -&gt; B) -&gt; FB</code></p>
<blockquote>
<p>Functor存在的意义：
因为经常要对容器内数据进行转换，而且这是一种比较常见的操作。
Functor即定义了统一的协议和语言，可以对容器数据进行转换，并且转换后的结果仍然存在容器中。
结果仍然存在容器中有好处，如果容器也满足其它操作协议，即可以通过链式的调用来完成一系列操作。
在Swift中很多系统容器及Optional都实现了map，也实现了其它方法。但Haskell中会有所不同，被操作的容器与定义的函数是分开的，通过类型匹配。但本质上是一样的。</p>
</blockquote>
<blockquote>
<p>在<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html">JS函数式编程指南</a>里解释的使用容器的价值：
让容器自己去运用函数能给我们带来什么好处？答案是抽象，对于函数运用的抽象。当 map 一个函数的时候，我们请求容器来运行这个函数。不夸张地讲，这是一种十分强大的理念。(容器是代表了任意，这样就可以把概念变的很抽象，甚至可以普适任意场景)</p>
</blockquote>
<h4 id="pointed-functor"><a class="header" href="#pointed-functor">Pointed Functor</a></h4>
<p>参考：<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html#pointed-functor">pointed functor</a></p>
<p>Pointed Functor 是实现了<code>of</code>方法的Functor，of是为了把值放到Context中，以便后续可以使用Context的map等能力</p>
<p>Swiftz中定义了Pointed结构：</p>
<pre><code class="language-swift">public protocol Pointed {
	associatedtype A
	static func pure(_ : A) -&gt; Self
}
</code></pre>
<h4 id="applicative"><a class="header" href="#applicative">Applicative</a></h4>
<p>参考：<a href="https://www.jianshu.com/p/001ff0dd3c30">一篇文章概述Functor(函子)、Monad(单子)、Applicative</a></p>
<p>Applicative 是实现了<code>ap</code>方法的 Pointed Functor（即实现了of和ap方法的容器）</p>
<p><code>ap</code>与<code>map</code>的区别：</p>
<ul>
<li>map: Context(结果值) = map(Context(初始值), 运算函数)</li>
<li>ap: Context(结果值) = apply(Context(初始值), Context(运算函数))</li>
</ul>
<blockquote>
<p>当运算函数也被Context包裹时，就用ap</p>
</blockquote>
<p>Swiftz中对这个函数的声明为：
<code>func ap(_ f : FAB) -&gt; FB</code></p>
<blockquote>
<p>Applicative存在的意义：
需要对容器数据进行转换，但转换方法也可能在容器中
函数也被容器包裹有什么好处呢？因为函数也是值，也可以对函数进行随意操作或转换，并且可以链式的操作
应用场景：
比如一个柯里化后的函数，被Context包裹住了，每次拿另外一个Context中的数据与其进行结合，也就是逐渐应用参数，就可以以链式的方式来应用</p>
</blockquote>
<h4 id="monad-单子"><a class="header" href="#monad-单子">Monad (单子)</a></h4>
<p>参考：<a href="https://www.jianshu.com/p/001ff0dd3c30">一篇文章概述Functor(函子)、Monad(单子)、Applicative</a></p>
<p>Monad是实现了<code>bind</code>的Applicative。</p>
<blockquote>
<p>Monad是一种约束，面向抽象编程，定义了一个通用的能力。</p>
</blockquote>
<p>bind的函数签名是：
<code>function :: 值A -&gt; Context(值B)</code>（值A与值B的类型可相同亦可不同）</p>
<p>Swiftz中对这个函数的声明为：(Swiftz中，Monad继承自Applicative)
<code>func bind(_ f : (A) -&gt; FB) -&gt; FB</code></p>
<p>Swift中的<code>flatMap</code>只是bind的一种具体实现，Array的flatMap可以将二维数组扁平化为一维数组</p>
<blockquote>
<p>Monad存在的意义：
某些转换函数的签名为：(A) -&gt; Context(B)，之所有会存在这种情况，是因为函数返回Context(B)是有优势的，可以直接拿其进行链式调用，也可以将其应用在另外一个Context值上。
如果直接用fmap将其应用在另外一个Context值上，则会出现Context(Context(值))的情况，甚至多次使用fmap可能会嵌套多层Context
再对Context(Context(值))进行处理时，就会变得复杂化。在这种背景下，出现了<code>bind</code>(flatMap)函数，可以将返回的类型保持为Context(值)，简化使用逻辑。
使用场景2：
思维上也需要将函数“数据化”
当需要灵活使用柯里化时，柯里化的函数需要不断的结合参数，如果要链式的给其赋值，可能就需要让柯里化后的函数也能被Context包围，并且与新的Context(参数)作用起，生成新的Context((A) -&gt; B)类型的结果，以此继续进行后续赋值
此时Context就需要支持Monad协议。 具体使用示例可以参考<a href="https://github.com/thoughtbot/Argo.git">Argo</a>中README里的使用示例</p>
</blockquote>
<p><code>bind</code>是一种通用的规范：</p>
<ul>
<li>在Swift数组中，实现为<code>flatMap</code>，可以将二维数组转为一维数组。</li>
<li>在Promise中，then也是bind的一种实现，在then内部返回Promise后，外部返回的结果仍然是Promise类型</li>
</ul>
<h4 id="semigroup-半群"><a class="header" href="#semigroup-半群">Semigroup (半群)</a></h4>
<p>参考：<a href="https://www.jianshu.com/p/f935e54faad3">有趣的Monoid</a></p>
<blockquote>
<p>对于自然数1、2、3、4、5、...而言，加法运算+可将两个自然数相加，得到的结果仍然是一个自然数，并且加法是满足结合律的：(2 + 3) + 4 = 2 + (3 + 4) = 9。如此一来我们就可以认为自然数和加法运算组成了一个半群。
我们通常将这个运算称为append</p>
</blockquote>
<p>Swiftz实现：https://github.com/typelift/Swiftz/blob/master/Sources/Swiftz/Semigroup.swift</p>
<h4 id="monoid-单位半群"><a class="header" href="#monoid-单位半群">Monoid (单位半群)</a></h4>
<p>参考：<a href="https://www.jianshu.com/p/f935e54faad3">有趣的Monoid</a></p>
<blockquote>
<p>Monoid本身也是一个Semigroup，额外的地方是它多了单位元，所以被称作为单位半群。
单位元在维基百科上的定义：在半群S的集合S上存在一元素e，使得任意与集合S中的元素a都符合 a·e = e·a = a</p>
</blockquote>
<p>Swiftz实现：https://github.com/typelift/Swiftz/blob/master/Sources/Swiftz/Monoid.swift</p>
<h3 id="其它-9"><a class="header" href="#其它-9">其它</a></h3>
<h4 id="pointfree"><a class="header" href="#pointfree">Pointfree</a></h4>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html#pointfree">pointfree</a>，函数无须提及将要操作的数据是什么样的。</p>
<pre><code class="language-js">// 非 pointfree，因为提到了数据：word
var snakeCase = function (word) {
  return word.toLowerCase().replace(/\s+/ig, '_');
};
// pointfree
var snakeCase = compose(replace(/\s+/ig, '_'), toLowerCase);
</code></pre>
<h4 id="纯函数"><a class="header" href="#纯函数">纯函数</a></h4>
<h4 id="惰性求值"><a class="header" href="#惰性求值">惰性求值</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-跨平台"><a class="header" href="#7-跨平台">7. 跨平台</a></h1>
<p>包含了<code>React Native</code>、<code>Hippy</code>等跨平台方案的资料</p>
<p>跨平台除了目前主流的<code>RN</code>、<code>Flutter</code>外，还有<a href="https://wizardforcel.gitbooks.io/qt-beginning/content/">QT</a>、<a href="https://wizardforcel.gitbooks.io/wxwidgets-book/content/0.html">wxWidgets</a>等方案。</p>
<p>其中<code>QT</code>也是采用自绘控件实现的跨平台，与<code>Flutter</code>的实现方式相似。</p>
<h3 id="资料-42"><a class="header" href="#资料-42">资料</a></h3>
<p><a href="https://juejin.im/post/6844903872130088974">全网最全 Flutter 与 React Native 深入对比分析</a></p>
<h3 id="flutter-vs-rn-vs-native"><a class="header" href="#flutter-vs-rn-vs-native">Flutter vs RN vs Native</a></h3>
<p><a href="https://medium.com/swlh/flutter-vs-native-vs-react-native-examining-performance-31338f081980">Flutter vs Native vs React-Native: Examining performance</a></p>
<p><a href="https://medium.com/swlh/flutter-vs-react-native-vs-native-deep-performance-comparison-990b90c11433">Flutter vs React Native vs Native: Deep Performance Comparison</a></p>
<p><strong>结论</strong>：</p>
<table><thead><tr><th>类型/平台</th><th>Native</th><th>Flutter</th><th>RN</th></tr></thead><tbody>
<tr><td>密集性计算</td><td>OC效率优于Swift</td><td>比Native慢20%至5倍不等</td><td>比Native慢1个量级</td></tr>
<tr><td>UI</td><td></td><td>使用的<a href="https://juejin.im/post/6844903938030829582">Flare</a>来测的动画，做的优化与Lottie不同，对比不能完全说明问题</td><td>耗电量、内存都是最高的</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-native"><a class="header" href="#react-native">React Native</a></h1>
<p>最简单的理解，React Native类似NodeJS，都是通过扩展JS引擎，使JS代码有了调用Native接口的能力。</p>
<p>RN目前依赖的JS引擎是<code>JavaScriptCore</code>，是Webkit中的JS引擎。在iOS上是自带的，但在安卓上，需要打包进应用，所以RN的安卓版本要更大。不过在新的RN版本后，有支持<a href="https://github.com/facebook/hermes">Hermes引擎</a>，<code>Hermes</code>是FaceBook专门针对RN安卓平台优化的引擎。</p>
<h3 id="待确认"><a class="header" href="#待确认">待确认</a></h3>
<ul>
<li>Virtual DOM之后，通过哪个类区分调用Native或操作真实DOM的</li>
<li>具体JS和Native交互时的效率如何？</li>
<li>JSI如何在V8等上面实现</li>
</ul>
<h3 id="资料-43"><a class="header" href="#资料-43">资料</a></h3>
<p><a href="https://reactnative.cn/docs/getting-started.html">ReactNative环境搭建</a></p>
<p><a href="https://github.com/reactnativecn/react-native-guide">React-Native学习指南</a></p>
<p><a href="https://insights.thoughtworks.cn/the-react-native-mystery/">React Native性能之谜</a></p>
<p><a href="https://mrgaogang.github.io/react/">ReactNative源码解析</a>：基于iOS来分析</p>
<p><a href="https://github.com/sucese/react-native">ReactNative源码分析</a>：基于安卓来分析</p>
<p><a href="https://juejin.im/post/6844903862113943560">RN 通信原理（for 前端）</a></p>
<p><a href="https://zxfcumtcs.github.io/2017/10/08/ReactNativeCommunicationMechanism/">ReactNative源码解析——通信机制详解(1/2)</a></p>
<p><a href="https://zxfcumtcs.github.io/2017/10/12/ReactNativeCommunicationMechanism2/">ReactNative源码解析——通信机制详解(2/2)</a></p>
<p><a href="https://juejin.im/post/6844904146840059918">JS核心理论之《React Native原理浅析》</a>：介绍了RN新的架构</p>
<p><a href="https://zeyio.com/rn-render/">React Native渲染原理浅析</a>：渲染过程的介绍</p>
<h3 id="使用-2"><a class="header" href="#使用-2">使用</a></h3>
<h4 id="使用native-ui"><a class="header" href="#使用native-ui">使用Native UI</a></h4>
<ul>
<li>继承RCTViewManager</li>
<li>导出：RCT_EXPORT_MODULE(ViewName)</li>
</ul>
<p>参考：https://github.com/matthewyan/RNLearn/tree/master/NativeComponent</p>
<h4 id="使用native-module"><a class="header" href="#使用native-module">使用Native Module</a></h4>
<ul>
<li>实现RCTBridgeModule协议</li>
<li>导出模块：RCT_EXPORT_MODULE()</li>
<li>添加接口：RCT_EXPORT_METHOD</li>
</ul>
<p>参考：https://github.com/matthewyan/RNLearn/tree/master/NativeModule</p>
<h3 id="原理--源码"><a class="header" href="#原理--源码">原理 &amp; 源码</a></h3>
<p>RN使用及工作原理，简单来说，有如下几点：</p>
<ul>
<li>
<p>开发层面，非常类似ReactJS，包括文档也主要参考ReactJS</p>
</li>
<li>
<p>RN中也有Virtual DOM的概念。布局变化也会通过Diff算出差异，提升布局效率</p>
</li>
<li>
<p>JS中的布局逻辑，会转换为操作指令，调用至Native侧</p>
</li>
<li>
<p>JS和Native的交互非常频繁，但效率不高，这儿也是RN效率较低的根本原因</p>
</li>
<li>
<p>在新版本的RN(0.59之后)中，提供了JSI来提升JS和Native的交互效率</p>
</li>
<li>
<p>Native调用JS，是通过JSC提供的<code>JSObjectCallAsFunction</code>等接口实现的</p>
</li>
<li>
<p>JS调用Native，是通过JSC提供的<code>JSContext</code>的<code>block</code>能力。使用示例：<code>jsContext[@&quot;funcname&quot;] = ^() {}</code></p>
</li>
</ul>
<blockquote>
<p>新版本的RN的OC和JS的交互已经通过JSI来实现了</p>
<p>在iOS中，JSI并不是简单使用的JSC的<code>evaluateScript:</code>方法执行JS，而是使用了JSC提供的原始C接口。具体可以参考RN源码：<code>JSCRuntime::evaluateJavaScript</code>的实现。（Pod中的<code>React-jsi</code>即是JSI的实现）</p>
<p>JS调用OC的方法，使用的是JSC提供的<code>block</code>方式。在新版本中，是在C++中实现的，参考源码：<code>JSIExecutor::initializeRuntime()</code>的实现。</p>
<p><a href="https://developer.apple.com/documentation/javascriptcore">JavaScriptCore</a> 提供的C接口可以参考：<a href="https://juejin.im/post/6844903632639361038">JavaScriptCoreC语言API详细介绍</a></p>
<p>RN中Native和JS交互的逻辑，说的比较清楚是这篇文章：<a href="https://juejin.im/post/6844903862113943560">RN 通信原理（for 前端）</a>。 对应的示例代码为：<a href="https://github.com/iostalks/Arch">iostalks/Arch</a></p>
</blockquote>
<h4 id="核心概念-3"><a class="header" href="#核心概念-3">核心概念</a></h4>
<h5 id="rctrootview"><a class="header" href="#rctrootview">RCTRootView</a></h5>
<p>RN在Native上的展示容器，所以RN基于这种实现，就很方便在已有的Native应用中进行插入某一个RN页面</p>
<h5 id="rctshadowview"><a class="header" href="#rctshadowview">RCTShadowView</a></h5>
<p>继承自NSObject，主要能力是在子线程进行布局相关的计算。与RCTView的关系类似UIView和CALayer的关系。</p>
<h5 id="rctbridge"><a class="header" href="#rctbridge">RCTBridge</a></h5>
<p>负责管理OC和JS的交互。 所有要暴露给JS的Native模块，都需要实现<code>RCTBridgeModule</code>协议</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hippy"><a class="header" href="#hippy">Hippy</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="笔记-1"><a class="header" href="#笔记-1">笔记</a></h1>
<ul>
<li><a href="Note/./10xWork.html">10倍程序员工作法</a></li>
<li><a href="Note/./ProfessionalJS.html">JavaScript高级程序设计</a></li>
<li><a href="Note/./DDD_Distilled.html">领域驱动设计精粹</a></li>
<li><a href="Note/./DDDPractice.html">DDD实践课</a></li>
<li><a href="Note/./SoftwareDesign.html">软件设计之美</a></li>
<li><a href="Note/./SoftwareArchitecture.html">架构整洁之道</a></li>
</ul>
<h3 id="待学习"><a class="header" href="#待学习">待学习</a></h3>
<ul>
<li><a href="https://book.douban.com/subject/30419555/">持续交付2.0</a></li>
<li><a href="https://book.douban.com/subject/6828074/">解析极限编程</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10x程序员工作法"><a class="header" href="#10x程序员工作法">10x程序员工作法</a></h1>
<p>来源：<a href="https://time.geekbang.org/column/intro/148">10x程序员工作法</a></p>
<h2 id="前言-1"><a class="header" href="#前言-1">前言</a></h2>
<p>专题的核心就是在讲<strong>如何有效工作</strong>。</p>
<p>文章是分四个模块来讲的：以终为始、任务分解、沟通反馈、自动化。</p>
<p>四个模块中的一些实例，即可以属于A模块，又能放在B模块中，所以区分上并没有那么明显。比如，需求的描述方式从 <code>列表式</code> 到 <code>User Story</code> ，可以放在 <code>以终为始</code> 中，因为 <code>User Story</code> 的描述方式，会强迫人们思考结果和路径。但同时也可以放在 <code>沟通反馈</code> 中，因为需求描述方式的改变，可以认为是 <code>沟通方式</code> 的改变来提升沟通有效性。所以有些内容也不一定非要用某个模块的思路来去思考、看待它。</p>
<p>课程中一开始就给了一个非常重要的思考框架，这个框架中的 <code>目标</code> 和 <code>实现路径</code>，分别引出了 <code>以终为始</code> 和 <code>任务分解</code> 两大模块。这个思考框架也可以应用在各个场景中。</p>
<h3 id="非常重要的思考框架"><a class="header" href="#非常重要的思考框架">非常重要的思考框架</a></h3>
<ol>
<li>现状是什么？ （现状）</li>
<li>要达到什么目标？（目标）</li>
<li>要达到这个目标的实现路径是什么？（实现路径）</li>
</ol>
<hr />
<h2 id="以终为始"><a class="header" href="#以终为始">以终为始</a></h2>
<p>以终为始，就是在做事之前，先想想结果是什么样子的。以终为始重要的是思考方式，站在结果上思考。</p>
<p>任何事物都要经过两次创造：一次是在头脑中的创造，也即智力上的创造。然后才是付诸实践，也就是实际的构建或第二次创造。以终为始，也即要明确第一次创造的结果，以第一次创造的结果作为第二次创造的开始。（需要培养的重要意识）</p>
<p>亚马逊开发一项产品的过程：</p>
<ol>
<li>写新闻稿</li>
<li>写FAQ</li>
<li>写用户文档</li>
<li>写代码</li>
</ol>
<blockquote>
<p>与我们常规思路是反过来的，这个过程就是以终为始的一种做事思路</p>
</blockquote>
<p>以终为始中，很重要的一点就是大家对<strong>完成的定义</strong>是否一致！(即<code>DoD</code>，<code>Define of Done</code>要一致)</p>
<p>需求是软件开发中非常重要的部分，<strong>不同的需求描述方式，可能会影响程序员对需求的理解。</strong></p>
<blockquote>
<p>信息的传递是会衰减的，你不可能把你理解的信息 100% 传递给另外一个人，而这中间，如何传递，也就是如何描述将直接决定衰减的比例。</p>
</blockquote>
<p>我们习惯的 <code>列表式</code> 的需求描述方式，可能就不是一种好的信息传递方式。这种描述方式，比较缺乏完整的图景。现在也有一些其它的描述方式，其中 <code>User Story</code> 就是一种不错的方式。</p>
<h3 id="user-story用户故事"><a class="header" href="#user-story用户故事">User Story（用户故事）</a></h3>
<p><code>User Story</code>，是站在用户的角度来描述了一个用户希望得到的功能，关注用户在系统中完成一个动作需要经过怎样的路径。既然它是“故事”，它就需要是一个完整的场景，可以讲述出来。</p>
<p><code>User Story</code> 大致包括如下几个部分：</p>
<ul>
<li>标题：一句话说明主要内容</li>
<li>概述：作为一个什么角色，要做什么样的事，以便达成一种怎样的效果。</li>
<li>详述：描述完整流程，包括正常路径和异常路径。</li>
<li>验收标准：用真实的数据描述出正常/异常路径的结果。（验收标准也可以理解为核心测试用例。其中异常流程的描述，也是非常重要的）</li>
</ul>
<blockquote>
<p>即使是列表形式的需求描述方式，<code>验收标准</code> 也会迫使大家较全面的思考最终结果，能极大程度的改善双方协作效率。</p>
</blockquote>
<h3 id="持续集成"><a class="header" href="#持续集成">持续集成</a></h3>
<p>持续集成本身就是写代码的一个环节，程序员的交付物并不应该是代码，而是一个可工作的软件。</p>
<p>持续集成是非常好的实践，站在个体的角度也要尽早提交代码去集成。</p>
<p>持续集成中最重要的就是<strong>快速</strong>的得到有效反馈。在有些团队中，为了解决服务端CI过慢的问题，会将部分工作移到本地来做。</p>
<h3 id="精益创业"><a class="header" href="#精益创业">精益创业</a></h3>
<p>精益创业，是要解决的是面向不确定性创造新事物。精益创业的思路就是“试”，通过尝试<code>MVP</code>(最小可行产品)来降低尝试成本。</p>
<p>精益创业的方法论就是“开发”-&gt;“测量”-&gt;“认知”这样一个反馈循环。其中收获的<strong>认知</strong>是最重要的，它是经过验证的。</p>
<h3 id="其它-10"><a class="header" href="#其它-10">其它</a></h3>
<p>在所有迭代前可以添加一个<strong>迭代 0</strong>，所谓迭代 0，就是在迭代 1 之前的一个迭代，我们可以把它理解成开发的准备阶段。</p>
<p>扩大自己的上下文，跨越自己的位置思考，甚至跨越两三级的角度上来看问题，让自己更有全局视野。</p>
<p>IT 行业中大多数人的专业程度是不够的。</p>
<p>我们的工作，多数情况下，即便目标清晰，路径却是模糊的。尽量在事前就推演一下路径，明确达到目标的路径。（在军事上常用的词叫 <code>沙盘推演</code>，在各行各业应用的都比较多了）</p>
<p>一定要有很强的 <code>数据</code> 意识，用数据说话。如在项目开始前，就要给自己定上各种数据目标。产品发布后，经常关注线上数据</p>
<hr />
<h2 id="任务分解"><a class="header" href="#任务分解">任务分解</a></h2>
<p>当一个复杂问题摆在面前时，我们解决问题的一个主要思路是分而治之。</p>
<p>只有能把任务拆分得足够<strong>小</strong>，你才能对自己的执行能力有一个更清楚地认识。困难的任务只要拆的足够细，我们执行起来就相对比较容易，因为解决小问题就是我们善长的。（任务分解的关键就是<strong>小</strong>）</p>
<p>细分到什么程度为好呢？细分到每一步，你都清晰的知道如何解决。</p>
<p>软件变更的成本，随着时间和开发阶段，逐步增加。</p>
<p>测试应该作为开发的一部分，问题越早发现越好。</p>
<p><code>测试先行开发</code> 与 <code>测试驱动开发</code>，是两个不同的概念，这二者的差异就在重构上。TDD甚至可以理解为 <code>测试驱动设计</code>，因为先写测试，会迫使代码设计上趋向于易测试。</p>
<p>你多长时间能够提交一次代码？如果你的答案超过半天，对不起，你的做法步子一定是太大了。你之所以不能小步提交，一定是牵扯了太多相关的部分。
只有把任务分解到很小，才有可能做到小步提交。你能把任务分解到很小，其实是证明你已经想清楚了。而大多数程序员之所以开发效率低，很多时候是没想清楚就动手了。</p>
<p>养成<strong>习惯</strong>去完成一些 <code>小任务</code>，时间长了就发现一个难以完成的大任务就被轻易完成了。</p>
<hr />
<h2 id="沟通反馈"><a class="header" href="#沟通反馈">沟通反馈</a></h2>
<p><code>香农信息论</code>通信模型：</p>
<p><img src="Note/./images/Shannon_Communication.png" alt="通信模型" /></p>
<blockquote>
<p>发送器（Transmitter），它会对信息进行某些操作，也就是对信息编码，产生信号（Signal）。</p>
<p>接收器（Receiver），它是对信号执行发送器的逆操作，解码信号，提取出信息。</p>
</blockquote>
<p>世界为什么总和我的理解不一样，用香农的信息论解释，就是编解码的过程出了问题。因为每个人经历见识的差异，造成了各自编解码器的差异。</p>
<p>如何减少信息传递过程中的损耗呢？主要是通过改善编解码，以及沟通方式(或称为算法)。沟通方式可以借鉴各行各业的优秀实践，其中 <code>User Story</code> 就是一种优秀的需求沟通方式。</p>
<p>很多程序员讲东西存在的一个通病：<strong>讲东西直奔细节</strong>。直接讲细节，忽略背景信息的介绍，就很容易导致对方缺乏解码后续信息的能力，一头雾水。</p>
<p>可读、可维护性，非常重要：要以写 <code>文档</code> 的思维来写代码。</p>
<p>好的会议应该是 <code>信息同步</code> 的会议。需要讨论的会，人越少越好，把事情讨论清楚后同步出来。</p>
<blockquote>
<p>Amazon的开会方式是很值得借鉴，一般会议的邀请里面就会带着会议内容的文档，尤其是项目设计的会议，如果没有读过文档就去开会，很有可能被请出会议去 -- ZackZzzzzz</p>
</blockquote>
<h3 id="解决开发中重复出现的问题"><a class="header" href="#解决开发中重复出现的问题">解决开发中重复出现的问题</a></h3>
<h4 id="复盘"><a class="header" href="#复盘">复盘</a></h4>
<p>复盘是避免问题再犯的有效方式，复盘是指把过程还原，进行研讨与分析的方式。项目总结会上，列的 <code>well</code>、<code>less well</code> 也是复盘的一种相对简单的复盘。</p>
<p>常用的复盘框架是回答三类问题：做的好的、做的欠佳的、问题或建议</p>
<p>在复盘的过程中，要写<strong>事实</strong>，不要写感受。后续优化调整后，还可以反过来校验这些成果。</p>
<h4 id="5个为什么"><a class="header" href="#5个为什么">5个为什么</a></h4>
<p>当出现一个问题后，不断的重复问**&quot;为什么？&quot;<strong>，当问到最后彻底找到原因或无法再问出</strong>&quot;为什么？&quot;**时为止。</p>
<h4 id="其它-11"><a class="header" href="#其它-11">其它</a></h4>
<p>要吃自己的狗粮，即多用自己的产品。</p>
<p>要和产品经理有共同语言，就需要说<strong>业务语言</strong>，这就是领域驱动设计中的通用语言。</p>
<p>一定要尽早暴露问题，出现了问题，主动拋出来，越晚拋，隐患就越大。但在工作中暴露自己的问题，是很大的挑战，因为这里还面临着一个心理问题：会不会让别人觉得自己不行。</p>
<h3 id="知识输出"><a class="header" href="#知识输出">知识输出</a></h3>
<p>将零散的知识结构化，有很多种方式，但输出是非常关键的一环。</p>
<p>自己以为自己懂的东西，当你真的需要把它按照一个完整的逻辑呈现出来时，那些缺失的细节就会冒出来，而补齐这些细节，一张知识地图就逐渐成型了。</p>
<p>要想比较好的表达，<strong>金字塔原理</strong>是非常重要的工具。金字塔原理的四个核心原则是：<strong>结论先行</strong>、<strong>以上统下</strong>、<strong>归类分组</strong>、<strong>逻辑递进</strong>。(利用金字塔的结构，然后自下而上来描述，也是一种表述方式)</p>
<p>阻碍很多人进行知识输出的一个重要原因是缺乏输出的模型。利用好金字塔原理，并且不断练习，良好的知识输出能力慢慢就成为了自然而然的能力，而且让自己的知识体系变得完善和牢固。</p>
<blockquote>
<p>学习的四重境界：器-&gt;术-&gt;道-&gt;传道，传道是学习的最高境界  -- <a href="https://time.geekbang.org/column/intro/158">【软件工程之美】</a></p>
</blockquote>
<p>国内程序员真正落后的不是信息，而是<strong>观念</strong>。国内程序员的平均水平，大多停留在实现一个功能的理解上，而发达国家的程序员做事要专业许多。(专业是指的类似更好的工程素养、更好的代码实践等)</p>
<hr />
<h2 id="自动化"><a class="header" href="#自动化">自动化</a></h2>
<p>程序员的三大美德：</p>
<ul>
<li><strong>懒惰</strong>，是一种品质，它会使你花很大力气去规避过度的精力消耗，敦促你写出节省体力的程序，别人也能很好地利用，你还会为此写出完善的文档，以免别人来问问题。</li>
<li><strong>急躁</strong>，是计算机偷懒时，你会感到的一种愤怒。它会促使你写出超越预期的程序，而不只是响应需求。</li>
<li><strong>傲慢</strong>，极度自信，写出（或维护）别人挑不出毛病的程序。</li>
</ul>
<h4 id="懒惰"><a class="header" href="#懒惰">懒惰</a></h4>
<ul>
<li>做好自动化</li>
<li>通过<strong>做</strong>一些事情可以产生价值，但通过<strong>不做</strong>这一些事情，也可能产生价值。（如某个项目已经推导出非常不可行了，此时通过取消它来避免无意义的浪费和消耗，也是一种价值）</li>
<li>避免<code>NIH综合症</code>，即不断的重复造轮子</li>
<li>通过<code>软件设计</code>，来避免实现不断调整，影响整个框架的稳定。即使某些组件技术选型已经选好了，仍然要以<strong>抽象</strong>的方式去看它，这样即使后续调整选型，抽象部分也可能是不需要调整的。（高层设计的稳定性会更强，不那么容易变化。）</li>
</ul>
<p>除此之外，自动化这系列文章，主要讲了 <code>持续集成</code> 及更进一步的 <code>持续交付</code> ，其它还有 <code>Devops</code>。这些都是公司目前在强力推动的实践，不展开了。还有一些是代码设计原则方面的，也是属于比较基础的内容。作者强烈推荐大家学习的就是 <code>DDD</code>，即 <code>领域驱动设计</code>，入门的书籍即为：<a href="https://book.douban.com/subject/30333944/">领域驱动设计精粹</a></p>
<hr />
<h2 id="综合运用"><a class="header" href="#综合运用">综合运用</a></h2>
<h3 id="新入职"><a class="header" href="#新入职">新入职</a></h3>
<p>新入职一家公司，应该做什么？是否学技术是最优先的？<strong>技术解决的是“怎么做”的问题，而我们第一个应该了解的问题是“做什么”</strong>。</p>
<p>优先级上应该是：业务、技术、团队运作。</p>
<ul>
<li>
<p><strong>业务</strong>：了解业务时，应该从<strong>大图景</strong>上来入手，自顶向下，开始不需要了解技术细节。不过在了解业务的过程中，可以思考这样的业务可能会采用什么样的架构与技术选型，带着自己的<strong>预判</strong>来看实际代码，就会更容易入手。</p>
</li>
<li>
<p><strong>技术</strong>：了解技术也一样，也需要从<strong>大图景</strong>入手，也即先 <code>宏观</code>，再 <code>微观</code>，宏观即先看架构、技术选型、使用的框架，以及为何这样决策等。然后再逐渐向下一步步的了解，最后才到代码层面。</p>
</li>
<li>
<p><strong>团队</strong>：团队动作包括当前产品开发各环节、各角色、各角色接口人、汇报关系、会议安排等等。</p>
</li>
</ul>
<h3 id="遗留系统"><a class="header" href="#遗留系统">遗留系统</a></h3>
<p>遗留代码是什么？遗留代码就是没有测试的代码。 -- 《修改代码的艺术》</p>
<p>遗留系统的烂代码只是表现，并不是根因。如果不分析原因直接进行重写/重构，可能仍然会走到烂代码的道路上。需要分析导致烂代码的，到底是设计问题，还是上个开发者对软件开发的基本原则都没掌握导致的。找到问题之后，再针对性的看如何解决，然后重写/重构时避开这些坑。</p>
<h3 id="保持竞争力"><a class="header" href="#保持竞争力">保持竞争力</a></h3>
<p>我们的焦虑来自于对未来的不确定性，而这种不确定性是一个特定时代加上特定行业的产物。</p>
<blockquote>
<p>上个世纪 80 年代之前，虽然当时的生活条件一般，但很少有人会为未来的发展焦虑，因为那时候，人们可以清晰地看到自己未来的人生，尽管那种人生可能是平淡的。</p>
</blockquote>
<p>怎么提升自己的竞争力呢？要努力让自己成为<strong>T 型人</strong>。所谓T 型人，就是一专多能的人。T中的竖是表示在一个点上能够非常深入，这个是竞争力的根基。其次T中的横表示努力扩展自己的视野，而且可以利用“一专”触类旁通，在“多能”上也有不错的见解。</p>
<p>要保持学习，避免自己处于 <code>舒适区</code>，舒适区中，人的成长是非常慢的。</p>
<hr />
<h2 id="结语-1"><a class="header" href="#结语-1">结语</a></h2>
<p>《10x 程序员工作法》，本质上是在讲如何有效工作。在算法优化中，**其实就是尽可能利用已知的信息，少做不必要的事。**在工作上，也应该如此，基于已有的信息，少做无效事情才能提高效率。</p>
<p>工作效率高，不是因为代码写得多，而是有效工作做得多。有效工作，需要我们把力量聚焦到正确的地方，做本质复杂度（Essential Complexity）的事情，少做无意义的事情。</p>
<p>要想有效工作，有两点非常重要。一、意识上要注意自己工作中无效的部分。二、要构建自己关于软件开发的知识体系。</p>
<hr />
<h2 id="资料-44"><a class="header" href="#资料-44">资料</a></h2>
<ul>
<li><a href="https://www.douban.com/doulist/113366760/">文章内提到的书籍</a></li>
<li><a href="http://t.cn/EGeYqfX">敏捷软件开发的基本定理</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript高级程序设计"><a class="header" href="#javascript高级程序设计">JavaScript高级程序设计</a></h1>
<p>[TOC]</p>
<h2 id="前提"><a class="header" href="#前提">前提</a></h2>
<h3 id="es标准"><a class="header" href="#es标准">ES标准</a></h3>
<p>ES5即ES3.1，于2009年12月3日正式发布。这几年基本维持了一年一个版本的节奏。</p>
<p>ECMAScript兼容是指：</p>
<blockquote>
<ol>
<li>支持ECMA-262的所有类型、值、对象、属性、函数以及程序句法和语义</li>
<li>支持Unicode字符标准</li>
</ol>
</blockquote>
<h3 id="dom-1"><a class="header" href="#dom-1">DOM</a></h3>
<p>DOM是针对HTML的应用程序编程接口。DOM产生的原因，是由于IE和Netscape在实现DHTML(Dynamic HTML)时，各持己见，实现不同，开发人员需要适配两个浏览器，就需要额外做一些工作。最终导致W3C来规划了DOM</p>
<p>DOM也是分级的，目前是分为3级：</p>
<ul>
<li>1级：由<code>DOM核心</code>和<code>DOM HTML</code>组成，DOM核心规定的是如何映射基于XML的文档结构。DOM HTML则在DOM核心的基础上添加了针对HTML的对象和方法</li>
<li>2级：新增了<code>DOOM视图</code>、<code>DOM事件</code>、<code>DOM样式</code>、<code>DOM遍历和范围</code></li>
<li>3级：支持XML 1.0规范，引入了统一方式加载和保存文档的方法，新增了验证文档的方法。</li>
</ul>
<p>DOM并不是针对JS的，很多基于XML的语言也实现了DOM，这些语言也添加了与语言相关的新方法和新接口：</p>
<ul>
<li>SVG (<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model#SVG_interfaces">DOM SVG接口</a>)</li>
<li>MathML</li>
<li>SMIL</li>
</ul>
<h3 id="bom-浏览器对象模型"><a class="header" href="#bom-浏览器对象模型">BOM (浏览器对象模型)</a></h3>
<p>使用BOM可以控制浏览器页面以外的部分。在H5之前，BOM没有标准，但H5中把很多BOM功能写入了正式规范：</p>
<ul>
<li>对cookies的支持</li>
<li>移动、缩放和关闭浏览器功能</li>
<li>提供浏览器各种信息的对象</li>
<li>……</li>
</ul>
<h3 id="script标签"><a class="header" href="#script标签">&lt;script&gt;标签</a></h3>
<p>在&lt;script&gt;标签中，除了有<code>type</code>属性外，还有几个可选属性</p>
<ul>
<li><strong>type</strong>：表明代码使用的脚本语言的内容类型，默认为<code>text/javascript</code>。这个属性是<code>language</code>的替代属性，<code>language</code>已经废弃</li>
<li><strong>src</strong>：引用的外部文件</li>
<li><strong>async</strong>：立即下载，但异步执行（页面渲染和js执行是同步的）</li>
<li><strong>defer</strong>：脚本可以延迟到文档完全解析和显示后再执行</li>
<li><strong>charset</strong>：通过src指定的字符集，很少使用</li>
<li><strong>crossorigin</strong>：配置相关请求的CORS设置</li>
<li><strong>integrity</strong>：通过对比收到的资源和指定的加密签名，来确保CDN不会提供恶意内容</li>
</ul>
<blockquote>
<p>有关async与defer的区别，详细参见：<a href="https://segmentfault.com/q/1010000000640869">defer和async的区别</a></p>
</blockquote>
<h3 id="脚本的加载及执行"><a class="header" href="#脚本的加载及执行">脚本的加载及执行</a></h3>
<ul>
<li>默认情况下，浏览器会按&lt;script&gt;出现的顺序依次解释它们，并且相互之间是串行的。</li>
<li>&lt;script&gt;标签内的代码会被从上到下解释，在&lt;script&gt;中的代码被计算完成之前，页面的其余内容不会被加载，也不会被显示。</li>
<li>如果&lt;script&gt;是引用的外部文件的代码，则在下载、解释JS代码时，会阻止页面剩余部分的加载显示。</li>
<li>如果在&lt;script&gt;中即使用了<code>src</code>引用外部js文件，又在标签体中包含了其他的JS代码，则浏览器仅会下载执行<code>src</code>指定的JS文件，而忽略标签体内嵌的JS代码。</li>
<li>过去喜欢把&lt;script&gt;放在&lt;head&gt;标签中声明，这样会导致一个问题，即页面的渲染需要等所有的JS代码下载、解释完成之后，才能开始渲染。比较好的方式是放在&lt;body&gt;标签之后。</li>
</ul>
<p>除此之外，也可以通过DOM API动态的加载脚本：</p>
<pre><code class="language-js">// 这种创建方式，默认将async属性设置为true了，也即异步方式加载的
let script = document.createElement('script');
script.src = 'demo.js';
document.head.appendChild(script);
</code></pre>
<p>​	</p>
<h2 id="js基础"><a class="header" href="#js基础">JS基础</a></h2>
<ul>
<li>大小写敏感</li>
<li>ES5中增加了严格模式，即在脚本开头添加<code>&quot;use strict&quot;</code>。严格模式是为了限制ES3中的一些不规范写法(<a href="https://www.runoob.com/js/js-strict.html">JavaScript 严格模式</a>)</li>
<li>JS可以省略分号，但应优先使用分号</li>
<li>支持<code>标签函数</code>，使用参考：<a href="https://zhuanlan.zhihu.com/p/31687266">ES6 - 标签函数</a></li>
</ul>
<h3 id="var与let区别"><a class="header" href="#var与let区别"><code>var</code>与<code>let</code>区别</a></h3>
<table><thead><tr><th>var</th><th>let</th></tr></thead><tbody>
<tr><td>声明的变量存在<code>提升</code>，会将变量声明移至作用域的顶部，并且默认赋值为<code>undefined</code></td><td>不提升</td></tr>
<tr><td>声明的作用域是函数作用域</td><td>作用域是块作用域(即在if体里声明，只会在该if体中有效)</td></tr>
<tr><td><code>var</code>声明的变量由于会提升，JS引擎会将多余的声明在作用域顶部合并</td><td><code>let</code>不会</td></tr>
<tr><td>声明变量可以省略<code>var</code>关键字，并且变量会变为全局变量</td><td>使用前必须声明</td></tr>
<tr><td>可以重复用var声明同名的变量</td><td>只能声明一次，再用<code>let</code>声明同名变量就会出错</td></tr>
<tr><td>声明为全局作用域的变量，会成为<code>window</code>对象的属性</td><td><code>let</code>不会</td></tr>
</tbody></table>
<blockquote>
<p>在实际使用中，要<code>const</code>优先，其次<code>let</code>，不使用<code>var</code></p>
</blockquote>
<h3 id="类型相关"><a class="header" href="#类型相关">类型相关</a></h3>
<ul>
<li><code>Undefined</code>类型只有一个值，就是<code>undefined</code>。声明的变量没有初始化，就是给的这个值</li>
<li><code>typeof</code>未声明的变量，也会返回&quot;undefined&quot;</li>
<li><code>Null</code>类型也只有一个值，即<code>null</code>。<code>null</code>表示一个空对象指针</li>
<li><code>typeof null</code>，会返回&quot;object&quot;，原因是<code>null</code>被认为是一个对空对象的引用 (由于上面一点原因产生)</li>
<li><code>undefined</code>值由<code>null</code>值派生出来，所以<code>null == undefined</code>会返回true</li>
<li>在if控制流语句中，会自动将其它类型的值转为Boolean类型。仅<code>&quot;&quot;</code>、<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code>少数几种情况转换为<code>false</code>，其它情况都会转为<code>true</code></li>
<li><code>console.log(0.1 + 0.2);</code>得出的结果是：<code>0.30000000000000004</code>，原因是浮点数计算中微小的舍入导致的（并非JS所独有，使用了<code>IEEE 754</code>数值表示就会存在这种问题）</li>
<li>JS中用0除任意数不会导致错误，但结果需要注意：<code>0 / 0 == NaN</code>、<code>5 / 0 == Infinity</code></li>
<li>任何涉及<code>NaN</code>的操作始终返回<code>NaN</code> （<code>NaN</code>表示<code>Not a Number</code>）</li>
<li><code>一元加操作符</code>与<code>Number()</code>函数遵循相同的转换规则。<code>+&quot;&quot;</code>为0，<code>+&quot;a&quot;</code>为<code>NaN</code>、<code>+true</code>为1</li>
<li><code>Number()</code>与<code>parseInt()</code>转换规则是不同的，<code>parseInt(&quot;10x&quot;)</code>得到的结果是<code>10</code>（<code>Number(&quot;10x&quot;)</code>返回的结果为<code>NaN</code>），原因是<code>parseInt()</code>识别字符串首字符是否是数值，如果是，则遍历到第一个不是字符串的地方，然后进行转换 (<code>paseInt()</code>专注于字符串转换)</li>
</ul>
<h4 id="symbol类型"><a class="header" href="#symbol类型"><code>Symbol</code>类型</a></h4>
<p><code>Symbol</code>类型的作用，一句话概括就是生成<code>全局唯一值</code>。详情参考：<a href="https://zhuanlan.zhihu.com/p/22652486">JS 中的 Symbol 是什么？</a></p>
<p>在如下场景都可以使用<code>Symbol</code>：</p>
<ul>
<li>枚举场景。</li>
</ul>
<pre><code class="language-js">var enumType = {
  // 具体值不被关心，但要表示唯一
  tag1: Symbol(),
  tag2: Symbol()
}
</code></pre>
<ul>
<li>作为Map的<code>key</code></li>
</ul>
<pre><code class="language-js">// 如果创建了Symbol，但没有引用它，则后续就比较难以找到它
let s1 = Symbol();
let o = {[s1]: 'foo'};
</code></pre>
<ul>
<li>用来判断一个实例是否是某对象的实例</li>
</ul>
<pre><code class="language-js">class Bar {}
let b = new Bar();

// 下面两句是等价的
console.log(b instanceof Bar);	// true
console.log(Bar[Symbol.hasInstance](b));	// true
</code></pre>
<p>除此之外，还有<code>Symbol.isConcatSpreadable</code>、<code>Symbol.iterator</code>、<code>Symbol.match</code>等内置符号，用来暴露语言内部行为，可供开发者访问、重写或模拟这些行为</p>
<h3 id="操作符"><a class="header" href="#操作符">操作符</a></h3>
<h4 id="位操作符"><a class="header" href="#位操作符">位操作符</a></h4>
<p><code>位操作符</code>即指二进制bit上的操作</p>
<p><code>位操作符</code>使用时需要注意，特殊值<code>NaN</code>和<code>Infinity</code>在位操作中都会被当成0来处理：</p>
<pre><code class="language-js">const a = Number(&quot;ff1&quot;);
const r = ~a;
console.log(r);	// 会输出-1
</code></pre>
<p>在JS中，除了<code>有符号右移</code>，用<code>&gt;&gt;</code>来表示，还存在<code>无符号右移</code>，用<code>&gt;&gt;&gt;</code>来表示。<code>无符号右移</code>在移动时，会给空位补0</p>
<p><code>逻辑非</code>操作符<code>!</code>可以应用在任意数据上，在对数据进行操作时，也是先转为布尔值，再取反。其中转为布尔值的过程，与在if控制流语句中的默认转换是一样的，即：仅<code>&quot;&quot;</code>、<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code>少数几种情况转换为<code>false</code>，其它情况都会转为<code>true</code></p>
<p><strong><code>逻辑与</code>操作符<code>&amp;&amp;</code>并不一定会返回布尔值</strong>，而是遵循如下规则：（<code>逻辑与</code>操作符与此类似）</p>
<ul>
<li>
<p>第一个操作数是对象时，则返回第二个操作数</p>
</li>
<li>
<p>第一个操作数可以隐式转为<code>true</code>时，则返回第二个操作数</p>
</li>
<li>
<p>第一个操作数隐式转换结果为<code>false</code>时，就返回第一个操作数</p>
</li>
</ul>
<p><strong><font color=red>注意：这儿的规则书上的内容讲错了！</font></strong></p>
<p>书上给的规则中说：如果有一个操作数是<code>null</code>、<code>NaN</code>、<code>undefined</code>中的一种，则返回值就是对应的<code>null</code>、<code>NaN</code>、<code>undefined</code>。但真实的测试情况不同：</p>
<pre><code class="language-js">class Bar {}
let b = new Bar();
let r = 0 &amp;&amp; NaN;

// 此时按书上的结论，应该会输出&quot;NaN&quot;，其实结果是：0
console.log(r);	// 这儿理解上，应该用上面列三条规则来看，这样理解是最简单的，而且是正确的
</code></pre>
<p>​	</p>
<h4 id="乘性操作符"><a class="header" href="#乘性操作符">乘性操作符</a></h4>
<p><code>乘性操作符</code>指的<code>乘</code>、<code>除</code>、<code>取模</code></p>
<ul>
<li>有任一操作数是<code>NaN</code>时，则返回<code>NaN</code></li>
<li><code>Infinity</code>与<code>0</code>相乘时，结果为<code>NaN</code></li>
<li><code>Infinity</code>与<code>非0</code>值相乘时，依第二个操作符的符号来决定返回<code>Infinity</code>或<code>-Infinity</code></li>
<li><code>Infinity</code>与<code>Infinity</code>相除或<code>0</code>与<code>0</code>相除，返回<code>NaN</code></li>
<li><code>非0</code>除<code>0</code>，返回<code>Infinity</code></li>
</ul>
<h4 id="其它操作符"><a class="header" href="#其它操作符">其它操作符</a></h4>
<ul>
<li>加法操作符的任意操作数是字符串时，另外一个操作数都会转为string再拼接</li>
<li><code>-0 + -0 == -0</code></li>
<li>js中除了有<code>==</code>和<code>!=</code>，还有<code>===</code>和<code>!==</code>，后面这个被称为<code>全等</code>和<code>不全等</code>。<code>全等</code>表示在操作数不转换的前提下相等才返回<code>true</code></li>
<li><code>逗号操作符</code>可以返回表达式的最后一个值。<code>let num = (5, 4, 3, 2, 1);</code>执行后的结果，num为<code>1</code></li>
</ul>
<h3 id="语句"><a class="header" href="#语句">语句</a></h3>
<ul>
<li>js中的<code>for-in</code>语句，用来枚举对象中的非符号键属性。<code>for-of</code>语句用来遍历可迭代对象的元素</li>
<li>js支持标签语句，典型场景是在嵌套循环中使用。使用参考：<a href="https://www.jianshu.com/p/13d48d4edbc4">JS 标签语句和 classList</a>中的标签语句部分</li>
<li>为了精简代码，js中支持<code>with</code>语句，但在<code>严格模式</code>下是禁用的，原因是影响性能且难以调试。使用参考：<a href="https://swordair.com/javascript-with-statement-in-depth/">深入JavaScript with语句</a></li>
</ul>
<h3 id="函数"><a class="header" href="#函数">函数</a></h3>
<ul>
<li>js中函数是一等公民，所以js可以方便的支持函数式编程</li>
<li>函数是就是对象，<code>function</code>是继承自<code>object</code>的</li>
<li>严格模式中，函数不能以<code>eval</code>及<code>arguments</code>作为名称以及参数名</li>
</ul>
<h2 id="变量作用域与内存"><a class="header" href="#变量作用域与内存">变量、作用域与内存</a></h2>
<p>JS中数据类型分<code>原始值</code>与<code>引用值</code>两种类型，除了<code>Object</code>是<code>引用值</code>外，其它都是<code>原始值</code>（包括字符串也是<code>原始值</code>）</p>
<h3 id="原始值与引用值特性"><a class="header" href="#原始值与引用值特性">原始值与引用值特性</a></h3>
<ul>
<li><code>引用值</code>可以随时增、删、改其属性和方法，但<code>原始值</code>不行。给<code>原始值</code>添加属性虽然运行时不会报错，但尝试读取该属性值仍然为<code>undefined</code></li>
<li>如果用new来初始化一个原始值，则实际上就是创建的一个对象。<code>let name = new String(&quot;Matt&quot;);</code>此时name的类型就会是<code>object</code></li>
<li>引用值再赋值时，是浅拷贝</li>
</ul>
<h3 id="作用域"><a class="header" href="#作用域">作用域</a></h3>
<ul>
<li>在浏览器环境下，全局上下文一般是<code>window</code>对象，通过var定义的全局变量或函数，都会成为<code>window</code>对象的属性和方法。(通过let和const定义的全局变量不会存储在<code>window</code>对象上)</li>
<li>在node.js环境下，全局变量是<code>global</code>对象，但在node.js环境下通过var定义的全局变量并不会成为<code>global</code>对象的属性</li>
<li>使用<code>var</code>定义的变量，会被添加到最接近的上下文中，比如<code>with</code>语句中使用<code>var</code>定义的变量，作用域就是函数上下文。但<code>let</code>的作用域是<code>块级作用域</code>，由最近的一对花括号<code>{}</code>内界定。</li>
</ul>
<p>通过<code>const</code>声明的变量，不能被重新赋值。但<code>const</code>对象的键仍然可以修改，如：<code>const o = {}; o.name = 'a';</code>。</p>
<p>如果想让整个对象都不能被修改，可以用<code>Object.freeze()</code>来初始化对象：</p>
<pre><code class="language-js">const o = Object.freeze({});
o.name = 'a';
// 不会出错，但是静默失败
console.log(o.name);	// undefined
</code></pre>
<h3 id="垃圾回收"><a class="header" href="#垃圾回收">垃圾回收</a></h3>
<p>JS是<code>自动内存管理</code>，垃圾回收程序每隔一定时间就会自动运行，确定哪些变量不会再使用，然后释放它。如何标记未使用的变量，有两种主要的策略：<code>标记清理</code>和<code>引用计数</code>。</p>
<p><code>标记清理</code>即通过给对象加标识的方式来识别对象是否有在使用，这种方案使用的较多。<code>引用计数</code>是记录每个对象的引用次数，当次数为0时释放。但<code>引用计数</code>的方案很容易导致循环引用，从而出现内存泄露。</p>
<blockquote>
<p>垃圾回收程序运行时，会对性能产生一定的影响，各种JS引擎启动回收程序的策略也不一样。</p>
<p>部分浏览器提供了主动回收内存的方式，但并不推荐主动触发。</p>
</blockquote>
<h4 id="优化内存方式"><a class="header" href="#优化内存方式">优化内存方式</a></h4>
<ul>
<li>将内存占用量保持在一个较小的值，可以让页面性能更好。开发者可以通过将不再使用的数据<strong>主动设置为null</strong>来<code>解除引用</code>，以降低内存的占用量。主动设置为null的操作对全局变量和和全局对象的属性来说是更加适合的。</li>
<li>通过<code>const</code>和<code>let</code>提升性能。因这这两个关键字声明的对象都是块级作用域，可以更早地让垃圾回收程序回收不需要的变量。</li>
<li>避免内存泄露，如尽量不要将对象存到<code>window</code>属性中，对象不要被timer或闭包长时间引用等。</li>
<li>针对<code>V8</code>引擎针对性的优化代码。比如<code>V8</code>中因为隐藏类的存在，尽量让多个实例共享相同的隐藏类可以提升性能。要做到这一点，就尽量在构造函数中提前创建好各属性，不要动态的添加/删除属性。</li>
<li>减少垃圾回收程序运行次数来提升性能。如通过自己管理<code>对象池</code>来影响回收程序的策略、频繁创建、回收的对象可以想办法使其少创建等。</li>
</ul>
<h2 id="迭代器与生成器"><a class="header" href="#迭代器与生成器">迭代器与生成器</a></h2>
<h3 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h3>
<p>任何实现<code>Iterator</code>接口的对象都可以作为迭代器使用。迭代器是仅使用游标来来记录遍历可迭代对象的历程。</p>
<p>提前终止迭代器时，也可以通过添加<code>retrun()</code>方法指定迭代器提前关闭时的执行逻辑。</p>
<h3 id="生成器-es6"><a class="header" href="#生成器-es6">生成器 (ES6)</a></h3>
<p>生成器可以让一个函数块内拥有暂停和恢复代码执行的能力。简单来说，它是对<code>协程</code>的支持。（ES7又提供了<code>async</code>、<code>await</code>来进一步简化使用）</p>
<p>生成器的声明方式为: </p>
<pre><code class="language-js">fuction *generatorFn()

class Foo {
  * generatorFn() {}
}
</code></pre>
<p>生成器特性：</p>
<ul>
<li>调用生成器函数，会生产一个<code>生成器对象</code>，并且开始是处于<code>暂停执行</code>的状态。</li>
<li>生成器对象也实现了<code>Iterator</code>接口，当调用该接口的<code>next()</code>方法后，就可以恢复执行。(同样可以通过<code>for-of</code>来遍历生成器对象)</li>
<li>生成器函数既然是一个迭代器，那么就是可以被迭代的。迭代的中间状态，通过<code>yield</code>关键字来标识。</li>
<li><code>yield</code>关键字只能在生成器函数内部使用，出现在嵌套的非生成器函数中会有语法错误。</li>
<li><code>yield *</code> 可以用来增强<code>yield</code>的行为，返回值可以返回一个可迭代对象并参与迭代。(如数组、甚至自身，可以使用<code>yield *</code> 来实现递归)</li>
</ul>
<p>使用<code>yield</code>实现输入：</p>
<pre><code class="language-js">fuction *generatorFn(v) {
  console.log(v);
  console.log(yield);
}

let g = generatorFn('foo');
g.next('bar');	// 仍然输出：foo，原因是首次调用next()只是用来执行生成器函数
g.next('baz');	// 输出：baz
</code></pre>
<h2 id="对象继承与类"><a class="header" href="#对象继承与类">对象、继承与类</a></h2>
<h3 id="对象"><a class="header" href="#对象">对象</a></h3>
<h4 id="属性"><a class="header" href="#属性">属性</a></h4>
<p>对象的属性分为两种：<code>数据属性</code>和<code>访问器属性</code></p>
<p><strong>数据属性</strong>的类型有如下几种：</p>
<ul>
<li><code>Configurable</code>: 表示属性是否可以通过delete删除并重新定义/是否可以修改它的特性</li>
<li><code>Enumerable</code>: 该属性是否可以通过<code>for-in</code>返回</li>
<li><code>Writable</code>: 属性值是否可以被修改</li>
<li><code>Value</code>: 实际的存储值</li>
</ul>
<p>如果要修改属性的默认特性，需要通过<code>Object.defineProperty()</code>来修改：</p>
<pre><code class="language-js">let person = {};
Object.defineProperty(person, &quot;name&quot;, {
  writable: false,
  value: &quot;Nicholas&quot;
});
person.name = &quot;Greg&quot;;	// 在非严格模式下不生效，严格模式下会出错
</code></pre>
<p><strong>访问器属性</strong>类型有如下几种：</p>
<ul>
<li><code>Configuable</code>: 同<code>数据属性</code>的含义</li>
<li><code>Enumerable</code>: 同<code>数据属性</code>的含义</li>
<li><code>Get</code>: 获取函数，在读取属性时调用</li>
<li><code>Set</code>: 设置函数，在写入属性时调用</li>
</ul>
<p><code>Get</code>和<code>Set</code>使用：</p>
<pre><code class="language-js">let person = {
  age_: 15	// 以 _ 结尾表示私有变量
};
Object.defineProperty(person, &quot;age&quot;, {
  get() {
    return this.age_;
  }
  set(newValue) {
  	this.age_ = newValue;
	}
});
</code></pre>
<p>属性相关其它特性:</p>
<ul>
<li>
<p><code>Object.defineProperty()</code>也可以一次设置或修改多个属性</p>
</li>
<li>
<p><code>Object.getOwnPropertyDescriptor()</code>可以读取属性，返回值是一个对象，里面包含<code>value</code>、<code>configurable</code>等值</p>
</li>
<li>
<p>对象可以通过<code>Object.assign()</code>来进行合并(自有属性和<code>Enumerable</code>为true的属性)</p>
</li>
</ul>
<h4 id="相等判断"><a class="header" href="#相等判断">相等判断</a></h4>
<p>对象间相等判定需要关注的点：</p>
<ul>
<li><code>{} === {}</code>，结果是<code>false</code></li>
<li><code>+0 === -0</code> 为 <code>true</code>；但 <code>Object.is(+0, -0)</code> 结果为<code>false</code></li>
<li><code>NaN === NaN</code> 为 <code>false</code>；<code>isNaN(NaN)</code> 为 <code>true</code>；<code>Ojbect.is(NaN, NaN)</code> 为 <code>true</code></li>
</ul>
<h4 id="es6语法糖"><a class="header" href="#es6语法糖">ES6语法糖</a></h4>
<p>支持属性简写:</p>
<pre><code class="language-js">let name = 'Matt';
let person = {
  name	// 这儿无须写成：name: name
};
console.log(person);	// 输出：{name: 'Matt'}
</code></pre>
<p>支持属性名动态生成：</p>
<pre><code class="language-js">const name = 'name';
let person = {
  [name + 'Key']: 'Matt'
}
console.log(person);	// {nameKey: 'Matt'}
</code></pre>
<p>支持方法名简写：</p>
<pre><code class="language-js">let person = {
  sayName(name) {	// 无须写成：sayName: function(name)
		// some code
  }
}
</code></pre>
<p>支持对象解构：</p>
<pre><code class="language-js">let person = {
  name: 'Matt',
  age: 27,
  job: {
  	title: 'engineer'
	}
};
let {name, age} = person;	// 或：let {name: personName} = person; 此时变量名为personName
console.log(name);	// Matt

// 对象解构支持默认值
let {name='David'} = person;

// 也支持嵌套解构
let {job: {title}} = person;
console.log(title);	// engineer

// 函数参数也可以直接使用解构语法
function printPerson(foo, {name, age}) {
  // some code
}
printPerson('1st', person);
</code></pre>
<blockquote>
<p>在解构过程中出错的话，到出错的位置就会结束，后续的解构就不再执行了</p>
</blockquote>
<h3 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h3>
<p>ES6中的类，也仅是封装了ES5.1的构造函数加原型继承的语法糖。</p>
<p>JS构造函数的使用：（与普通函数的区别就在于调用方式不同）</p>
<pre><code class="language-js">// 定义一个大写开头的函数名，内部使用this.来给属性赋值即可 (大写开头是惯例)
function Person(name, age) {
    this.name = name;
    this.age = age;	
  	// 最后无须return
}
let person = new Person('Matt', 35);	// 这儿使用new来创建对象
console.log(person);
</code></pre>
<p>对象实例中都有一个constructor属性，会指向对象：</p>
<pre><code class="language-js">console.log(person.constructor == Person);	// 返回true
</code></pre>
<p>构造函数也存在一些问题，即对象的方法在每个实例上都会被重新创建一遍</p>
<pre><code class="language-js">function Person(name, age) {
    this.name = name;
    this.sayName = function() {
      console.log(this.name);
    }
}
let person1 = new Person('Matt1');
let person2 = new Person('Matt2');
// 之所以返回false，是因为创建person1和person2时，分别创建了两个sayName函数对象
console.log(person1.sayName == person2.sayName);	// false
</code></pre>
<h3 id="原型"><a class="header" href="#原型">原型</a></h3>
<p>原型是理解JS对象非常关键的信息。</p>
<p>只要定义一个函数，就会按照特定规则为这个函数创建一个prototype属性。</p>
<pre><code class="language-js">function Person(name) {
    this.name = name
}
console.log(Person.prototype)	// Person {}
</code></pre>
<p>前面说的通过构造函数创建对象函数存在的问题，可以通过prototype属性来解决。通过prototype定义的属性和方法会被对象实例共享：</p>
<pre><code class="language-js">function Person(name, age) {
    this.name = name;
}
Person.prototype.sayName = function() {
  console.log(this.name);
}
let person1 = new Person('Matt1');
let person2 = new Person('Matt2');
console.log(person1.sayName == person2.sayName);	// true
</code></pre>
<blockquote>
<p>原型的设置也可以通过<code>字典</code>一次性设置多个属性或方法</p>
</blockquote>
<p>对象创建的实例，可以通过 <code>__proto__</code>(图中<code>[[Prototype]]</code>) 链接到原型对象。整体关系如下图所表示：</p>
<p><img src="Note/./images/js_prototype.jpeg" alt="prototype" /></p>
<p>如果某些实现没有将属性的<code>[[ProtoType]]</code>暴露出来，则可以通过<code>isPrototypeOf()</code>方法来判断某些实例是否指向某原型：<code>Person.prototype.isPrototypeOf(person1)</code></p>
<p>在调用某个实例的属性或方法时，会产生两级搜索：</p>
<ul>
<li>先看实例是否有该属性</li>
<li>如果实例没有，则看原型是否有该属性</li>
</ul>
<p>所以如果在原型和实例中同时定义了属性，则会优先使用实例中的。</p>
<p><code>in</code>操作符，有两种用途：</p>
<ul>
<li>判断某个属性是否可以访问到：<code>&quot;name&quot; in person</code> 即判断person中是否有name属性</li>
<li>通过<code>for-in</code>枚举所有属性 </li>
</ul>
<blockquote>
<p>实例的<code>hasOwnProperty()</code>仅可以判断属性是否声明在类中，不会判断是否在原型中</p>
</blockquote>
<p>除了<code>for-in</code>可以用来枚举属性外，还有其它4种方式可以枚举，它们的枚举顺序是有差异的：</p>
<ul>
<li><code>for-in</code>、<code>Object.keys()</code> 顺序是不确定的，跟实现有关系</li>
<li><code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>、<code>Object.assign()</code> 是按升序枚举数值、字符串和符号键</li>
</ul>
<p>原型使用时需要注意：如果在实例上共享包含引用值的属性，则相当于是个静态变量，任何实例对引用值的修改都可能影响到其它实例。</p>
<h3 id="继承-2"><a class="header" href="#继承-2">继承</a></h3>
<p>继承就是通过修改原型链来实现的。子类原型不再指向子类构造函数，而是指向父类原型，以此来继承父类的属性和方法。</p>
<p>原型链的关系如下：</p>
<p><img src="Note/./images/js_inherit.jpeg" alt="inherit" /></p>
<blockquote>
<p>实际上，所有对象都是默认是从<code>Object</code>继承的</p>
</blockquote>
<p>除了原型链继承，还有一些其它继承方式：</p>
<ul>
<li><strong>盗用构造函数</strong>：为了解决原型中<code>属性共享</code>和<code>父类构造函数无法传参</code>的问题，有一种叫的实现方案，思路就是在子类构造函数中调用父类的构造函数。</li>
<li><strong>组合继承</strong>：结合 <code>盗用构造函数</code> 和 <code>原型链继承</code></li>
<li><strong>寄生式继承</strong>：通过在原型链中添加一层包装类来实现</li>
<li><strong>寄生组合继承</strong>：被认为是最有效的类型继承方式</li>
</ul>
<p>几种继承的详细解释也可以参考：<a href="https://segmentfault.com/a/1190000037433126">ES5继承</a></p>
<h3 id="类"><a class="header" href="#类">类</a></h3>
<p>在ES5中实现继承相对都比较繁琐，而且各有各的问题。在ES6中为了解决这些问题增加了<code>class</code>关键字，不过其仍然是一层语法糖，实际实现上仍然是用的<code>原型链</code>和<code>构造函数</code>的概念。</p>
<p>判断一个class的类型时，仍然会返回<code>function</code>：</p>
<pre><code class="language-js">class Person {
}
console.log(typeof Person);	// function
</code></pre>
<p>但在使用上，JS的类与其它面向对象语言的类并没有多少差别，比如支持<code>继承</code>、支持使用<code>static</code>成员等。不过因为基于<code>原型链</code>来实现，它也有一些自己的独特的地方。比如：支持定义一个类的同时去创建一个实例、支持<code>mixin</code>等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="许式伟的架构课"><a class="header" href="#许式伟的架构课">许式伟的架构课</a></h1>
<p>软件工程是一项非常复杂的系统工程，它需要依赖一个能够掌控整个工程全局的团队（或个人），来规划和引导整个系统的演变过程。</p>
<p>如何才能掌控全局？核心在于对知识脉络的体系化梳理。</p>
<p>掌控全局的前提是：在自己心中去重新构建出整个世界。在这个过程中，你不需要一上来沉浸在某个技术的实现细节（除非它影响了你对这个世界构建过程的理解），但是你知道整个世界的脉络，知道整个世界的骨架。</p>
<p>架构关乎的是整个复杂的软件工程，它关乎实现它的人，它又因团队的能力而异。</p>
<p>架构不仅仅是个纯技术的工作。还要仔细思考业务，基于业务拆解任务，预测业务可能变化的点。</p>
<p>预测什么不会发生最为重要，只有做到这一点，才能真正防止架构的过度设计。</p>
<h3 id="架构步骤"><a class="header" href="#架构步骤">架构步骤</a></h3>
<ul>
<li>需求分析</li>
<li>概要设计</li>
<li>详细设计</li>
</ul>
<h3 id="需求分析"><a class="header" href="#需求分析">需求分析</a></h3>
<p>步骤：</p>
<ul>
<li>梳理清楚需求所有定义</li>
<li>定义需求边界</li>
<li>架构设计。拆分子系统、对需求进行归纳与抽象，以及防止过度设计等。</li>
</ul>
<p>在做需求分析时，需要刨根问底，找到根源性需求。</p>
<p>产品是桥，一端连接了用户需求，一端连接了先进的技术。所以产品定义跟技术也是有关系的。</p>
<h3 id="系统的概要设计"><a class="header" href="#系统的概要设计">系统的概要设计</a></h3>
<p>架构分类：业务架构、基础架构</p>
<p>基础架构的能力，考验的是选择能力。背后靠的是技术前瞻性和判断力。这并不简单。大部分架构师往往更容易把关注点放到业务架构上，但实际上基础架构的影响面更广，选错产生的代价更高。（架构师能力差距很大程度是在这一块）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="领域驱动设计精粹"><a class="header" href="#领域驱动设计精粹">领域驱动设计精粹</a></h1>
<p>书籍：<a href="https://book.douban.com/subject/30333944/">领域驱动设计精粹</a></p>
<h2 id="前言-2"><a class="header" href="#前言-2">前言</a></h2>
<p>这本书是<a href="https://book.douban.com/subject/25844633/">《实现领域驱动设计》</a>的精简版。内容上偏高层次的战略设计。</p>
<p><code>建模</code> 是<code>DDD</code>的基础概念</p>
<h2 id="ddd对我而言"><a class="header" href="#ddd对我而言">DDD对我而言</a></h2>
<h3 id="优秀设计糟糕设计和有效设计"><a class="header" href="#优秀设计糟糕设计和有效设计">优秀设计、糟糕设计和有效设计</a></h3>
<h2 id="其它-12"><a class="header" href="#其它-12">其它</a></h2>
<p>目前</p>
<p><code>DDD</code>的核心就是将业务架构映射到系统架构上，在业务变化调整时，对应的系统架构也做调整。</p>
<p>领域驱动设计包括战略建模和战术建模: 战略设计侧重于高层次、宏观上去划分和集成限界上下文，而战术设计则关注更具体使用建模工具来细化上下文。</p>
<p><strong>领域</strong>即问题域，<strong>子域</strong>即是将大的领域拆分之后的问题域。</p>
<p>子域又分三类：核心域、支撑域、通用域。</p>
<p>为了准确地沟通，我们需要统一语言的边界，在相同的语言边界内沟通，才不容易出差错。</p>
<h2 id="资料-45"><a class="header" href="#资料-45">资料</a></h2>
<p><a href="https://medium.com/doflowy/%E4%BB%80%E9%BA%BC%E6%98%AFscrum-%E4%B8%8D%E6%98%AF%E5%B7%A5%E7%A8%8B%E5%B8%AB%E4%B9%9F%E8%83%BD%E6%87%82%E7%9A%84scrum%E5%85%A5%E9%96%80%E6%95%99%E5%AD%B8-1cc6683575f8">什麼是Scrum？不是工程師也能懂的<strong>Scrum</strong>入門介紹！</a></p>
<p><a href="https://mp.weixin.qq.com/s/MHL9FJFjWHqtWL9I_zKmTw">走向卓越，领域驱动设计的思维方式</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件设计之美"><a class="header" href="#软件设计之美">软件设计之美</a></h1>
<p>来源：<a href="https://time.geekbang.org/column/intro/100052601">软件设计之美(极客时间)</a></p>
<p>[TOC]</p>
<h2 id="前言-3"><a class="header" href="#前言-3">前言</a></h2>
<p>软件设计的目的是什么？ 一句话概括就是：<strong>为了让软件在长期演进中更容易适应变化。</strong></p>
<p>而且随着现在这个时代的发展，变化也是越来越迅速的，很多产品也不再满足于被动去适应变化，而是主动寻求改变。这种情况下，对设计及架构的能力要求也越来越高。</p>
<p>软件设计跟算法也有一定的共同性。算法的优劣，在一定数据规模下才有差别。而设计的优劣，也往往是在不同的需求规模下展现差异，而且随着规模增加及变化，软件灵活性就会出现天壤之别。算法和设计二者对抗的都是规模问题，算法对抗的是数据的规模，而软件设计对抗的是需求的规模。<strong>软件设计，实际上就是应对需求的“算法”。</strong></p>
<p>软件设计学习的难度，不在于一招一式，而在于融会贯通。</p>
<blockquote>
<p>笔记并没有完全按照原课程来划分目录，而是简单聚合了一下，分为了基础知识、编程工具、设计原则、实战四部分</p>
<p>课程中也讲了一些领域驱动设计、函数式编程的内容，目前没有做相应的记录，后续会以其它课程笔记的形式展开来分享。</p>
</blockquote>
<h2 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h2>
<p>软件最核心的三个部分：模型、接口和实现。</p>
<p>规范是软件设计中很重要的点，它可以约束软件的发展，在其长期的演化中保持有序。</p>
<h3 id="分离关注点"><a class="header" href="#分离关注点">分离关注点</a></h3>
<p>所谓分离关注点，即把<strong>引起变化的部分隔离开</strong>，能够做到变化只影响其中一个模块，而对其它模块不会产生任何影响。分离关注点也是《程序员修炼之道》中的提到的满足 <strong>正交性</strong> 的一种实践。</p>
<p>要满足<strong>正交性</strong>，任务分解是非常重要的，其中颗粒度是需要仔细思考的。如果颗粒度过大，就会让不同的东西混淆在一起，从而导致一些简单修改，引起系统发生剧烈的抖动。</p>
<p>还有一点就是意识到<strong>业务问题</strong>和<strong>技术方案</strong>的区分。当业务层的东西和技术层的东西分不清的时候，就很容易导致后续系统维护非常困难。比如有些情况下在业务层面加一些策略来解决技术层面存在的问题，虽然可以临时解决，但长期来看带来的维护成本会越来越大。</p>
<blockquote>
<p>程序员最常犯的错误就是认为所有问题都是技术问题，总是试图用技术解决所有问题。任何试图用技术去解决其他关注点的问题，只能是陷入焦油坑之中，越挣扎，陷得越深。</p>
</blockquote>
<p>在数据处理上，也需要敏感的意识到某些处理逻辑是需要分开。比如读写分离、高频低频分离等等。</p>
<h3 id="可测试性"><a class="header" href="#可测试性">可测试性</a></h3>
<p>我们要保证每个小模块的正确性，就要保证每个模块在开发阶段能够测试，而想要每个模块能够测试，在设计过程中，就要保证每个模块是可以测试的，而这就是可测试性。</p>
<blockquote>
<p>就和盖楼是一个道理，不保证钢筋、水泥、砖土质量合格，却想要盖出合格的大楼来。</p>
</blockquote>
<p>从可测试性角度来看，<code>单例模式</code>并不是一种好的设计模式。</p>
<h3 id="如何了解一个软件的设计"><a class="header" href="#如何了解一个软件的设计">如何了解一个软件的设计</a></h3>
<p>如果要了解一个软件的设计，切记不要直接深入源码。而是可以从三个部分着手：<code>模型</code>、<code>接口</code>和<code>实现</code>：</p>
<ul>
<li>模型：先看各种类以及各类间的关系</li>
<li>接口：看具体的类有哪些方法</li>
<li>实现：看具体方法的实现</li>
</ul>
<p>了解的顺序也应该是按模型 -&gt; 接口 -&gt; 实现</p>
<h4 id="模型"><a class="header" href="#模型">模型</a></h4>
<p>我们不仅要知道一个设计的结果，最好还要推断出设计的动因。</p>
<p>只有理解了模型设计的来龙去脉，清楚认识到它在解决的问题，才能更好地运用这个模型去解决后面遇到的问题</p>
<h4 id="接口"><a class="header" href="#接口">接口</a></h4>
<p>如何分析一个软件的接口呢？<strong>找主线，看风格</strong></p>
<p>我们常把编程视为一种艺术，而在接口的设计上就能窥见一二。</p>
<p>找到项目主线的一个方法就是从起步走文档开始，因为它会把项目最基本的用法展现给你，你可以轻松地找到主线。</p>
<h4 id="实现"><a class="header" href="#实现">实现</a></h4>
<p>要分析一个软件的实现，最重要的是找到 <strong>软件结构和关键技术</strong></p>
<h2 id="编程工具"><a class="header" href="#编程工具">编程工具</a></h2>
<h3 id="编程语言"><a class="header" href="#编程语言">编程语言</a></h3>
<p>&quot;每年至少学习一门新语言。&quot; --- 《程序员修炼之道》</p>
<blockquote>
<p>学习程序设计语言其实就是要学习语言提供的编程模型。不提供新编程模型的语言是不值得刻意学习的。</p>
</blockquote>
<p>一旦对于程序设计语言的模型有了新的认识，你就能理解一件事：一切语法都是语法糖。比如：类型是对内存的解释方式；class是数据组织方式。</p>
<p>“语言设计就是程序库设计”和“程序库设计就是语言设计”。语法和程序库是在解决同一个问题，二者之间是相互促进的关系。某些好用的程序库也会随着语言的发展，而变成语言的语法。</p>
<p>做设计真正的地基，并不是程序设计语言，而是 <strong>运行时</strong>，有了对于运行时的理解，我们甚至可以做出语言本身不支持的设计。运行时即程序是如何运行的。</p>
<h3 id="编程范式"><a class="header" href="#编程范式">编程范式</a></h3>
<p>现在主流的三种编程范式：结构化编程（面向过程）、面向对象、函数式编程</p>
<p>用面向对象语言，仍然可能写出的是面向过程的代码。</p>
<p>设计模式一般是跟编程范式是有关联的，有些设计模式在面向对象编程中存在，但在函数式编程中就不存在了，比如策略模式、模板模式等。</p>
<p>虽然不同语言有不同的倾向，比如C主要是面向过程的语言，但仍然可以用它模拟面向对象的能力，C++主要是面向对象的语言，但可以模拟出函数式编程的能力。</p>
<p>在一个程序中应用多种编程范式已经成为了一个越来越明显的趋势。充分利用各种编程范式的长处，能写出更容易维护的代码。</p>
<p>“编程范式本质是从某方面对程序员编程能力的限制和规范” --- Bob大叔</p>
<p>结构化编程是为了封装低层的指令而生的，而随着程序规模的膨胀，它组织程序的方式就显得很僵硬，因为它是自上而下进行分解的。</p>
<p>面向对象中封装是根基，它提升了程序员管理程序的尺度。封装的重点在于对象提供了哪些行为，而不是有哪些数据。</p>
<p>设计一个类，先要考虑其对象应该提供哪些行为。然后，我们根据这些行为提供对应的方法，最后才是考虑实现这些方法要有哪些字段。</p>
<p>将意图与实现分离开来，这是一个优秀设计必须要考虑的问题。</p>
<p>要遵循<strong>最小化接口暴露</strong>原则。</p>
<p>继承分为<code>实现继承</code>和<code>接口继承</code>。实现继承主要考虑的是代码复用，是站在子类的角度向上看的。接口继承是站在父类往下看，父类是主要的思考点。（实现继承并不被推荐，优先用组合来实现。如果想复用代码，在dart中可以使用<code>mixin</code>、C++中，可以使用私有继承）</p>
<p>构建抽象，需要找出不同事物的共同点，而这是最有挑战的部分。寻找共同点这件事，地基还是在分离关注点上。</p>
<p>接口将变的部分和不变的部分隔离开来。<strong>不变的部分就是接口的约定</strong>，而变的部分就是子类各自的实现。对程序员来说，识别出变与不变，也是一种很重要的能力。</p>
<p>尽量面向接口编程。接口是一个边界。无论是什么样的系统，清晰界定不同模块的职责是很关键的。</p>
<h2 id="设计原则-1"><a class="header" href="#设计原则-1">设计原则</a></h2>
<p>设计原则是为了让软件在长期演进中更<strong>容易适应变化</strong>而沉淀出来的一些优秀经验。</p>
<h3 id="单一职责"><a class="header" href="#单一职责">单一职责</a></h3>
<p>SRP原则的最新定义为：一个模块应该对一类且仅对一类行为者（actor）负责。不再是以前的“一个类只负责一件事”，原因是将<strong>变化</strong>纳入了考量。</p>
<p>理解单一职责原则本质上就是要理解分离关注点。</p>
<p>康威定律：一个组织设计出的系统，其结构受限于其组织的沟通结构。</p>
<p>单一职责原则是基于康威定律的一个推论：一个软件系统的最佳结构高度依赖于使用这个软件的组织的内部结构。如果我们的软件结构不能够与组织结构对应，就会带来一系列麻烦 --- Robert Martin</p>
<h3 id="开放封闭原则"><a class="header" href="#开放封闭原则">开放封闭原则</a></h3>
<p>软件实体（类、模块、函数）应该对扩展开放，对修改封闭。</p>
<p>阻碍程序员们构造出稳定模块的障碍，其实是构建模型的能力。</p>
<p>封装的要点是行为，数据只是实现细节，而很多人习惯性的写法是面向数据的，这也是导致很多人在设计上缺乏扩展性思考的一个重要原因。
构建模型的难点，首先在于分离关注点，其次在于找到<strong>共性</strong>。</p>
<p>很多工具提供的插件机制，就是OCP的很好实践。小到VIM这种工具，大到互联网系统，都有这种机制。</p>
<h3 id="liskov-替换原则"><a class="header" href="#liskov-替换原则">Liskov 替换原则</a></h3>
<p>LSP：子类型（subtype）必须能够替换其父类型（base type）。用子类型替换之后，所有的行为表现都与父类型时完全一致。如果父类型的某个操作不会产生异常，但子类型的相同操作会产生异常，这就是不符合LSP原则。</p>
<p>继承要符合 IS-A 的关系。IS-A 的判定是基于行为的，只有行为相同，才能说是满足 IS-A 的关系。所以不能说正方形IS-A长方形。</p>
<p>如果你发现了任何做运行时类型识别的代码，很有可能已经破坏了 LSP。</p>
<p>要满足 LSP，首先这个对象体系要有一个统一的接口，而不能各行其是，其次，子类要满足 IS-A 的关系。</p>
<p>LSP 的关注点让人把注意力放到父类上，而一旦子类成了重点，我们必须小心谨慎。</p>
<h3 id="接口隔离原则"><a class="header" href="#接口隔离原则">接口隔离原则</a></h3>
<p>ISP：不应强迫使用者依赖于它们不用的方法。</p>
<p>一定要将接口的设计者和使用者明确区分出来，即使是同一个人，但也要意识到是不同的角色。实际开发中设计者和使用者经常是同一个人，这就导致角色区分的意识缺失，从而将接口设计的比较混乱。</p>
<p>接口会迫使我们站在<strong>行为</strong>的角度上来思考，这也是前面编程范式中所倡导的。而且基于接口来设计，可以让对象更加纯粹，设计出的系统也更加容易符合其它原则。</p>
<p>某个大而全的接口，很可能是扮演了多个角色。比如有一个叫<code>人</code>的接口，里面可能实现了父亲、儿子、公司雇员、顾客等角色的接口，任何一点变化都要对这个大接口进行修改。这种情况应该按角色来拆分为多个接口，拆分后的接口就叫做<code>角色接口</code>。</p>
<p>接口的使用者对于接口是一种依赖关系，被依赖的一方越稳定越好，而只有规模越小，才越有可能稳定下来。</p>
<h3 id="依赖倒置原则"><a class="header" href="#依赖倒置原则">依赖倒置原则</a></h3>
<p>DIP：1. 高层模块不应依赖于低层模块，二者应依赖于抽象；2. 抽象不应依赖于细节，细节应依赖于抽象。</p>
<p>DIP可以让原本高层模块对低层模块的<strong>实现依赖</strong>，转变为低层模块对高层模块的<strong>接口依赖</strong>，以此实现高层模块与低层模块的解耦，并且能让高层模块保持稳定。</p>
<p>基于细节应该依赖于抽象的原则，我们可以得出如下的实践：</p>
<ul>
<li>任何变量都不应该指向一个具体类</li>
<li>任何类都不应继承自具体类</li>
<li>任何方法都不应该改写父类中已经实现的方法</li>
</ul>
<h3 id="其它原则"><a class="header" href="#其它原则">其它原则</a></h3>
<p>除了上面列的<strong>SOLID原则</strong>之外，还有一些其它原则：</p>
<ul>
<li><code>KISS原则</code>：即<code>Keep It Simple and Stupid</code>，即保持代码的简单、易于理解</li>
<li><code>DRY原则</code>：即<code>Don't Repeat Yourself</code>，目的要减少信息重复</li>
<li><code>迪米特法则</code>：也叫<code>最少知识原则</code>。为了降低了类之间的耦合度，提高了模块的相对独立性。</li>
<li><code>YAGNI原则</code>：不要加上你不需要的东西，为了避免过度设计</li>
<li>……</li>
</ul>
<p>DRY原则中，注意并不只是指编码的重复，还包括如下的重复：（来源《程序员修炼之道》）</p>
<ul>
<li>对<code>知识</code>和<code>意图</code>的重复；即在多个地方对相同的东西进行了不同(不同或相同)的表达。</li>
<li><code>文档</code>的重复；即代码能很明确的表达的东西，就没有必要再注释中再表达。</li>
<li><code>数据</code>的重复；比如某个线段类，已经定义了起点、终点的属性，就没必要再定义length的属性了。（提供方法就好）</li>
<li>开发人员间的重复：不同的人员为相同的解决方案做了不同的实现</li>
<li>……</li>
</ul>
<h3 id="设计模式-2"><a class="header" href="#设计模式-2">设计模式</a></h3>
<p>设计模式是在特定场景下<strong>遵守设计原则</strong>而提炼出来的较通用的解决方案。</p>
<p>虽然设计模式本身并不局限于语言，但很多模式之所以出现，就是受到了语言本身的限制。比如所谓的模板模式、策略模式等，都有浓浓的面向对象的味道。</p>
<h2 id="实战"><a class="header" href="#实战">实战</a></h2>
<h3 id="如何实现程序库"><a class="header" href="#如何实现程序库">如何实现程序库</a></h3>
<ul>
<li>发现问题</li>
<li>把问题拆解成可以解决的需求</li>
<li>思考解决方案</li>
<li>做设计（包括基础设计、扩展设计）</li>
</ul>
<p>阻碍一个人写出一个程序库的，往往是不知道要实现一个什么样的程序库，原因就是没有发现存在的问题。<strong>程序员不能只当一个问题的解决者，还应该经常抬头看路，做一个问题的发现者。</strong></p>
<p>在思考解决方案时，一个特定的问题总有一个快速的解决方案，但如果要想做成一个通用方案，它就必须提炼通用的模式。这就需要我们把问题抽丝剥茧，把无关的信息都拿掉，才可能看到最核心的部分。</p>
<h3 id="如何设计一个应用"><a class="header" href="#如何设计一个应用">如何设计一个应用</a></h3>
<p>业务人员提出问题；开发人员给出解决方案。一定不能混淆问题和解决方案</p>
<p>一件事是不是有技术含量往往不取决于事情本身，而取决于我们怎么做它。</p>
<p>一个好的设计从拒绝低水平重复开始，把工作做成有技术含量的事情。</p>
<h3 id="如何改进旧系统"><a class="header" href="#如何改进旧系统">如何改进旧系统</a></h3>
<p>找到一个目标，然后小步改进，逐步向这个目标接近。</p>
<ul>
<li>目标要全新思考，如果有机会<strong>从头设计这个系统</strong>，它应该是什么样子？ </li>
<li>有了目标之后，再拆分成<strong>足够小</strong>的步骤，每一步都不要带来太大的风险，而且每一步都能给我们一些正向的反馈。</li>
<li>改进设计时，千万不要走回到老路上。该分离关注点就分离关注点，该重新组合就重新组合</li>
</ul>
<blockquote>
<p>重新设计很容易走回老路上，因为思维的惯性实在是太大了。比如说，在原有的系统内有一个叫订单的概念，我们就会习惯性地使用订单，而不是把商品订单、支付订单等概念分开。</p>
</blockquote>
<h2 id="资料-46"><a class="header" href="#资料-46">资料</a></h2>
<ul>
<li><a href="https://book.douban.com/subject/1152111/">程序员修炼之道</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/01/abstraction_principles.html">代码的抽象三原则</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ddd实战课"><a class="header" href="#ddd实战课">DDD实战课</a></h1>
<p>来源：<a href="https://time.geekbang.org/column/intro/100037301">DDD实战课</a></p>
<h2 id="基础概念-7"><a class="header" href="#基础概念-7">基础概念</a></h2>
<img src="https://static001.geekbang.org/resource/image/dc/66/dc32e8e4a317fe00121ce18adc407c66.jpg" alt="领域模型" style="zoom:50%;" />
<p>DDD与微服务是经常放在一起的概念。DDD也是在微服务被提出后，才开始有大展拳脚的场景。微服务的难点在于边界的划分，而DDD很好的指导边界的划分。</p>
<p>DDD 是一种设计思想，它的目的是分离技术实现的复杂性，以围绕业务概念构建领域模型来控制业务的复杂性，以解决软件难以理解，难以演进的问题。</p>
<p>DDD 包括战略设计和战术设计两部分。</p>
<ul>
<li>战略设计主要从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的限界上下文</li>
<li>战术设计则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地</li>
</ul>
<p>基础概念</p>
<ul>
<li>领域：就是用来确定范围的，范围即边界</li>
<li>子域：将领域划分为多个子领域，称为子域</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="领域驱动设计综述thoughtworks洞见"><a class="header" href="#领域驱动设计综述thoughtworks洞见">领域驱动设计综述(Thoughtworks洞见)</a></h1>
<blockquote>
<p>来源：<a href="https://weread.qq.com/web/reader/44f32bb071e1265344f0481kc81322c012c81e728d9d180">领域驱动设计综述</a></p>
</blockquote>
<p>在当前这个时代，按照固有的计划来执行往往会跟不上外部多变的环境。所以很多管理者开始选择<strong>主动变化</strong>，来紧跟时代。不确定性管理成了这个时代的主旋律，企业的响应力成了成败的关键。</p>
<p>这种情况下，对技术架构的挑战也前所未有的大。</p>
<p>架构设计的本质是要解决问题的复杂度，以及让系统能够快速响应外部变化并支持系统能够持续演进。</p>
<p>不要用固有的思维，认为某些场景或业务天生就很重很慢，无法做到快速响应。但可以看看我们每天都在使用的一些巨型系统，如<strong>互联网</strong>，可能没有什么公司的业务系统要比互联网本身更复杂，但互联网的健壮性以及变化速度是非常快的。每天都有不同的新业务及新事物在互联网上出现，部分业务出了问题也不会影响其它的业务。</p>
<p>互联网的设计就给可以给我们很多启发：</p>
<ul>
<li>组件的划分尽量靠近变化的原点。让变化固定在组件范围内，不要让某个变化波及至多个组件。</li>
<li>组件间能够互相调用，但不应该有强依赖。</li>
<li>组件在业务上鼓励复用。</li>
</ul>
<p>从业务出发、面向业务变化是我们现代架构设计成功的关键。架构设计的核心实质是保证面对业务变化时我们能够有足够快的响应能力。</p>
<p>面向业务变化而架构就要求首先理解业务的核心问题，即有针对性地进行关注点分离来找到相对内聚的业务活动形成子问题域。</p>
<p>业务架构和系统架构形成绑定关系，从而建立针对业务的高响应力框架。</p>
<p>在战略层面，DDD非常强调针对业务问题的分析和分解，通过识别核心问题域来降低分析的复杂度。</p>
<p>在战术层面，DDD强调通过识别问题域里的不同业务上下文来进行面向业务需求的组件化。</p>
<p>若想对业务问题进行很好的子域划分，必须能够很好的“讲故事”。即能够在两三分钟的时间内，清晰、场景化的描述出所做的业务。</p>
<h2 id="概念-3"><a class="header" href="#概念-3">概念</a></h2>
<p><strong>聚合</strong>是构建领域模型的基础。识别聚合是认知潜在核心业务规则的过程。</p>
<p><strong>领域服务</strong>本身就像一个静态方法一样，拥有一定的逻辑但不持有任何的信息，从整个领域来看也不存在不同“版本”的同一个服务。</p>
<p>DDD通过<strong>子问题域</strong>（subdomain）的划分进行针对业务能力的分解。而<strong>限界上下文</strong>在解决方案域中完成了进一步分解。一个<strong>限界上下文</strong>封装了一个相对独立子领域的领域模型和服务。能够区分问题域和解决方案域，是比较困难的，而且是一个架构师能力进阶的分水岭。</p>
<h2 id="实践"><a class="header" href="#实践">实践</a></h2>
<p>DDD提出了业务设计到代码实现一致性的要求。也就是说从代码的结构中我们可以直接理解业务的设计，命名得当的话，非程序人员也可以“读”懂代码。</p>
<p>完成业务的需求就是在领域模型上的一系列操作（应用）。这些操作包括了对核心实体状态的改变，领域事件的存储，领域服务的调用等</p>
<p>DDD落地常用分层架构：</p>
<img src="Note/./images/DDD_ArchLayer.png" style="zoom:50%;" />
<p>各层的依赖关系是非常重要的，比如Domain不应该依赖于其它任何一层，如果实施过程中不严格规范，就会导致最终代码结构的混乱。</p>
<p>单元测试作为构建高质量软件过程中的标准规范，很多时候设计测试比实现应用本身更加困难。让用例尽量测试业务需求而不是实现方式本身。</p>
<p>基于DDD建立的核心模型之上应用TDD是顺理成章的事，因为TDD与DDD在遵循的原则上是一致的，即都是面向业务做分解和设计。</p>
<p>前期对核心领域模型的分析和设计是必要的，这样能够帮我们更快地响应后续业务变化。</p>
<p>实践DDD时仍然需要遵循“模型是用来交流的”的这一核心原则。</p>
<p>事件风暴是一种<strong>快速探索复杂业务领域和对领域建模的实践。</strong> (详细介绍参考：<a href="https://juejin.cn/post/6844904006016303117">DDD第3篇 - 事件风暴</a>)</p>
<h2 id="思考"><a class="header" href="#思考">思考</a></h2>
<p>DDD在客户端开发中的使用?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="架构整洁之道"><a class="header" href="#架构整洁之道">架构整洁之道</a></h1>
<p>来源：<a href="https://weread.qq.com/web/reader/480322f072021a3248038c8kc81322c012c81e728d9d180">架构整洁之道(微信读书)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="解析极限编程"><a class="header" href="#解析极限编程">解析极限编程</a></h1>
<p><a href="https://www.dedao.cn/eBook/nroX7MYDaKMjy7eNqrmOX6pnAQ5Vg048Qo0JzxbE9LZl1o8RkGd2BPYv4x6d9meB">《解析极限编程》</a></p>
<p>XP目标：更低成本、更高生产效率、更高投资回报。</p>
<p>极限编程中，要有非常重要的意识：</p>
<ul>
<li>无论环境如何，你始终可以改进</li>
<li>你总可以自己开始改进</li>
<li>你今天就可以开始改进</li>
</ul>
<p>XP实践中需要不断改进开发方式，使开发方式极限化</p>
<p>XP要求我们放弃放弃那些妨碍生产率但保护我们自己防御行为的习惯及模式：</p>
<ul>
<li>坦承自己的能力可以做什么</li>
<li>放弃我们不成熟的自负</li>
</ul>
<p>XP也需要好的合作关系，好的人际关系会影响到生产率和自信心。XP致力于同时解决技术和合作关系这两方面的问题。</p>
<p>XP定义：一种软件开发风格，专注于编程技术、清晰沟通还有团队协作的精彩实践。</p>
<p>XP是：</p>
<ul>
<li>一种开发哲学，基于沟通、反馈、简约、勇气和尊重的价值观。</li>
<li>一套有用实践，这些实践相辅相成，相互增强。</li>
</ul>
<p>什么是XP呢？</p>
<ul>
<li>XP是放弃旧的、低效的技术和习惯而采用新的有效的技术和习惯。</li>
<li>XP是因为你今天的竭尽全力而充分欣赏自己。</li>
<li>XP是努力在明天做得更好。</li>
<li>XP是要你按照对团队共同目标做出的贡献来评价自己。</li>
<li>XP是让你的一些人性需求在软件开发中得到满足。</li>
</ul>
<p>XP是一条可以使得一起开发软件的人们共同进步直至卓越的途径。</p>
<p>关于技术： (对卓越技术的追求在开发型组织中是非常重要的。)</p>
<ul>
<li>成为一个杰出的开发团队，需要大量的技术知识，并且需要不断学习新的知识。</li>
<li>卓越的技术还有益于信任关系的建立。</li>
</ul>
<p>“不设防才是真正的安全” -- 要避免通过隐瞒一些事情来让自己有安全感</p>
<p>XP团队需要竭尽全力去取胜，而且勇于承担后果。不要为失败做准备，只为成功做准备。（为失败做准备就是在为自己留后路）</p>
<p>开发人员不应该对“最后期限”恐惧，你要做的就是把所有关于项目的事情都同步出来，尽可能的跟其他角色沟通清楚。</p>
<p>理解极限编程，有一个很直观的隐喻，就是“开车”。开车最重要的是保持注意力集中，不断调整方向。这个也就是XP的范式：保持清醒、适应、变化。</p>
<p>知识和理解的这个层次，就是实践。实践是明确的，即使我们没有在更深层次上理解软件开发时，我们也可以去做一些事情并从中受益。</p>
<p>价值观是属于更高的层次，价值观是在某种处境中我们喜欢或不喜欢某事的根源并用于评价我们所见、所想和所做的一大标准。</p>
<p>将价值观显式化很重要，因为没有价值观，实践很快会变成生搬硬套，为行动而行动，缺乏目的或方向。（实践是价值观的一个表现）</p>
<p>价值观是普适的。理想的情况下，工作中的价值观同生活中的价值观一样。</p>
<p>原则是架在价值观和实践中间的桥梁，是一种具体领域的指导方针。</p>
<h3 id="价值观"><a class="header" href="#价值观">价值观</a></h3>
<p>XP的5个开发价值观：沟通、简单、反馈、勇气和尊重。</p>
<p>价值观之间是相互平衡和相互支持的。比如加强沟通能够去除那些不需要的或者可暂缓的需求，从而达到简单化。</p>
<h5 id="沟通"><a class="header" href="#沟通">沟通</a></h5>
<p>每当你遇到一个问题，首先问自己这个问题是不是由于缺乏沟通引起的，你需要什么样的沟通来解决该问题？需要什么样的沟通来使你以后避免这样的麻烦？</p>
<h5 id="简单"><a class="header" href="#简单">简单</a></h5>
<p>思考一个问题：什么是最简单而又有效的系统？ 简单的意义与具体的环境相关。</p>
<h5 id="反馈"><a class="header" href="#反馈">反馈</a></h5>
<p>变化是不可能避免的，变化产生了对反馈的需要。</p>
<p>XP团队致力于在尽可能快的情况下产生尽可能多的反馈。</p>
<p>如果将沟通的对象从人扩展为事时，反馈可以合入到沟通中。毕竟在人与事的沟通中，事物给的响应就是反馈。</p>
<h5 id="勇气"><a class="header" href="#勇气">勇气</a></h5>
<p>软件开发中的人们同样也会感到畏惧。</p>
<p>仅仅只有勇气是危险的，与其他价值观相呼应的勇气才是有力的。表达愉快或不愉快真相的勇气会有助于沟通和信任的建立；放弃失败的解决方案和寻求新方案的勇气会有助于鼓励对“简单”这一价值观的追求；寻求真实具体答案的勇气会有助于增加反馈。</p>
<h5 id="尊重"><a class="header" href="#尊重">尊重</a></h5>
<p>受软件开发影响的每个人，都有其作为人的价值观。不会有某个人本质上比其他人更有价值。所以要同时提高软件开发的人性和生产率，每个人对团队的贡献都应该得到尊重。我是重要的，你也是。</p>
<h3 id="原则"><a class="header" href="#原则">原则</a></h3>
<p>软件开发通常并不符合人的需求，也没有承认人性的弱点和平衡人的力量。如果忽视软件是由“人”编写的，参与者会付出高昂的代价。</p>
<p>一名优秀开发者的需求：</p>
<ul>
<li>基本安全</li>
<li>成就感 （自我价值体现）</li>
<li>归属感 （得到认可、责任及为共同目标做贡献）</li>
<li>成长</li>
<li>亲切感 （与其他成员间的高度理解与被理解）</li>
</ul>
<p>互惠互利是XP中最重要的原则，也是最难坚持的原则。XP通过互惠互利的方式来解决“与未来交流”的问题。</p>
<p>计算机业务其实是人的业务，维护工作关系是很重要的。</p>
<p>试着将一个解决方案的结构复制到一个新环境中，即使它们的粒度不同</p>
<p>在软件开发中，“完美”是个动词，而并非是形容词。“完美”是指通过不断<strong>改进</strong>达到完美。改进原则表示为实践就是：马上开始行动，随着时间的推移逐步精化结果。</p>
<p>软件开发技术的历史就是逐步减少浪费的人力的历史。</p>
<p>团队需要将不同的技能、态度以及看待问题和缺陷的视角整合在一起，来考虑解决问题和实现解决方案的不同方法。团队需要多样性。</p>
<p>一个设计有两种想法，代表的是机会，而不是问题。</p>
<p>在压力巨大时，尊重他人，保持自我，可以使沟通顺畅。</p>
<p>好的团队并不只是进行他们的工作，他们会思考如何工作和为什么工作。他们会分析为什么成功或失败。他们不会试图掩藏他们的错误，而是暴露它们并从中学习。谁都不可能突然间变优秀。</p>
<p>反省不应该限制在“官方”场合。比如喝咖啡、与朋友交谈都可以用来反省。</p>
<p>要学会把问题看做改变的机遇，必须把问题转化为学习和改进的机遇。比如缺陷，虽然没有缺陷是令人满意的，但每一个缺陷都是团队学习和改进的机会。</p>
<p>失败不是浪费吗？不是，如果它能够产生知识的话。知识是有价值的，这种价值有时候是很难获得的。</p>
<p>不要为了担心浪费编码时间，而进入长时间无休止的讨论中。做了一定的讨论后，做起来，失败好过无休止的讨论。</p>
<p>在不知道如何做到更好的时候，冒一点风险失败可能是通向成功的最短最稳妥的道路。</p>
<p>要求高质量通常导致更快的交付，而降低质量标准通常会导致更晚的不可预见的交付。</p>
<p>缺陷、设计质量和开发经验衡量为度量，每一次质量的提高都会改进其他的项目属性。</p>
<p>人们需要做令他们感到自豪的工作。</p>
<p>如果你不知道做一项必需要做的工作的明确方法，那么尽你最大的努力去做。如果你知道但是需要的时间太长，那么用你现在所拥有的全部时间去做，稍后想办法完成它。</p>
<p>小步快跑</p>
<p>责任不能被指定，只能被接受。</p>
<p>责任和权力需要并行。</p>
<h3 id="实践-1"><a class="header" href="#实践-1">实践</a></h3>
<p>在XP实践中，不要生搬硬套，要以核心价值观为根本。比如结对编程实践，只有为了沟通、获取反馈、简化系统、捕捉错误和提升勇气的结对编程才是真正有意义的。</p>
<p>XP实践概览：
<img src="Note/./images/XPExplained/xp_practice.png" alt="XP实践概览" /></p>
<p>一次采取一个XP实践可能会看到改善，但多个实践结合在一起时你将会看到惊人的改进。</p>
<p>坐在一起工作是非常重要的：</p>
<ul>
<li>不管客户说的问题是什么，它终归是人的问题，单单用技术解决是不够的。</li>
<li>坐到一起来，用我们所有的感官知觉进行交流，这一点太重要了。</li>
</ul>
<p>人们需要团队感：</p>
<ul>
<li>我们属于它；</li>
<li>我们都在其中；</li>
<li>我们相互支持彼此的工作、成长和学习。</li>
</ul>
<p>在组织中，要避免“碎片人”的出现，即一部分工作时间支持A项目，另一部分时间支持B项目。这样会导致大量的时间浪费在工作任务的切换上。</p>
<p>团队最好有一个信息空间，一个对项目感兴趣的观察者，走进来之后可以在15秒内对项目如何运转有一个大致的概念。并且可以进一步通过近距离观察发现更多的问题或相关信息。 现在也可以建立电子信息空间来实现这一目的。</p>
<p>软件开发是一个洞察力的游戏，而洞察力来自于准备好的、休息好的和放松的头脑。当你太疲倦的时候，你很难意识到你正在降低项目的价值。</p>
<p>你可以对工作时间做出更多改进。使用同样长的时间，但对时间进行更好的管理。每天明确两个小时的编码时间。关闭电话和邮件提醒，两个小时只进行编程。</p>
<p>结对程序员：</p>
<ul>
<li>使彼此都专注于任务；</li>
<li>一起头脑风暴，讨论系统的精化；</li>
<li>理清想法；</li>
<li>当搭档陷入困境时要主动，这样才能减少挫折；</li>
<li>使彼此都对团队的实践负责。</li>
</ul>
<p>结对并不意味着你不能独立思考，可以带着要思考的问题离开团队，思考、探索完成后，把想法带回团队。</p>
<p>结对时，需要让双方的个人空间都得到尊重，让双方都能处于一种舒适的状态(不同人的舒适距离可能也不一样)。 如果程序员感情上不够成熟，不能辨别鼓励与赞赏，那么和异性的结队工作可能会带来男女情感，而这对团队是不利的</p>
<p>团队需要发挥好作用，让成员们都可以高效、舒适的工作。</p>
<p>用户故事，相比需求，可以更早的估算结果。在估算的过程中，也会让一些条件或限制更加明确出来，也便于决策。比如一台跑车或一台货车，要如何选择它们，就需要明确自己的条件、使用目的等。</p>
<p>计划是一种必要的浪费。</p>
<p>任务的所有权对满足人类的占有欲有很大帮助。</p>
<p>习惯性的高承诺所产生的令人难以置信的浪费：难以管理的缺陷负载，沮丧的士气和敌对的关系。实现承诺，即使是不起眼的，也会起到消除浪费的作用。</p>
<p>持续集成有同步模型和异步模型。一般情况下异步模型更受欢迎，因为CI代码之后，就可以开始后续的任务了，不需要等待当前检测结果。同步模型是指CI代码后，需要等这次CI验证通过后，才可以进行下一步工作。同步模型也有他的好处，在等待的时间，是一个很好的<strong>反省时间</strong>，可以思考刚才的代码是否有更好的写法及设计。</p>
<p>XP实践推荐增量设计，很难做到一步就能给出完美设计。开始给出一个足够的设计就可以开始工作，但要保证在设计上的投入与至今为止的系统需求成比例。</p>
<p>开始实践XP的步骤如下：</p>
<ul>
<li>一个团队首先需要对过去的经历进行准确的反省，有了反省才可以做出明确的决定。（先度量问题，以此意识到改变的必要性）</li>
<li>有了改变的意识，就开始执行</li>
<li>找一个实践开始执行，如结队编程，挑选我担心的一段代码，让别人跟我结对一两个小时写出它和系统另一部分的接口。</li>
<li>实践完之后再来反思其带来的改变，是否需要做什么调整。</li>
</ul>
<p>要实践XP，团队中的任何一个人都可以从自己开始。</p>
<p>如果我们在开发过程中带着人类的本性工作，就会产生大幅提升效率的机会。</p>
<p>在花费了项目预算的很小比率的资金之后，就应该进行最初的软件部署，这样可以及早得到反馈并进一步调整。</p>
<h3 id="扩展实践"><a class="header" href="#扩展实践">扩展实践</a></h3>
<p>通用化一个成功的系统比定制一个不能解决任何人问题的系统更容易。</p>
<p>大组织常常忽视团队的价值，把“编程资源”比喻成分子/流体。一旦项目完成了，他们重新回到“池”中。这种调度的目标是充分利用所有的程序员。这种策略可以将微观效率最大化，但是会破坏组织的整体效率，它追求让每个个体都忙于敲打键盘的虚幻效率，而忽略了让员工尽量与熟悉和信任的同事一起工作的价值。</p>
<p>遇到问题后，要进行<strong>根源分析</strong>，采用不断问<strong>为什么</strong>的方式来分析根源。</p>
<p>共享代码和<strong>责任</strong>。团队成员可以共同承担责任，不仅为他们提交给用户产品的质量负责，也为他们给团队工作感到自豪。结队编程可以帮助队友彼此明确他们对彼此的质量承诺，同时也帮助他们对质量的组成达成共同的期望。</p>
<h3 id="完整xp团队"><a class="header" href="#完整xp团队">完整XP团队</a></h3>
<p>XP团队中的每个人都要把自己的未来跟他的工作领域联系起来。</p>
<p>流的原则表明，平稳的软件流比偶尔的大规模部署创造的价值更多。要让工作过程变成流，顺畅而又自然的状态。</p>
<p>在执行XP过程中，让每个角色都齐头并进（比任何一群人试图迫使其他人跟随其后）将会取得更多的进步。</p>
<p>将大的架构变化分解成小而安全的步骤，是XP团队的挑战之一。</p>
<p>测试能传达架构的意图。</p>
<p>项目经理同样要促进团队内部沟通以增强团队的凝聚力和信心。项目经理作为团队的一个高效的促进者，比作为一个重要信息的控制者，对团队的帮助更大。</p>
<p>一旦团队负担过重，产品经理要通过分析真实需求和设想需求之间的不同，来帮助团队决定优先做哪些事情。</p>
<p>主管人员要给XP团队提供勇气、自信和责任感。主管人员需要保持洞察力。</p>
<p>主管人员需要保持洞察力，才能在需要做出决策时，主管人员已经拥有了必要的信息来做出英明的决定。</p>
<p>XP团队可能不符合组织的要求，主管人员工作的一部分就是将团队积极地呈现在组织中其他部门面前。XP团队会坚持自己的优点，主管人员需要有在批评面前继续前进的勇气。</p>
<p>一个技术上极其熟练的独行者，和一个可以胜任工作同时具备较强社交能力的程序员，如果要在两人之中做个选择，XP团队一致地选择社交能力强的候选人。</p>
<p>成熟XP团队的角色不是固定和严格的。我们的目标是让每个人为团队的成功作出最大的努力。比如在某时刻，项目经理最适合为架构改进提供建议，那么项目经理就可以来给架构改进提建议。如果程序员适合写用户故事，那就让程序员来写用户故事。</p>
<h3 id="约束理论"><a class="header" href="#约束理论">约束理论</a></h3>
<p>约束理论认为任何系统在某一时间只存在一个约束（偶尔也会存在两个）。要提高系统的整体吞吐率，那么必须首先找出那个约束，并确保它能够全速工作。也即同一时间只关注一个最核心的问题，然后去优化它。</p>
<p>XP工作流，是采用“拉”模式。这种方式是故事在即将要实现时才做详细说明，进而由详细说明拉动着测试，然后设计程序接口来满足测试的需求。（也即是反过来驱动的一种方式）</p>
<p>约束理论假设：整个组织关注的是整体的吞吐率而不是微观的优化。</p>
<h3 id="计划管理范围"><a class="header" href="#计划管理范围">计划：管理范围</a></h3>
<p>XP中的计划开始于把当前的目的、假设和事实公布于众。</p>
<p>计划的一部分工作是从所有可能性中决定下一步要做什么。</p>
<p>XP中的计划不是对未来的预测，是根据今天所有的信息来预估明天可能会发生的事。计划的不确定性也并没有否定其价值。它能够帮助你与其他团队间的协调同步。</p>
<p>结对效率比单人的效率要高不止两倍。</p>
<p>事情进展不顺利的时候就是我们最需坚持价值观和原则的时候，同时修改我们已有的实践去尽可能地保持效率。不准确的评估是信息的错误，而不是价值观或者原则的错误。</p>
<h3 id="尽早测试经常测试自动测试"><a class="header" href="#尽早测试经常测试自动测试">尽早测试、经常测试、自动测试</a></h3>
<p>缺陷破坏了有效软件开发所需的信任。信任在软件开发中是非常重要的，包括开发者之间、开发者与其他角色之间的信任。当团队中充满信任时，整个团队士气和信心都是高涨的，开发效率也会更加高，而且会充满着创造力。所以尽可能降低缺陷是非常重要的，不仅仅是质量的问题。</p>
<p>XP的实践旨在，首先，通过清晰的沟通使得缺陷不再出现，其次，如果出现，保证团队借此学会如何在未来避免发生类似问题。</p>
<p>XP应用两个原则来提高测试的成本效益：复核，缺陷成本递增率：</p>
<ul>
<li>软件测试就是复核。</li>
<li>越早发现缺陷，所需的花费就越少。 （把测试资源转移到开发周期中成本就会更少）</li>
</ul>
<p>TDD优势：实现不应该过度影响接口。先写测试是完成这两者分离的具体方式。(TDD会驱动达到这个目的)</p>
<p>在XP中，测试与编程同样重要。</p>
<h3 id="设计时间的价值"><a class="header" href="#设计时间的价值">设计：时间的价值</a></h3>
<p>增量设计是早早交付功能，并且在项目生命周期中每周持续的交付功能。XP将软件设计的渐进主义推向一个极限。设计是日常事务的一部分，项目运转会更平稳。</p>
<p>软件是一种杠杆游戏。一个好的主意能够节省数百万美金的花费，同时创造数百万美金的收入。</p>
<blockquote>
<p>软件的杠杆效应，在<a href="https://book.douban.com/subject/7564417/">《Linux/Unix设计思想》</a>中有详细介绍
也要思考在工作上怎么样让自己的工作具有放大效应。</p>
</blockquote>
<p>增量设计：开始只需设计足够的东西来得到反馈，然后利用反馈改进设计，保证足以获得下一轮的反馈即可。在这个过程中，耐心是一个软件设计者可以拥有的最有价值的技能之一。</p>
<p>仔细思考设计可以产生一个好的答案，但是经验能够产生更好的设计答案。这儿所谓的经验，就是指前期初步的设计在适应开发的过程中沉淀出来的经验。</p>
<p>如果面对的是一堆乱麻的代码，也可以通过小步改进，让其逐渐变好。如果有不得不改大改的地方，将其记录下来，到时机允许时对其进行大的重构。</p>
<p>XP风格的设计就是<code>设计决策时期</code>的转换，推迟设计带来一些好处：（也即开始做够用的设计就好）</p>
<ul>
<li>更早部署软件</li>
<li>更容易根据执行情况做决策</li>
<li>更容易根据执行情况做出好的决策</li>
</ul>
<p>XP团队更喜欢简单的解决方案，趋向简单的项目可以改善软件开发的人性化和生产率。</p>
<h3 id="增大团队的规模"><a class="header" href="#增大团队的规模">增大团队的规模</a></h3>
<p>XP规模不单指人数，还有投资、时间、问题的复杂性等。</p>
<p>当遇到规模比较大的项目时，按照XP的原则，先进行最大化价值的尝试，然后进入迭代、反馈的循环，每次拿出一点成果。不管是人数，还是投资，都可以按照这种原则来处理。</p>
<h3 id="丰田生产制度"><a class="header" href="#丰田生产制度">丰田生产制度</a></h3>
<p>最大的浪费就是生产过剩的浪费。 -- 大野耐一</p>
<h3 id="应用xp"><a class="header" href="#应用xp">应用XP</a></h3>
<p>软件开发中有太多的浪费，而这些浪费的根源更多的来自于我们认知的误区。</p>
<p>首先改变自己，然后把改变的成果贡献给其他人。期望别人做你自己不想做的事情是无礼和低效的。模范带头开发是一种有力的领导形式。</p>
<p>教练应该有足够的技术能力来教导队员学习不易自学的知识。</p>
<h3 id="永恒的编程之道"><a class="header" href="#永恒的编程之道">永恒的编程之道</a></h3>
<p>在不同的人之间培养牢靠的关系，一起用软件赚钱。</p>
<p>XP依赖于有能力的程序员的成长：能够快速地评估、实现和部署可靠的软件。</p>
<p>XP依靠团队中的每一个成员，包括主管、经理和客户，每个人都要完全地负责并尽他们最大的努力。一个团队一起工作可完成超过它的成员单独努力的总和的工作，</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust--swift对比"><a class="header" href="#rust--swift对比">Rust / Swift对比</a></h1>
<h3 id="rust特性-1"><a class="header" href="#rust特性-1">Rust特性</a></h3>
<ul>
<li>支持<code>可变</code> / <code>不可变</code>类型</li>
<li>支持元组 （但Rust支持命名元组，使用Struct来定义）</li>
<li>支持模式匹配</li>
<li>支持泛型</li>
<li>支持协议 (Rust中叫<code>Trait</code>，Swift中叫<code>Protocol</code>)，两者的协议能力非常类似</li>
<li>没有提供继承，通过组合来实现代码复用</li>
<li>测试代码可以写在源文件中</li>
<li>注释文档中可以也可以写测试代码</li>
<li>面向表达式的语言。（除了<code>use</code>这种声明语句，其它基本都是表达式）</li>
<li>没有 <code>三元操作符</code></li>
</ul>
<h3 id="其它-13"><a class="header" href="#其它-13">其它</a></h3>
<ul>
<li>Rust后端也是LLVM</li>
</ul>
<table><thead><tr><th>能力</th><th>Rust</th><th>Swift</th></tr></thead><tbody>
<tr><td>不可变类型</td><td><code>let x = 5</code></td><td><code>let x = 5</code></td></tr>
<tr><td>可变类型</td><td><code>let mut x = 5</code></td><td><code>var x = 5</code></td></tr>
<tr><td>支持元组</td><td><code>(1, true)</code></td><td><code>(1, true)</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-文章"><a class="header" href="#12-文章">12. 文章</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="浅谈软件设计-1"><a class="header" href="#浅谈软件设计-1">浅谈软件设计</a></h1>
<blockquote>
<p>文章通过读的一些资料加上自己的理解整理的，可能存在一些错误，欢迎指正</p>
</blockquote>
<p>[TOC]</p>
<h2 id="前言-4"><a class="header" href="#前言-4">前言</a></h2>
<p>软件设计中，什么最重要？能让软件灵活、低成本修改的前提下，又能尽可能减少变化带来的风险。</p>
<p>如何能达到这个目的呢？有如下几个方面：</p>
<ul>
<li>能不修改原有代码就不修改，变化的功能完全通过新增代码来解决。(<a href="https://weread.qq.com/web/reader/480322f072021a3248038c8k98f3284021498f137082c2e">OCP原则</a>)</li>
<li>必须修改原有代码时，尽量把代码的变化限制在足够小的范围内。（正交性）
<ul>
<li>模块/类/方法的职责单一化，边界划分时将可能联动的变化隔离 (<a href="https://weread.qq.com/web/reader/480322f072021a3248038c8k1f032c402131f0e3dad99f3">SRP原则</a>)</li>
<li>对代码进行抽象，抽象的东西更具普适性，更容易在变化中做到不变。并且抽象的部分不要依赖于具体的部分（<a href="https://weread.qq.com/web/reader/480322f072021a3248038c8k37632cd021737693cfc7149">DIP原则</a>）</li>
</ul>
</li>
</ul>
<blockquote>
<p>正交性：源于<a href="https://book.douban.com/subject/1152111/">《程序员修炼之道》</a>，是一个核心指导原则。是指当某个模块有修改、变化时，对周边其它模块不造成任何影响。</p>
</blockquote>
<h2 id="设计原则-2"><a class="header" href="#设计原则-2">设计原则</a></h2>
<h3 id="ocpsrpdip"><a class="header" href="#ocpsrpdip">OCP/SRP/DIP</a></h3>
<p>根据上面这些推导，就能看出来设计原则也是为了满足目的而总结出来的经验。虽然在<a href="https://weread.qq.com/web/reader/480322f072021a3248038c8kc81322c012c81e728d9d180">《架构整洁之道》</a>中提炼了SOLID五种设计原则，但根据上面的推论，可以看出来OCP/SRP/DIP是更加核心的设计原则。</p>
<p>如果从逻辑上来讲，OCP应该跟正交性属于同一个层次。</p>
<p>OCP在设计模式中的使用也是非常常用的指导原则，比如<code>观察者模式</code>、<code>职责链</code>、<code>装饰器模式</code>等，都是OCP原则的使用。</p>
<p>OCP也是可大可小的原则，在越大的系统上，OCP越重要。比如互联网，核心层是非常稳定，扩展性非常强，要发布新的网站完全是不需要修改互联网底层。</p>
<blockquote>
<p>互联网的这个例子，来自<a href="https://time.geekbang.org/column/intro/313">软件设计之美</a>，非常具有启发性。</p>
</blockquote>
<p>针对OCP原则，在<a href="https://time.geekbang.org/column/article/176075">《设计模式之美》</a>中提了一个有趣的问题：修改代码就意味着违背开闭原则吗？</p>
<p>其实不一定。比如实现某个需求时，如果在某个类中扩展了一个接口，那么对接口来说是满足OCP，但对类来说是不满足的(对模块和类层次来说也一样)。所以是否满足OCP不能简单一概而论。专栏中给出了这样的结论：<strong>尽量让修改操作更集中、更少，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。</strong></p>
<h3 id="lspisp"><a class="header" href="#lspisp">LSP/ISP</a></h3>
<p>那SOLID中剩余的LSP及ISP原则是有什么用处呢？</p>
<p>LSP(里氏替换原则)从定义上来说：任何基类可以出现的地方，子类都可以替换它。</p>
<p>子类可以完全替换父类，这个约束可以产生什么样的结果呢？</p>
<ul>
<li>子类只能去扩展基类，而不能隐藏或者覆盖基类行为。这其实是对OCP的实践。</li>
<li>抽象层确定下来的行为，具体类不能改变它，只能适应它；也就是实现要依赖于抽象，而非具体。这其实是对DIP的实践。</li>
</ul>
<p>所以本质上LSP是在满足DIP和OCP的原则下推导出的一个具体原则。</p>
<p>ISP(接口隔离原则)从定义上来说：不应强迫使用者依赖于它们不用的方法。ISP有如下作用：</p>
<ul>
<li>源码层面的变化隔离，可以一定程度上提升源码编译速度。</li>
<li>对更高层次模块来说，可以防止不必要依赖变化时，都需要重新编译、布署。</li>
</ul>
<p>ISP与SRP一定程度上有些相似性，但并不一样。ISP更侧重于接口的设计，思考角度也是略不同的。</p>
<p>ISP迫使我们在接口的维度上来思考，使我们站在行为的角度上来思考。行为是更加复杂易变的，实体会更加稳定。那么基于行为进行职责划分与隔离，就更容易封装变化。</p>
<h3 id="其它原则-1"><a class="header" href="#其它原则-1">其它原则</a></h3>
<p>除SOLID原则外，还有一些比较有名的指导原则：</p>
<ul>
<li>针对接口编程：本质也是将代码分层，接口设计即抽象层的设计，也即DIP的实践。</li>
<li>KISS：使代码保持简洁。注意，如果问题很复杂，此时解决方案复杂的话，也可以认为是满足KISS原则的。</li>
<li>YAGNI：不要做过度设计。不要提前写用不到的代码，但预留扩展性是必要的。</li>
<li>DRY：完全重复的代码不一定违反DRY，不完全一样的代码也可能违反了DRY。详情可以参考：<a href="https://time.geekbang.org/column/article/179607">重复的代码就一定违背DRY吗？如何提高代码的复用性？</a></li>
<li>LOD：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。 详解参考：<a href="https://time.geekbang.org/column/article/179615">如何用迪米特法则（LOD）实现“高内聚、松耦合”？</a></li>
</ul>
<blockquote>
<p><code>KISS</code>、<code>LOD</code>、<code>YAGNI</code>等原则的一些详细说明，<a href="https://time.geekbang.org/column/intro/250">《设计模式之美》</a> 对这块的详细介绍是很值得看一下的
<code>DRY</code>原则，在《程序员修炼之道》中有更全面的说明，DRY不止指代码层面的重复，还包括意图等方面的重复</p>
</blockquote>
<h2 id="设计模式-3"><a class="header" href="#设计模式-3">设计模式</a></h2>
<p>面向对象开发中，代码中遍布着对象。那么面向对象开发中对象及对象关系的处理就是非常重要的。GoF总结的设计模式，也可以围绕对象的关系/行为来理解。</p>
<p>对象的处理，可以划分为如下三种关系/行为：</p>
<ul>
<li>对象的创建</li>
<li>对象间的关系</li>
<li>对象的行为</li>
</ul>
<p>站在这个角度来理解设计模式是更容易理解的。但我们需要先考虑的是，为什么会存在这些设计模式。要研究这个问题，还是需要基于具体场景来看</p>
<blockquote>
<p>比较简单的单例、观察者模式，以及使用场景比较受限的解释器，还有仅为了内存优化而存在的FlyWeight模式并没有涉及</p>
</blockquote>
<h3 id="对象的创建-2"><a class="header" href="#对象的创建-2">对象的创建</a></h3>
<p>直接创建一个类会有什么问题呢？可能会违反DIP原则，导致抽象类依赖于具体类。</p>
<p>如何解决这个问题呢？在抽象层中不做具体的创建，只保留基类中对象的引用。只要想办法给引用赋值即可，一种办法是在外部创建好后再传进来(即依赖注入)。如果在对象中存在继承关系，还有一种办法就是在子类中创建。</p>
<p>在子类中创建的方式就是**<code>工厂模式</code>**，具体实现上就是抽象类提供<code>create</code>接口返回具体的对象，子类重载该接口返回具体对象。</p>
<p>有批量对象需要创建，对象之间存在约束：某些类型的对象只能同时使用。为了满足该约束，需要封装创建者，并将创建者也进一步分层为抽象类及具体类，就是**<code>抽象工厂模式</code>**</p>
<p>有批量对象要创建，这些对象创建完之后还需要做进一步拼装/组合等操作，同样需要封装创建者并进行设计分层，将拼装/组合的差异放在具体创建者子类中，就是**<code>创建者模式</code>**</p>
<p>如果要对已有对象(包含状态)进行复制，就是**<code>原型模式</code>**</p>
<p>创建型的设计模式，都在遵循<strong>封装变化</strong>、<strong>对接口编程</strong>这些根本原则。</p>
<h3 id="对象间的关系-2"><a class="header" href="#对象间的关系-2">对象间的关系</a></h3>
<p>对象与对象之间有多少种关系呢？</p>
<ul>
<li>继承</li>
<li>包装(包含组合)</li>
</ul>
<p>在什么场景下，可以很好的利用对象关系的处理达到设计的目的呢？</p>
<h4 id="继承-3"><a class="header" href="#继承-3">继承</a></h4>
<p>继承重要的作用就是将代码进行分层，分为抽象层与具体层，并且尽量保持抽象层的稳定。（虽然代码复用也是其中一个功能，但并不推荐）</p>
<p>遇到问题需要对类进行分层时，要满足<code>DIP</code>原则的约束，针对这种约束沉淀出来的方案，自然就可以做到具体层可以随意变化，不影响抽象层，抽象层做一些调整时，具体层也可能完全不受影响。这就是**<code>桥接模式</code>**</p>
<h4 id="包装-2"><a class="header" href="#包装-2">包装</a></h4>
<p>如果目前已有一个对象，我们希望对其进行扩展或修改时，但又希望满足OCP原则，那如何做呢？（还一种情况，就是原始对象无法修改）</p>
<p>有个办法就是通过一个Wrapper类，来将原有对象包装起来，并用Wrapper来替换原始对象的使用，以此来达到修改原始对象的功能。</p>
<p>要改变原始类的接口名称时，在Wrapper的新接口中调用原始接口，就是**<code>适配器模式</code>**</p>
<p>要扩展原始类的功能时，Wrapper与目标类设计为同样类型的对象。在Wrapper中抽象接口实现时，除了调用目标对象的接口，还补充了自己的逻辑。就是**<code>装饰器模式</code>**</p>
<p>修改原始类的行为时，Wrapper与目标类设计为同样类型的对象。在Wrapper中抽象接口实现时，可以按自己的预期来调整新的行为。就是**<code>代理模式</code>**</p>
<p>如果对象结构间有一种递归性，比如大图案是由小图案组合而成的，并且可以不断递归组合。此时Wrapper与目标类设计为同样的类型对象，并且Wrapper中可以存储多个目标类型对象。Wrapper的接口实现上，会迭代调用内部目标对象的接口。这就是**<code>组合模式</code>**</p>
<p>如果要扩大被包装目标的范围，比如是多个对象，或者某个模块，要对他们的接口进行调整，就可以产生**<code>外观模式</code>**</p>
<h3 id="对象的行为-2"><a class="header" href="#对象的行为-2">对象的行为</a></h3>
<p>站在对象的行为上来考虑时，可以更多的从他们的时机和行为上来分析。</p>
<p>如果有一系列操作需要执行，可以将这些操作封装为同一种类型的对象，然后在抽象层可以按序执行它们，就是**<code>Command模式</code>**</p>
<p>如果有一个数据或事件，需要交给多个对象处理或执行。可以将这些处理对象封装为同一类型对象，数据/事件在这个对象链条上进行传递，就是**<code>职责链模式</code>**</p>
<p>如果系统中存在不同的状态，并且这些状态可以随着系统执行不断改变其中的状态时，就可以将这些状态封装为同一类型对象，核心执行逻辑可以不关心使用的具体对象，这就是**<code>状态模式</code>**</p>
<p>如果系统中存在不同的状态，并且在不同场景会使用不同对象时，就可以将这些状态封装为同一类型对象，要使用不同策略，仅需要将策略对象设置给该系统，这就是**<code>策略模式</code>**</p>
<p>如果某容器内有多个元素，想在不了解容器内部实现的情况下枚举其中的内部元素，就可以通过提供统一访问协议，容器来实现该协议以达到遍历的目的。这就是**<code>迭代器模式</code>**</p>
<p>如果某个对象有存取需求，并且不想暴露内部实现，就可以让该对象提供导出/导入状态的接口，在外部来存取相应数据。这就是**<code>备忘录模式</code>**</p>
<p>如果在完成某件任务时，有统一的执行流程，不同场景下的差异仅在于细节上的差异，就可以在抽象层实现流程和通用的执行细节，具体差异部分通过子类重写保留的接口来实现。这就是**<code>模板模式</code>**</p>
<p>如果想在不同场景对容器元素进行遍历操作并得到不同结果，并且要处理的元素类型比较固定，但处理的操作可能易变时，就可以让元素对象提供一个访问接口，然后把要处理的操作封装为<code>访问者对象</code>，访问者对象中可以对不同元素进行不同处理。这样就可以更好的满足OCP原则，这就是<strong>访问者模式</strong></p>
<p>如果一组对象之间相互调用的关系比较复杂，形成了网状的结构时，通过增加一个中间交互对象的方式，来将各对象之间相互的引用解耦开，就是**<code>中介者模式</code>**</p>
<blockquote>
<p>在行为类模式中，状态模式跟策略模式是很像的，从类图上来看也是一致的。但两个模式处理的问题场景是不同的。
比如登录问题很适合用状态模式，登录过程分为几个状态，这几个状态在开始登录后，会自动切换其中的状态，一种状态切为另一种状态可能会执行不同的操作，该系统给外界的反馈可能也会有差异。
一个软件是试用模式还是正式模式，就可以比较适合使用策略模式，比如试用版本时某些功能的调用受限。如果用户付了费，可以直接将另外一个策略替换当前策略。</p>
</blockquote>
<p>其中<code>Command模式</code>、<code>职责链模式</code>、<code>状态模式</code>、<code>策略模式</code>在类结构上是比较相似的，可以用简单语言来描述的其中差异：</p>
<ul>
<li>当一系列对象有统一行为接口，在抽象层可以按序执行它们，就是<code>Command模式</code></li>
<li>当一系列对象有统一行为接口，并且数据或事件会沿着这一系列对象传递时，就是<code>职责链模式</code></li>
<li>当一系列对象有统一行为接口，在不同时机会切换不同的对象，就是<code>状态模式</code></li>
<li>当一系列对象有统一行为接口，在不同的场景使用不同的对象，就是<code>策略模式</code></li>
</ul>
<h2 id="结语-2"><a class="header" href="#结语-2">结语</a></h2>
<p>现在再回过头来看，设计模式是什么呢？设计模式其实是针对场景总结出的设计经验。</p>
<p>学习设计模式最重要的是什么？<strong>透彻理解设计原则是最重要的</strong>。如果熟练掌握了设计原则，即使从来不知道设计模式，仍然能在开发过程中自然而然的用上设计模式。</p>
<p>当然并不是说设计模式没有价值，首先是它可以给我们一些指导和演示，告诉我们在某些场景下比较优秀的设计是什么样的。其次它是一种沟通语言，可以在不同的开发之间方便的传达设计思路。</p>
<h2 id="参考资料-2"><a class="header" href="#参考资料-2">参考资料</a></h2>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift/blob/master/README-CN.md">设计模式（Swift 5.0 实现）</a></li>
<li><a href="https://share.weiyun.com/unKs5RJG">设计模式迷你手册</a></li>
<li><a href="https://time.geekbang.org/column/intro/250">设计模式之美</a></li>
<li><a href="https://time.geekbang.org/column/intro/313">软件设计之美</a></li>
<li><a href="https://weread.qq.com/web/reader/480322f072021a3248038c8kc81322c012c81e728d9d180">架构整洁之道</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="解析极限编程笔记"><a class="header" href="#解析极限编程笔记">《解析极限编程》笔记</a></h1>
<h3 id="什么是极限编程"><a class="header" href="#什么是极限编程">什么是极限编程</a></h3>
<p><code>极限编程</code>(XP)是大家都听说过的词，但当问你极限编程是什么时？你也可能能说出极限编程是<code>测试驱动开发</code>，是<code>结队编程</code>、是<code>持续集成</code>等。但只是这些吗？</p>
<p>结队编程、TDD等，都只是极限编程的实践，是在XP原则下衍生出的具体做法。</p>
<p>那什么是极限编程呢？</p>
<ul>
<li>是一种开发哲学</li>
<li>是一套有用的实践</li>
</ul>
<p>极限编程是什么样的开发哲学呢？强调如下五种价值观的哲学：</p>
<ul>
<li>沟通</li>
<li>反馈</li>
<li>简单</li>
<li>勇气</li>
<li>尊重</li>
</ul>
<p>要彻底理解极限编程，也必须要以其<code>价值观</code>的点来入手</p>
<h3 id="价值观-1"><a class="header" href="#价值观-1">价值观</a></h3>
<h4 id="沟通-1"><a class="header" href="#沟通-1">沟通</a></h4>
<p>在团队软件开发中<strong>最要紧的是沟通</strong>。沟通对于创造团队意识和高效合作意识也是很重要的。每当你遇到一个问题，首先要确认这个问题是否由于缺乏沟通引起的，如果是，需要什么样的沟通来解决该问题，后续又应该如何来避免同样的问题。</p>
<h4 id="反馈-1"><a class="header" href="#反馈-1">反馈</a></h4>
<p>变化是不可能避免的，变化产生了对反馈的需要。</p>
<p>XP团队致力于在尽可能快的情况下产生尽可能多的反馈。</p>
<blockquote>
<p>如果将沟通的对象从人扩展为事时，反馈可以合入到沟通中。毕竟在人与事物的沟通中，事物给的响应就是反馈。
沟通与反馈本质上都是让信息更顺畅的流通，信息越顺畅、越快速的流动，组织或流程就越健康。</p>
</blockquote>
<h4 id="勇气-1"><a class="header" href="#勇气-1">勇气</a></h4>
<p>软件开发中的人们同样也会感到畏惧。</p>
<p>仅仅只有勇气是危险的，与其他价值观相呼应的勇气才是有力的。表达愉快或不愉快真相的勇气会有助于沟通和信任的建立；放弃失败的解决方案和寻求新方案的勇气会有助于鼓励对“简单”这一价值观的追求；寻求真实具体答案的勇气会有助于增加反馈。</p>
<h4 id="尊重-1"><a class="header" href="#尊重-1">尊重</a></h4>
<p>受软件开发影响的每个人，都有其作为人的价值观。不会有某个人本质上比其他人更有价值。所以要同时提高软件开发的人性和生产率，每个人对团队的贡献都应该得到尊重。我是重要的，你也是。</p>
<h4 id="简单-1"><a class="header" href="#简单-1">简单</a></h4>
<p>思考一个问题：什么是最简单而又有效的系统？ </p>
<p>构造一个优雅地解决今天问题同时又足够简单的系统是很难的。当随着系统发展，你需要让系统重新获得简单性时，你必须找到一条从你当前位置到目的地的路径。</p>
<blockquote>
<p>价值观之间是相互平衡和相互支持的。比如加强沟通能够去除那些不需要的或者可暂缓的需求，从而达到系统简单化的目的。</p>
</blockquote>
<h3 id="原则-1"><a class="header" href="#原则-1">原则</a></h3>
<h5 id="人"><a class="header" href="#人">人</a></h5>
<p>软件开发中最重要的就是人，要<strong>重视人的需求</strong></p>
<p>一名优秀开发者的需求：</p>
<ul>
<li>基本安全</li>
<li>成就感 （自我价值体现）</li>
<li>归属感 （得到认可、责任及为共同目标做贡献）</li>
<li>成长</li>
<li>亲切感 （与其他成员间的高度理解与被理解）</li>
</ul>
<p>人们需要做令他们感到自豪的工作。</p>
<h5 id="互惠互利"><a class="header" href="#互惠互利">互惠互利</a></h5>
<p><strong>互惠互利</strong>是XP中最重要的原则，也是最难坚持的原则。</p>
<p>互惠互利可以带来良好的工作关系，这个是很重要的，毕竟计算机业务其实是人的业务。如下几条实践都可以互惠互利：</p>
<ul>
<li>写自动化测试，让现在的我及以后的维护者都能获益</li>
<li>重构代码以消除系统复杂性，可以给自己带来满足感和更少的缺陷，也让维护者获益</li>
<li>写出良好的代码</li>
</ul>
<blockquote>
<p>有些事情需要注意可能看起来像是互惠互利，但其实并没有，比如详细写了很可能没人看的文档等。</p>
</blockquote>
<h5 id="自相似性"><a class="header" href="#自相似性">自相似性</a></h5>
<p>很多解决方案会有一定的普适性，而且能在不同粒度的问题上去使用，试着将一个解决方案的结构复制到一个新环境中。</p>
<h5 id="完美"><a class="header" href="#完美">完美</a></h5>
<p>在软件开发中，<strong>“完美”是个动词</strong>，而并非是形容词。“完美”是指通过不断<strong>改进</strong>达到完美。改进原则表示为实践就是：马上开始行动，随着时间的推移逐步精化结果。</p>
<p>软件开发技术的历史就是逐步减少浪费的人力的历史。</p>
<p>最大的浪费就是生产过剩的浪费。 -- 丰田 大野耐一</p>
<h5 id="多样性"><a class="header" href="#多样性">多样性</a></h5>
<p>团队需要将不同的技能、态度以及看待问题和缺陷的视角整合在一起，来考虑解决问题和实现解决方案的不同方法。<strong>团队需要多样性</strong>。</p>
<p>一个设计有两种想法，代表的是机会，而不是问题。</p>
<h5 id="反省"><a class="header" href="#反省">反省</a></h5>
<p>好的团队并不只是进行他们的工作，他们会思考如何工作和为什么工作。他们会分析为什么成功或失败。他们不会试图掩藏他们的错误，而是暴露它们并从中学习。谁都不可能突然间变优秀。也即好的团队非常重视<strong>思考和反思</strong>。 反省不用限制在正式场合，喝咖啡、聊天时都可以用来反省。</p>
<h5 id="机遇"><a class="header" href="#机遇">机遇</a></h5>
<p>要学会把问题看做改变的机遇，必须<strong>把问题转化为学习和改进的机遇</strong>。比如缺陷，虽然没有缺陷是令人满意的，但每一个缺陷都是团队学习和改进的机会。</p>
<h5 id="失败"><a class="header" href="#失败">失败</a></h5>
<p>失败不是浪费吗？不一定，在失败中沉淀出来的知识也可能是非常有价值的，而且这种价值有时候是很难获得的。</p>
<p>不要为了担心浪费编码时间，而进入长时间无休止的讨论中。做了一定的讨论后，做起来，<strong>失败好过无休止的讨论</strong>。在不知道如何做到更好的时候，冒一点风险失败可能是通向成功的最短最稳妥的道路。</p>
<h5 id="质量"><a class="header" href="#质量">质量</a></h5>
<p><strong>要求高质量通常导致更快的交付</strong>，而降低质量标准通常会导致更晚的不可预见的交付。缺陷、设计质量和开发经验衡量为度量，每一次质量的提高都会改进其他的项目属性。</p>
<p>如果你不知道做一项必需要做的工作的明确方法，那么<strong>尽你最大的努力去做</strong>。如果你知道但是需要的时间太长，那么用你现在所拥有的全部时间去做，稍后想办法完成它。</p>
<h5 id="责任"><a class="header" href="#责任">责任</a></h5>
<p>责任不能被指定，只能被接受；责任和权力需要并行。</p>
<h3 id="实践-2"><a class="header" href="#实践-2">实践</a></h3>
<p>在XP实践中，不要生搬硬套，要以核心价值观为根本。比如结对编程实践，只有为了沟通、获取反馈、简化系统、捕捉错误和提升勇气的结对编程才是真正有意义的。</p>
<p>XP实践概览：</p>
<p><img src="Article/./images/xp_practice.png" alt="XP实践概览" /></p>
<p>一次采取一个XP实践可能会看到改善，但多个实践结合在一起时你将会看到惊人的改进。</p>
<h5 id="坐一起"><a class="header" href="#坐一起">坐一起</a></h5>
<p>坐在一起工作是非常重要的：</p>
<ul>
<li>不管客户说的问题是什么，它终归是人的问题，单单用技术解决是不够的。</li>
<li>坐到一起来，用我们所有的感官知觉进行交流，这一点太重要了。</li>
</ul>
<h5 id="完整团队"><a class="header" href="#完整团队">完整团队</a></h5>
<p>人们需要团队感：</p>
<ul>
<li>我们属于它；</li>
<li>我们都在其中；</li>
<li>我们相互支持彼此的工作、成长和学习。</li>
</ul>
<p>在组织中，要避免“碎片人”的出现，即一部分工作时间支持A项目，另一部分时间支持B项目。这样会导致大量的时间浪费在工作任务的切换上。</p>
<h5 id="信息工作空间"><a class="header" href="#信息工作空间">信息工作空间</a></h5>
<p>团队最好有一个信息空间，一个对项目感兴趣的观察者，走进来之后可以在15秒内对项目如何运转有一个大致的概念。并且可以进一步通过近距离观察发现更多的问题或相关信息。 现在也可以建立电子信息空间来实现这一目的。</p>
<h5 id="充满活力地工作"><a class="header" href="#充满活力地工作">充满活力地工作</a></h5>
<p>软件开发是一个洞察力的游戏，而洞察力来自于准备好的、休息好的和放松的头脑。当你太疲倦的时候，你很难意识到你正在降低项目的价值。</p>
<p>你可以对工作时间做出更多改进。使用同样长的时间，但对时间进行更好的管理。每天明确两个小时的编码时间。关闭电话和邮件提醒，两个小时只进行编程。</p>
<h5 id="结队编程"><a class="header" href="#结队编程">结队编程</a></h5>
<p>结对程序员：</p>
<ul>
<li>使彼此都专注于任务；</li>
<li>一起头脑风暴，讨论系统的精化；</li>
<li>理清想法；</li>
<li>当搭档陷入困境时要主动，这样才能减少挫折；</li>
<li>使彼此都对团队的实践负责。</li>
</ul>
<p>结对并不意味着你不能独立思考，可以带着要思考的问题离开团队，思考、探索完成后，把想法带回团队。</p>
<p>结对时，需要让双方的个人空间都得到尊重，让双方都能处于一种舒适的状态(不同人的舒适距离可能也不一样)。 如果程序员感情上不够成熟，不能辨别鼓励与赞赏，那么和异性的结队工作可能会带来男女情感，而这对团队是不利的。</p>
<p>团队需要发挥好作用，让成员们都可以高效、舒适的工作。</p>
<h5 id="故事"><a class="header" href="#故事">故事</a></h5>
<p>用户故事，相比需求，可以更早的估算结果。在估算的过程中，也会让一些条件或限制更加明确出来，也便于决策。比如一台跑车或一台货车，要如何选择它们，就需要明确自己的条件、使用目的等。</p>
<h5 id="周循环"><a class="header" href="#周循环">周循环</a></h5>
<p>计划是一种必要的浪费。</p>
<p>任务的所有权对满足人类的占有欲有很大帮助。</p>
<h5 id="松驰"><a class="header" href="#松驰">松驰</a></h5>
<p>习惯性的高承诺所产生的令人难以置信的浪费：难以管理的缺陷负载，沮丧的士气和敌对的关系。实现承诺，即使是不起眼的，也会起到消除浪费的作用。</p>
<h5 id="持续集成-1"><a class="header" href="#持续集成-1">持续集成</a></h5>
<p>持续集成有同步模型和异步模型。一般情况下异步模型更受欢迎，因为CI代码之后，就可以开始后续的任务了，不需要等待当前检测结果。同步模型是指CI代码后，需要等这次CI验证通过后，才可以进行下一步工作。同步模型也有他的好处，在等待的时间，是一个很好的<strong>反省时间</strong>，可以思考刚才的代码是否有更好的写法及设计。</p>
<h5 id="增量设计"><a class="header" href="#增量设计">增量设计</a></h5>
<p>XP实践推荐<strong>增量设计</strong>，很难做到一步就能给出完美设计。开始给出一个足够的设计就可以开始工作，但要保证在设计上的投入与至今为止的系统需求成比例。</p>
<h3 id="实践xp"><a class="header" href="#实践xp">实践XP</a></h3>
<p>开始实践XP的步骤如下：</p>
<ul>
<li>一个团队首先需要对过去的经历进行准确的反省，有了反省才可以做出明确的决定。（先度量问题，以此意识到改变的必要性）</li>
<li>有了改变的意识，就开始执行</li>
<li>找一个实践开始执行，如结队编程，挑选我担心的一段代码，让别人跟我结对一两个小时写出它和系统另一部分的接口。</li>
<li>实践完之后再来反思其带来的改变，是否需要做什么调整。</li>
</ul>
<p>要实践XP，团队中的任何一个人都可以从自己开始。</p>
<p>如果我们在开发过程中带着人类的本性工作，就会产生大幅提升效率的机会。</p>
<p>在花费了项目预算的很小比率的资金之后，就应该进行最初的软件部署，这样可以及早得到反馈并进一步调整。</p>
<p>软件开发中有太多的浪费，而这些浪费的根源更多的来自于我们认知的误区。</p>
<p>首先改变自己，然后把改变的成果贡献给其他人。期望别人做你自己不想做的事情是无礼和低效的。模范带头开发是一种有力的领导形式。</p>
<p>教练应该有足够的技术能力来教导队员学习不易自学的知识。</p>
<h3 id="扩展实践-1"><a class="header" href="#扩展实践-1">扩展实践</a></h3>
<p>通用化一个成功的系统比定制一个不能解决任何人问题的系统更容易。</p>
<p>大组织常常忽视团队的价值，把“编程资源”比喻成分子/流体。一旦项目完成了，他们重新回到“池”中。这种调度的目标是充分利用所有的程序员。这种策略可以将微观效率最大化，但是会破坏组织的整体效率，它追求让每个个体都忙于敲打键盘的虚幻效率，而忽略了让员工尽量与熟悉和信任的同事一起工作的价值。</p>
<p>遇到问题后，要进行<strong>根源分析</strong>，采用不断问<strong>为什么</strong>的方式来分析根源。</p>
<p>共享代码和<strong>责任</strong>。团队成员可以共同承担责任，不仅为他们提交给用户产品的质量负责，也为他们给团队工作感到自豪。结队编程可以帮助队友彼此明确他们对彼此的质量承诺，同时也帮助他们对质量的组成达成共同的期望。</p>
<h3 id="完整xp团队-1"><a class="header" href="#完整xp团队-1">完整XP团队</a></h3>
<p>XP团队中的每个人都要把自己的未来跟他的工作领域联系起来。</p>
<p>流的原则表明，平稳的软件流比偶尔的大规模部署创造的价值更多。要让工作过程变成流，顺畅而又自然的状态。</p>
<p>在执行XP过程中，让每个角色都齐头并进（比任何一群人试图迫使其他人跟随其后）将会取得更多的进步。</p>
<p>将大的架构变化分解成小而安全的步骤，是XP团队的挑战之一。</p>
<p>测试能传达架构的意图。</p>
<p>项目经理同样要促进团队内部沟通以增强团队的凝聚力和信心。项目经理作为团队的一个高效的促进者，比作为一个重要信息的控制者，对团队的帮助更大。</p>
<p>一旦团队负担过重，产品经理要通过分析真实需求和设想需求之间的不同，来帮助团队决定优先做哪些事情。</p>
<p>主管人员要给XP团队提供勇气、自信和责任感。主管人员需要保持洞察力。</p>
<p>主管人员需要保持洞察力，才能在需要做出决策时，主管人员已经拥有了必要的信息来做出英明的决定。</p>
<p>XP团队可能不符合组织的要求，主管人员工作的一部分就是将团队积极地呈现在组织中其他部门面前。XP团队会坚持自己的优点，主管人员需要有在批评面前继续前进的勇气。</p>
<p>一个技术上极其熟练的独行者，和一个可以胜任工作同时具备较强社交能力的程序员，如果要在两人之中做个选择，XP团队一致地选择社交能力强的候选人。</p>
<p>成熟XP团队的角色不是固定和严格的。我们的目标是让每个人为团队的成功作出最大的努力。比如在某时刻，项目经理最适合为架构改进提供建议，那么项目经理就可以来给架构改进提建议。如果程序员适合写用户故事，那就让程序员来写用户故事。</p>
<h3 id="约束理论-1"><a class="header" href="#约束理论-1">约束理论</a></h3>
<p>约束理论认为任何系统在某一时间只存在一个约束（偶尔也会存在两个）。要提高系统的整体吞吐率，那么必须首先找出那个约束，并确保它能够全速工作。也即同一时间只关注一个最核心的问题，然后去优化它。</p>
<p>XP工作流，是采用“拉”模式。这种方式是故事在即将要实现时才做详细说明，进而由详细说明拉动着测试，然后设计程序接口来满足测试的需求。（也即是反过来驱动的一种方式）</p>
<p>约束理论假设：整个组织关注的是整体的吞吐率而不是微观的优化。</p>
<h3 id="计划管理范围-1"><a class="header" href="#计划管理范围-1">计划：管理范围</a></h3>
<p>XP中的计划开始于把当前的目的、假设和事实公布于众。</p>
<p>计划的一部分工作是从所有可能性中决定下一步要做什么。</p>
<p>XP中的计划不是对未来的预测，是根据今天所有的信息来预估明天可能会发生的事。计划的不确定性也并没有否定其价值。它能够帮助你与其他团队间的协调同步。</p>
<p>结对效率比单人的效率要高不止两倍。</p>
<p>事情进展不顺利的时候就是我们最需坚持价值观和原则的时候，同时修改我们已有的实践去尽可能地保持效率。不准确的评估是信息的错误，而不是价值观或者原则的错误。</p>
<h3 id="尽早测试经常测试自动测试-1"><a class="header" href="#尽早测试经常测试自动测试-1">尽早测试、经常测试、自动测试</a></h3>
<p>缺陷破坏了有效软件开发所需的信任。信任在软件开发中是非常重要的，包括开发者之间、开发者与其他角色之间的信任。当团队中充满信任时，整个团队士气和信心都是高涨的，开发效率也会更加高，而且会充满着创造力。所以尽可能降低缺陷是非常重要的，不仅仅是质量的问题。</p>
<p>XP的实践旨在，首先，通过清晰的沟通使得缺陷不再出现，其次，如果出现，保证团队借此学会如何在未来避免发生类似问题。</p>
<p>XP应用两个原则来提高测试的成本效益：复核，缺陷成本递增率：</p>
<ul>
<li>软件测试就是复核。</li>
<li>越早发现缺陷，所需的花费就越少。 （把测试资源转移到开发周期中成本就会更少）</li>
</ul>
<p>TDD优势：实现不应该过度影响接口。先写测试是完成这两者分离的具体方式。(TDD会驱动达到这个目的)</p>
<p>在XP中，测试与编程同样重要。</p>
<h3 id="设计时间的价值-1"><a class="header" href="#设计时间的价值-1">设计：时间的价值</a></h3>
<p>增量设计是早早交付功能，并且在项目生命周期中每周持续的交付功能。XP将软件设计的渐进主义推向一个极限。设计是日常事务的一部分，项目运转会更平稳。</p>
<p>软件是一种杠杆游戏。一个好的主意能够节省数百万美金的花费，同时创造数百万美金的收入。</p>
<blockquote>
<p>软件的杠杆效应，在<a href="https://book.douban.com/subject/7564417/">《Linux/Unix设计思想》</a>中有详细介绍
也要思考在工作上怎么样让自己的工作具有放大效应。</p>
</blockquote>
<p>增量设计：开始只需设计足够的东西来得到反馈，然后利用反馈改进设计，保证足以获得下一轮的反馈即可。在这个过程中，耐心是一个软件设计者可以拥有的最有价值的技能之一。</p>
<p>仔细思考设计可以产生一个好的答案，但是经验能够产生更好的设计答案。这儿所谓的经验，就是指前期初步的设计在适应开发的过程中沉淀出来的经验。</p>
<p>如果面对的是一堆乱麻的代码，也可以通过小步改进，让其逐渐变好。如果有不得不改大改的地方，将其记录下来，到时机允许时对其进行大的重构。</p>
<p>XP风格的设计就是<code>设计决策时期</code>的转换，推迟设计带来一些好处：（也即开始做够用的设计就好）</p>
<ul>
<li>更早部署软件</li>
<li>更容易根据执行情况做决策</li>
<li>更容易根据执行情况做出好的决策</li>
</ul>
<p>XP团队更喜欢简单的解决方案，趋向简单的项目可以改善软件开发的人性化和生产率。</p>
<h3 id="增大团队的规模-1"><a class="header" href="#增大团队的规模-1">增大团队的规模</a></h3>
<p>XP规模不单指人数，还有投资、时间、问题的复杂性等。</p>
<p>当遇到规模比较大的项目时，按照XP的原则，先进行最大化价值的尝试，然后进入迭代、反馈的循环，每次拿出一点成果。不管是人数，还是投资，都可以按照这种原则来处理。</p>
<h3 id="永恒的编程之道-1"><a class="header" href="#永恒的编程之道-1">永恒的编程之道</a></h3>
<p>在不同的人之间培养牢靠的关系，一起用软件赚钱。</p>
<p>XP依赖于有能力的程序员的成长：能够快速地评估、实现和部署可靠的软件。</p>
<p>XP依靠团队中的每一个成员，包括主管、经理和客户，每个人都要完全地负责并尽他们最大的努力。一个团队一起工作可完成超过它的成员单独努力的总和的工作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="浅谈函数式编程"><a class="header" href="#浅谈函数式编程">浅谈函数式编程</a></h1>
<h3 id="前言-5"><a class="header" href="#前言-5">前言</a></h3>
<p>网上关于函数式的资料参差不齐，基本都直接基于函数这个点来思考，也有些资料上来就开始讲一些数学概念，对大部分开发者很不友好。</p>
<p>很多资料里也大谈<code>Functor</code>、<code>Monad</code>、<code>Applicative</code>，但没有说明为什么需要存在这些概念。函数式也存在一些特性，如<code>纯函数</code>、<code>惰性求值</code>，这些也比较少介绍它们为什么是这样的。这样的话，理解起来就比较不容易，就会感觉函数式比较难入门。</p>
<p>本篇文章主要分析一下函数式编程的一些特性，会结合场景来分析为什么要有这些特性。整体上从以下几个点上来介绍函数式编程：</p>
<ul>
<li>函数式思维与命令式思维的区别</li>
<li>通过具体场景沉淀出map（或其它高阶函数）</li>
<li><code>Functor</code>、<code>Monad</code>、<code>Applicative</code>等常见概念介绍</li>
</ul>
<blockquote>
<p>代码示例使用Swift</p>
<p>现在对函数式的学习还是入门阶段，如果文章存在什么错误，欢迎指导交流。</p>
</blockquote>
<h3 id="函数式-vs-命令式"><a class="header" href="#函数式-vs-命令式">函数式 vs 命令式</a></h3>
<p>很多资料在讲函数式编程时，也以函数作为根本来讲，自己以前也是抓着函数来思考，也能很好的理解<code>柯里化</code>、<code>函数组合</code>等概念，但并不能非常灵活在适合的场景下使用函数式编程。</p>
<blockquote>
<p>柯里化学习：<a href="https://iweiyun.github.io/2018/09/04/curry-cleancode/">利用Swift柯里化处理重复代码</a></p>
<p>函数组合学习：<a href="https://iweiyun.github.io/2018/10/03/func-compose/">利用函数组合提升代码可维护性</a></p>
</blockquote>
<p>很重要的原因是把函数作为根本来思考时，是没有抓住核心，学起来也容易云里雾里，能学一些技巧，但思考方式没有太多变化。那么要学习函数式编程，要以什么为根本呢？要以数据为根本。</p>
<p>函数式编程与命令式编程的核心区别就是：<strong>函数式将数据作为主体，以流的思维来思考</strong></p>
<p>当在作为流处理时，缺什么补什么，如果没有某个接口，就封装某个接口，尽可能的把函数变得足够通用，粒度足够小，这样函数就更加容易被复用，通过组合这些小函数，就可以实现比较复杂的处理。</p>
<blockquote>
<p>https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ Haskell的标准库，很多都是小而美的函数</p>
</blockquote>
<h4 id="简单示例"><a class="header" href="#简单示例">简单示例</a></h4>
<p>假设有一个数组：[1, 2, 3, 4]，需要将所有元素翻倍</p>
<p>命令式：</p>
<pre><code class="language-swift">var lst = []
for i in [1, 2, 3, 4] {
    lst.add(i * 2)
}
</code></pre>
<p>函数式：</p>
<pre><code class="language-swift">let lst = [1, 2, 3, 4].map { $0 * 2 }
</code></pre>
<p>通过这个示例，虽然能感受到一些函数式带来的好处，让代码更简单、可读性更强了。但如果我们不理解map怎么来的，就无法自己去扩展系统没有提供的高阶方法。下面我们就基于 <strong>流思维</strong> 来推导一下map函数的产生。</p>
<h3 id="高阶函数map"><a class="header" href="#高阶函数map">高阶函数Map</a></h3>
<h4 id="1-2-3-4元素翻倍"><a class="header" href="#1-2-3-4元素翻倍">[1, 2, 3, 4]元素翻倍</a></h4>
<p>假设有个初始需求，就是将[1, 2, 3, 4]的所有元素都翻倍。</p>
<p>我们拿到需求后，尝试用函数式的思维来写代码，我们以数据为思考的原点，那就可以大概得出这样的代码：</p>
<pre><code class="language-swift">let lst = [1, 2, 3, 4].doubleElement()
</code></pre>
<p><code>doubleElement()</code>方法应该是什么样的呢？</p>
<pre><code class="language-swift">extension Array {
    func doubleElement() -&gt; Self where Element: Numeric {
        var result = [Element]()
        for i in self {
            result.append(i * 2)
        }
        return result
    }
}
</code></pre>
<p>现在已经满足了需求。</p>
<h4 id="1-2-3-4元素都乘3"><a class="header" href="#1-2-3-4元素都乘3">[1, 2, 3, 4]元素都乘3</a></h4>
<p>突然有一天，又多了一个需求，需要将[1, 2, 3, 4]所有元素都乘3</p>
<p>之前的<code>doubleElement</code>不满足需求了，可以再实现一个<code>tripleElement</code></p>
<pre><code class="language-swift">extension Array {
    func tripleElement() -&gt; Self where Element: Numeric {
        var result = [Element]()
        for i in self {
            result.append(i * 3)
        }
        return result
    }
}
</code></pre>
<p>跟<code>doubleElement</code>相比，除了乘的数字不一样，别的没什么区别了。那如何才能让代码不存在重复呢？而且要思考未来很可能出现的其它变化，今天是乘3，明天又可能是除2。</p>
<p>我们思考的就是如何把i * 3及i * 2这种代码提取出来，让外部来提供实现。我们将封装一个足够通用的接口：<code>transformElement</code>，并且外部传操作进来</p>
<pre><code class="language-swift">extension Array {
    func transformElement(_ t: (Element) -&gt; Element) -&gt; Self where Element: Numeric {
        var result = [Element]()
        for i in self {
            result.append(t(i))
        }
        return result
    }
}
</code></pre>
<p>当将操作提出去之后，发现对Element的约束也可以去掉了。所以最终就是这样的实现了：</p>
<pre><code class="language-swift">extension Array {
    func transformElement(_ t: (Element) -&gt; Element) -&gt; Self {
        var result = [Element]()
        for i in self {
            result.append(t(i))
        }
        return result
    }
}
</code></pre>
<p>当实现到这一步程度之后，我们就发现它是一个比较通用的接口了，而且能满足任意的同类型元素转换了</p>
<h4 id="1-2-3-4转为a-b-c-d"><a class="header" href="#1-2-3-4转为a-b-c-d">[1, 2, 3, 4]转为['a', 'b', 'c', 'd']</a></h4>
<p>某一天又多了这样一个需求：[1, 2, 3, 4]要转为['a', 'b', 'c', 'd']</p>
<p>我们之前实现的<code>transformElement</code>又不能满足了，毕竟我们只能转换同类型的元素。但这个都不是什么难题，只需要将返回类型用泛型来表示就好：</p>
<pre><code class="language-swift">func transform&lt;T&gt;(_ t: (Element) -&gt; T) -&gt; [T] {
    var result = [T]()
    for i in self {
        result.append(t(i))
    }
    return result
}
</code></pre>
<p>这就是简单的<code>map</code>的实现。其它类似<code>filter</code>、<code>reduce</code>这样的高阶函数也可以通过类似的场景来不断提炼得出来。</p>
<blockquote>
<p>Swift标准库中map的实现可以参考：<a href="https://github.com/apple/swift/blob/main/stdlib/public/core/Sequence.swift">Sequence.swift</a></p>
</blockquote>
<h3 id="函数式概念"><a class="header" href="#函数式概念">函数式概念</a></h3>
<p>函数式编程中有很多术语概念，可以在<a href="https://github.com/hemanth/functional-programming-jargon">functional-programming-jargon</a>中查看各种术语的描述。我们经常看到<code>Functor</code>、<code>Applicative</code>、<code>Monad</code>这几个概念，而且一些资料里大概给出这样的定义：</p>
<ul>
<li>实现了<code>map</code>运算函数的容器，是Functor</li>
<li>实现了<code>ap</code>运算函数的窗口，是Applicative</li>
<li>实现了<code>bind</code>运算函数的窗口，是Monad</li>
</ul>
<p>看这些定义，好像挺简单，但仅知道这些定义，对你理解函数式并没有什么帮助，因为这只是知道了一个概念。这儿更重要的是思考：为什么会存在这些概念，他们产生的背景是什么？</p>
<p>先说结论，函数式中的各种概念，是<strong>基于函数式编程思维下，沉淀出来的一些优秀实践</strong>。</p>
<p>在Swift中，可以把它们理解为协议。当说某个容器实现了Functor时，你就清楚它支持哪些能力了。</p>
<p>下面就逐个介绍下这三个常见概念的作用</p>
<blockquote>
<p>会结合Swift函数式编程库<a href="https://github.com/typelift/Swiftz">Swiftz</a>介绍</p>
</blockquote>
<h4 id="functor函子"><a class="header" href="#functor函子">Functor(函子)</a></h4>
<p>实现了<code>map</code>运算函数的容器，是Functor。</p>
<p>具体map的使用场景就不再展开，通过前面<code>Map的来源</code>就可以知道在很多场景下，通过不断提炼再提炼，就能把数据转化类型的操作都统一起来，变成了<code>map</code>接口。</p>
<p>在Swiftz中map的声明：</p>
<pre><code class="language-swift">func fmap(_ f : (A) -&gt; B) -&gt; FB	// FB即包装了一个值的容器
</code></pre>
<p>这儿有两个疑问点：</p>
<ul>
<li>为什么Functor要是容器？</li>
<li>为什么声明了map的Functor被拿出来强调，而类似filter这种也比较通用的没有被拿出来强调？</li>
</ul>
<h5 id="为什么functor要是容器"><a class="header" href="#为什么functor要是容器">为什么Functor要是容器？</a></h5>
<p>这个问题在<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html">JS函数式编程指南</a>中有介绍：</p>
<blockquote>
<p>让容器自己去运用函数能给我们带来什么好处？答案是抽象，对于函数运用的抽象。当 map 一个函数的时候，我们请求容器来运行这个函数。不夸张地讲，这是一种十分强大的理念。(容器是代表了任意，这样就可以把概念变的很抽象，甚至可以普适任意场景)</p>
</blockquote>
<p>是的，基于容器就实现了一种抽象，基于这种抽象，就可以让操作变得更灵活。Functor的map返回结果，仍然是一个容器，这样很容易针对该容器进行扩展，让其更强大，而且很容易实现链式操作，在容器上不断应用各种操作。</p>
<h5 id="为什么声明了map的functor被拿出来强调"><a class="header" href="#为什么声明了map的functor被拿出来强调">为什么声明了map的Functor被拿出来强调</a></h5>
<p>在平常开发中，类似<code>filter</code>、<code>reduce</code>等高阶函数也是经常使用的，它们的概念为什么没有拿出来强调。是跟稍后介绍的<code>Monad</code>有关系，Monad不仅仅是一个概念，你可以理解为它是函数式编程范式下常用的一种设计模式。</p>
<h4 id="applicative应用函子"><a class="header" href="#applicative应用函子">Applicative(应用函子)</a></h4>
<p>Applicative 是实现了<code>ap</code>方法的 Functor。</p>
<p>在Swiftz中它的定义为：</p>
<pre><code class="language-swift">public protocol Applicative : Functor {
	associatedtype FAB = K1&lt;(A) -&gt; B&gt;	// FAB即包装了一个函数的容器
	func ap(_ f : FAB) -&gt; FB	// associatedtype FB = K1&lt;B&gt;，FB即包装了一个值的容器
}
</code></pre>
<p><code>ap</code>函数签名比较类似<code>map</code>，但其函数也被包裹在了一个容器中。为什么要声明这样一个接口呢？</p>
<p>在Swift函数式的JSON解析库<a href="https://github.com/thoughtbot/Argo">Argo</a>中，有这样的使用示例：</p>
<pre><code class="language-swift">extension User: Decodable {
  static func decode(_ json: JSON) -&gt; Decoded&lt;User&gt; {
    return curry(User.init)
      &lt;^&gt; json &lt;| &quot;id&quot;
      &lt;*&gt; json &lt;| &quot;name&quot;
  }
}
</code></pre>
<blockquote>
<p>其中&lt;^&gt;是由map定义的运算符，&lt;*&gt;是由apply定义运算符</p>
</blockquote>
<p>简单解释下这段代码的执行流程：</p>
<ul>
<li><code>curry(User.init)</code>即将构造函数从 <code>(Int, String) -&gt; User</code> 转为 <code>(Int) -&gt; (String) -&gt; User</code> 这种签名</li>
<li><code>josn &lt;| &quot;id&quot; </code> 可以生成 <code>Decoded&lt;Int&gt;</code></li>
<li>构造函数使用&lt;^&gt;与<code>json &lt;| &quot;id&quot;</code>结合，即调用map，得到的结果为：<code>Decoded&lt;(String) -&gt; User&gt;</code></li>
<li>此时就会发现有转换函数已经被包装到容器之中了。这就是<code>ap</code>函数的使用场景</li>
</ul>
<blockquote>
<p>map后函数被包装的原因是，上个map返回的不是普通的值，而是函数值，函数值作为整体被解析为(String) -&gt; User</p>
</blockquote>
<p>不管构造函数的参数有多少，只要不断的这样推进解析，都可以这样来使用，让代码变得非常清晰、易维护。</p>
<h4 id="monad单子"><a class="header" href="#monad单子">Monad(单子)</a></h4>
<p>Monad是实现了<code>bind</code>的Applicative。</p>
<p>Swiftz中的定义为：</p>
<pre><code class="language-swift">public protocol Monad : Applicative {
	func bind(_ f : (A) -&gt; FB) -&gt; FB	// FB即包装了一个值的容器
}
</code></pre>
<p><code>bind</code>与<code>map</code>的区别就是转换函数，返回值仍然是被包装起来的。</p>
<blockquote>
<p><code>bind</code>在swift标准库里实现为<code>flatMap</code>，可以将二维数组压平为一维数组</p>
</blockquote>
<p>为什么又要存在<code>bind</code>声明呢？</p>
<p>当我们不必须限制执行过程中产生的数据类型时，就需要兼容转换函数返回的类型是否为<code>包装值</code>的情况。这可以理解为对使用场景的补充，而且有些情况，比如在Swift中二维数组转一维数组，如果不提供这种转换能力，高维的降维就会受限制。</p>
<p>Monad这个即使我们没有接触函数式，以前或多或少也有遇到过类似的处理模式。比如Promise，Promise中的<code>then</code>，你可以理解为<code>bind</code>的具体实现。在then中你仍然可以返回一个promise，then返回的也是一个promise。用promise写代码时，你就可以不断的用then来串联起异步的操作。</p>
<blockquote>
<p>这几个概念都是比较通用的处理逻辑，但如果发现这几个不满足时，可以自己扩展接口，实现新的协议的。</p>
</blockquote>
<h4 id="其它概念"><a class="header" href="#其它概念">其它概念</a></h4>
<h5 id="maybe"><a class="header" href="#maybe">Maybe</a></h5>
<p>其实就是Swift中的<code>Optional</code>，这个概念也在越来越多的语言中提供了，包括在Dart新版本中。</p>
<h5 id="lift"><a class="header" href="#lift">Lift</a></h5>
<p>其实就是Swift中的<code>reduce</code></p>
<h5 id="point-free"><a class="header" href="#point-free">Point-free</a></h5>
<p>是一个挺有趣的概念，即定义函数时，能不声明它的参数类型及参数名，就尽量不声明。即尽量用point-free风格的代码，这是两种代码的对比</p>
<pre><code class="language-swift">// Not point-free，类型和参数名都声明出来了
let addOne: (Int) -&gt; Int = { num in
    return num + 1
}

// point-free，让函数更加“值”化
let addOne = curry(+)(1)

// 使用都是一样的
addOne(2)	// 输出3
</code></pre>
<h5 id="纯函数-1"><a class="header" href="#纯函数-1">纯函数</a></h5>
<p>在函数式编程中，为什么强调纯函数呢？</p>
<p>纯函数的输入、输出是预期的，输入固定输出就是固定的。利用这种特性，能更好的把纯函数看成“值”，能更好的对函数进行变换、组合，才不会产生预期之外的情况。</p>
<h3 id="结语-3"><a class="header" href="#结语-3">结语</a></h3>
<p>虽然对map、fliter、reduce的使用可以理解为函数式编程，但这更多只是简单的使用。</p>
<p>要能根据场景自然而然的写出类似Argo这样的库，非常重要的是理解：</p>
<ul>
<li>
<p>为什么强调纯函数</p>
</li>
<li>
<p>为什么要支持柯里化（Haskell中函数是自动柯里化的）</p>
</li>
<li>
<p>怎么理解Monad等概念</p>
</li>
</ul>
<p>还要让<code>函数是一等公民</code>的意识深入骨髓，这样才能不受制于表达。要不断的强化某些场景下自己的思考路径，这样才能在遇到相应场景时，自然而然的想到如何更好的用函数式的方式来处理。</p>
<p>函数式编程在现代语言中得到越来越多的支持，而且在它善长的领域，它能带来很多开发优势，比如表达能力更强，代码量更少，代码更不容易出错等。在未来很可能是越来越多的人开始尝试它，并且也将有它的一席之地。有兴趣的小伙伴可以多一起交流讨论。</p>
<h3 id="参考资料-3"><a class="header" href="#参考资料-3">参考资料</a></h3>
<ul>
<li><a href="https://www.jianshu.com/p/001ff0dd3c30">函数式编程 - 一篇文章概述Functor(函子)、Monad(单子)、Applicative</a></li>
<li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">JS函数式编程指南</a></li>
<li><a href="https://github.com/typelift/Swiftz">Swiftz</a></li>
<li><a href="https://github.com/thoughtbot/Argo">Argo</a></li>
<li><a href="https://github.com/hemanth/functional-programming-jargon">functional-programming-jargon</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dart-list对象的高效操作"><a class="header" href="#dart-list对象的高效操作">Dart List对象的高效操作</a></h1>
<p>先看个dart中常见的操作：</p>
<pre><code class="language-dart">[1, 2, 3].where((e) =&gt; e &gt;= 2).toList();
</code></pre>
<p>列表处理完之后，需要再调用一下toList()操作，这儿开始是很不习惯的，觉得是比较冗余的。但仔细研究下才发现，是dart为了性能优化而做的妥协。</p>
<p>如果不能彻底理解这块，我们在使用集合操作时，很可能会写出性能很差的代码而不自知。</p>
<p>本文大概从如下几个方面介绍：</p>
<ol>
<li>同样的逻辑，不同的实现的性能对比</li>
<li>性能差异的原因</li>
<li>具体系统接口的实现</li>
<li>自己如何实现高效接口</li>
</ol>
<p>下面开始先对比下不同代码的性能。</p>
<h3 id="操作的性能分析"><a class="header" href="#操作的性能分析">操作的性能分析</a></h3>
<p>我们要做这样一件事情：将数组[1, 2, 3, 4, 5, 6]中的偶数取出来，并且将其翻倍。</p>
<p>思路的话，需要用到这两个高阶操作：<code>where</code>、<code>map</code>，它们的声明分别如下：</p>
<pre><code class="language-dart">// where
Iterable&lt;E&gt; where(bool test(E element));

// map
Iterable&lt;T&gt; map&lt;T&gt;(T f(E e))
</code></pre>
<p>这些操作返回的对象都是<code>Iterable</code>对象，返回值虽然不是<code>List</code>对象，只要调用<code>Iterable</code>提供的<code>toList()</code>转换一下就好。</p>
<p>先写如下的代码：</p>
<pre><code class="language-dart">var lst = [1, 2, 3, 4, 5, 6].where((e) =&gt; e % 2 == 0).toList();
lst.map((e) =&gt; e * 2);
</code></pre>
<p>这段代码执行耗时为：<em>2042 us</em></p>
<p>因为<code>map</code>是在<code>Iterable</code>中实现的，可以不将中间结果转为<code>List</code>，做如下调整：</p>
<pre><code class="language-dart">var lst = [1, 2, 3, 4, 5, 6].where((e) =&gt; e % 2 == 0);
lst.map((e) =&gt; e * 2);
</code></pre>
<p>再测试其执行耗时为：<em>493 us</em></p>
<p>性能竟然有<strong>4倍</strong>以上的差距！差别仅仅在于，中间生成的结果中是否从Iterable转为List了。</p>
<p>说明这个<code>toList()</code>并不是简单的类型转换，而是做了很多事情。下面我们详细分析下为什么会有这么大的性能差距。</p>
<h3 id="性能差异原因"><a class="header" href="#性能差异原因">性能差异原因</a></h3>
<p>Dart一定程度上也支持了函数式编程，并且标准库中提供了不少高阶函数，如<code>where</code>、<code>map</code>、<code>fold</code>、<code>reduce</code>等。</p>
<p>在函数式编程中，有一个很重要的一个特性：<strong>惰性求值</strong>，调用某个函数时，并不会立即真正执行函数，而是延迟到数据需要时才真正的进行调用！</p>
<p>这儿性能巨大差异原因就在这儿！<code>map</code>、<code>where</code>等都实现为了<code>lazy</code>的，也就是说，当执行完<code>where</code>之后，直接调用<code>map</code>，也只是拼接了一个操作，并没有真正计算。而执行完<code>where</code>之后，再调用<code>toList()</code>，会导致真正的操作计算，这儿肯定会有巨大的性能差异。</p>
<p>仔细看<code>map</code>和<code>where</code>的文档，确实有说明这两个方法是<code>lazy</code>的。</p>
<p>除了这两个方法之外，还有如下的接口都支持<code>lazy</code>：</p>
<ul>
<li><code>take(int count) → Iterable&lt;E&gt;</code></li>
<li><code>followedBy(Iterable&lt;E&gt; other) → Iterable&lt;E&gt;</code></li>
<li><code>takeWhile(bool test(E value)) → Iterable&lt;E&gt;</code></li>
<li><code>whereType&lt;T&gt;() → Iterable&lt;T&gt;</code></li>
</ul>
<p>知道性能差异的原因了，那使用时就需要注意了，<strong>如果在处理数据中有多个lazy型的函数，那么把它们连在一起调用，调用结束后再一起转为list</strong>。这样才能让代码最高效。</p>
<p>知道了性能差异的原因了，那这些接口是如何实现的呢？怎么才能把接口实现为lazy的？</p>
<h3 id="lazy实现"><a class="header" href="#lazy实现">Lazy实现</a></h3>
<p>我们分析下<code>where</code>接口的实现，先看其定义：</p>
<pre><code class="language-dart">Iterable&lt;E&gt; where(bool test(E element)) =&gt; WhereIterable&lt;E&gt;(this, test);
</code></pre>
<p>其实是返回了<code>Iterable</code>的一个子类：<code>WhereIterable</code>，我们再看<code>WhereIterable</code>的实现：</p>
<pre><code class="language-dart">class WhereIterable&lt;E&gt; extends Iterable&lt;E&gt; {
  final Iterable&lt;E&gt; _iterable;
    
  // 调用完where之后，只是将_f记录下来而已，后面真正需要时，这个_f才会被调用
  final _ElementPredicate&lt;E&gt; _f;

  WhereIterable(this._iterable, this._f);

  Iterator&lt;E&gt; get iterator =&gt; new WhereIterator&lt;E&gt;(_iterable.iterator, _f);
}

class WhereIterator&lt;E&gt; extends Iterator&lt;E&gt; {
  final Iterator&lt;E&gt; _iterator;
  final _ElementPredicate&lt;E&gt; _f;

  WhereIterator(this._iterator, this._f);

  bool moveNext() {
    while (_iterator.moveNext()) {
      // 真正获取where操作之后的结果时，才会调用这儿的逻辑，才会真正的执行
      if (_f(_iterator.current)) {
        return true;
      }
    }
    return false;
  }

  E get current =&gt; _iterator.current;
}
</code></pre>
<p>当我们调用完where之后，<strong>只是将操作记录起来了，并没有后续的操作</strong>。</p>
<p>只有我们真正的执行迭代获取数据时，才会调用<code>moveNext()</code>里的逻辑，此时才会真正的调用<code>where</code>中的判断接口，执行真正的逻辑。</p>
<p>当理解了系统的这个实现，我们实现自己的接口时，也就可以参照如此的实现，以提升操作性能。</p>
<h3 id="实现自己的高效接口"><a class="header" href="#实现自己的高效接口">实现自己的高效接口</a></h3>
<p>通过上面的代码，我们可以清楚如何实现自己的lazy函数，但这只是其中一种方式。除此之外，还有另外一种方式，即通过dart提供的<code>sync*</code> / <code>yield</code> / <code>yield*</code>来实现。我们分别使用这两种方式实现一些操作实例。</p>
<h4 id="继承iterable实现"><a class="header" href="#继承iterable实现">继承Iterable实现</a></h4>
<p>假设我们现在需要删除List中最后n个元素，那如何实现lazy版本的呢？</p>
<p>与<code>WhereIterable</code>实现是类似的，也是在<code>moveNext()</code>进行指定处理，当遍历到第n-1个之后，后面的数据就丢掉（通过<code>moveNext()</code>返回<code>false</code>丢弃）</p>
<p>实现代码：</p>
<pre><code class="language-dart">class DropLastIterable&lt;E&gt; extends Iterable&lt;E&gt; {
  final Iterable&lt;E&gt; _iterable;
  final int _length;  // _length为要保留的元素个数

  DropLastIterable(this._iterable, this._length);

  @override
  Iterator&lt;E&gt; get iterator =&gt; DropLastIterator(_iterable.iterator, _length);
}

class DropLastIterator&lt;E&gt; extends Iterator&lt;E&gt; {
  final Iterator&lt;E&gt; _iterator;
  final int _length;
  int _index = 0;

  DropLastIterator(this._iterator, this._length);

  @override
  E get current =&gt; _iterator.current;

  @override
  bool moveNext() {
    if (_index++ &gt;= _length) {
      return false;
    }
    return _iterator.moveNext();
  }
}
</code></pre>
<h4 id="通过-sync--yield--yield-实现"><a class="header" href="#通过-sync--yield--yield-实现">通过 sync* / yield / yield* 实现</a></h4>
<p>我们现在要将一个一维数组分解为二维数组，每个数组包含 size 或更少的项，代码实现如下：</p>
<pre><code class="language-dart">extension IterableExt&lt;E&gt; on Iterable&lt;E&gt; {
  Iterable&lt;List&lt;E&gt;&gt; chunk(int size) sync* {
    for (var i = 0; i &lt; length; i += size) {
      // sublist也是lazy的
      yield sublist(i, i + size &lt; length ? i + size : length);
    }
  }
}
</code></pre>
<p>这个实现，本质上也是返回的<code>Iterable</code>，外界迭代一次，这儿就返回一个<code>sublist</code>，不迭代时，这儿的<code>sublist</code>也不会执行。</p>
<p>除了这个示例中的<code>yield</code>操作可以返回一个元素，还有另外一个关键字：<code>yield*</code>，它后面可以跟一个集合，在返回时会把这个集合展开，比如要把二维数组压编为一维数组，用<code>yield*</code>就可以非常简单的实现：</p>
<pre><code class="language-dart">extension IterableExt&lt;E&gt; on Iterable&lt;E&gt; {
  Iterable&lt;E&gt; flatten() sync* {
    for (var e in this) {	// e是数组
      yield* e as Iterable&lt;E&gt;;
    }
  }
}
</code></pre>
<p>在某些情况下，用<code>sync*</code>的方式，可以极大的简化代码，而且也是以同步的思维来写异步代码。</p>
<h3 id="结语-4"><a class="header" href="#结语-4">结语</a></h3>
<p>这儿讨论的高效，更多是从集合的惰性求值上来说的，如果能正确的使用，它在很多情况下能节省不少不必要的操作。</p>
<p>本文仅针对<code>List</code>作的讲解，实际上<code>Set</code>、<code>Queue</code>都存在同样的情况，需要多关注文档上对接口的标注，是否有支持<code>lazy</code>计算。</p>
<p>还有些接口，虽然文档上没有说明，但真实的实现上，是实现为了lazy类型的方法，比如刚才说的List提供的<code>sublist</code>操作，也是lazy的。（有些List的实现，需要从<a href="https://github.com/dart-lang/sdk">dart sdk</a>中查看)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flutter开发笔记"><a class="header" href="#flutter开发笔记">Flutter开发笔记</a></h1>
<p>本篇笔记主要基于开发中遇到的一些问题记录，主要有如下几部分：</p>
<ul>
<li>代码相关，有dartfmt隐含的规则、空类型推断问题</li>
<li>工程相关，Flutter版本管理，以及工程文档能力</li>
<li>测试相关，Dart的Mock库，mockito的简单使用</li>
</ul>
<h3 id="dartfmt格式化问题"><a class="header" href="#dartfmt格式化问题">dartfmt格式化问题</a></h3>
<p>在开发中，我们习惯用<code>dartfmt</code>来格式化代码，但格式化出来的代码经常是有问题的，比如这段代码：</p>
<pre><code class="language-dart">void _push(BuildContext context, Widget widget) {
  Navigator.push(
      context,	// 4个空格宽度的缩进
      MaterialPageRoute(
        builder: (context) =&gt; widget,
      ));		// 最后的 ); 没有跟Navigator的左侧对齐
}
</code></pre>
<p>在上面这段代码中，存在两处问题：</p>
<ul>
<li>存在4个空格宽度的缩进</li>
<li>最后的<code>);</code>左侧没有跟<code>Navigator</code>的左侧对齐</li>
</ul>
<p>看起来是dartfmt的Bug，我们无能为力，但实际上是有办法可以解决的，只要在<code>);</code>前补一个逗号<code>,</code>，也即在 <code>push</code> **接口的最后一个参数后，也补上一个<code>,</code> **即可解决该问题，如下就是新的<code>dartfmt</code>格式化后的代码：</p>
<pre><code class="language-dart">void _push(BuildContext context, Widget widget) {
  Navigator.push(
    context,
    MaterialPageRoute(
      builder: (context) =&gt; widget,
    ),
  );
}
</code></pre>
<blockquote>
<p>这个是在<a href="https://flutter.dev/docs/development/tools/formatting">Flutter Code formatting</a>中推荐的做法</p>
</blockquote>
<h3 id="空类型推断的问题"><a class="header" href="#空类型推断的问题">空类型推断的问题</a></h3>
<p>在Dart中，可能会有一些反常识的非空类型推断，看如下代码：</p>
<pre><code class="language-dart">class MyDemo {
  String? v1;
  late String v2;
}

String getValue() {
  MyDemo? demo;

  if (demo != null) {
    return demo.v2; // 不需要对demo进行强制解包
  }

  if (demo?.v1 != null) {
    // return demo.v1; // 编译错误，需要对demo及v1进行强制解包
    return demo!.v1!; // 需要对demo进行强制解包
  }

  return '';
}
</code></pre>
<p>这段代码实际情况如注释，如果if对demo变量进行非空判断了，则在后面if体里面就不需要再对其强制解包。</p>
<p>但如果if体对demo的子成员进行非空判断了，在if包体中，仍然需要对demo及子成员变量进行强制解包</p>
<h3 id="flutter版本管理"><a class="header" href="#flutter版本管理">Flutter版本管理</a></h3>
<p>开发中，当涉及多个Flutter版本管理时，比较土的办法就是自己维护多个Flutter的版本，使用哪个版本，就将系统环境变量配置到需要的版本。除此之外还有两个比较方便的办法：</p>
<ul>
<li>使用 <a href="https://github.com/leoafarias/fvm">FVM</a> 工具</li>
<li>使用VSCode的setting配置</li>
</ul>
<h4 id="fvm"><a class="header" href="#fvm">FVM</a></h4>
<p>要使用FVM的话，安装完成之后，通过<code>fvm use version</code>命令就可以切换版本。FVM的实现原理就是通过一个default的软链接，来指向不同的flutter版本来自动切换的。这样就不需要去改环境变量了。</p>
<blockquote>
<p>FVM也支持仅针对当前工程指定某个Flutter版本，此时要执行flutter的命令时，都需要用<code>fvm flutter run</code>这样的形式</p>
</blockquote>
<h4 id="vscode-2"><a class="header" href="#vscode-2">VSCode</a></h4>
<p>当要管理的Flutter版本除系统提供的版本外，还有自己的版本时，使用FVM就不那么方便了。此时可以利用VSCode配置来配置指定的flutter版本。</p>
<ul>
<li><code>Command + Shift + P</code></li>
<li>输入：<code>Flutter: Change SDK</code></li>
<li>没有目标SDK时，可以先选择一个，会在工程目录下自动生成<code>settings.json</code>，修改<code>&quot;dart.flutterSdkPath&quot;</code>的value即可。</li>
</ul>
<h3 id="注释能力"><a class="header" href="#注释能力">注释能力</a></h3>
<p><code>dartdoc</code> 对注释的能力支持还是挺丰富的，其对 <code>markdown</code> 的语法做了挺多基本的支持。如：</p>
<ul>
<li>链接</li>
<li>代码块</li>
<li>分割线</li>
<li>多级标题</li>
<li>图片</li>
<li>列表</li>
<li>字体加粗、变斜等</li>
<li>内联html</li>
</ul>
<p>但也有一些常用的<code>markdown</code>语法没有支持：</p>
<ul>
<li>表格支持不好</li>
<li>TODO标签不支持, <code>- [ ] item</code></li>
<li>区块</li>
<li>其它高级特性</li>
</ul>
<p>虽然markdown能力支持不完善，但其通过内联html实现非常丰富的展现。比如甚至可以通过内联html支持iframe。</p>
<p>下面是一个注释demo示例：</p>
<pre><code class="language-dart">/// # 注释能力列表 (一级标题)
/// ## 这是二级标题
/// ### 这是三级标题
///
/// ----
///
/// 支持**加粗**
///
/// 支持*斜体*
///
/// 支持~~删除线~~
///
/// 通过html标签支持下划线：&lt;u&gt;Underlined Text&lt;/u&gt;
///
/// 通过html标签修改字体及颜色：&lt;font face=&quot;黑体&quot; color=green size=5&gt;我是绿色5号黑体字&lt;/font&gt;
///
/// ----
///
/// 支持图片：
/// ![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)
///
/// ----
///
/// 支持列表：
/// - 1111
/// - 2222
///
/// ----
///
/// 默认表格支持不完善：
///
/// | AAA | BBBB |
/// | --- | ---- |
/// | 111 | 2222 |
///
///
/// 通过html标签嵌入表格：
/// &lt;table border=&quot;1&quot;&gt;
///   &lt;tr&gt;
///     &lt;td&gt;row 1, cell 1&lt;/td&gt;
///     &lt;td&gt;row 1, cell 2&lt;/td&gt;
///   &lt;/tr&gt;
///   &lt;tr&gt;
///     &lt;td&gt;row 2, cell 1&lt;/td&gt;
///     &lt;td&gt;row 2, cell 2&lt;/td&gt;
///   &lt;/tr&gt;
/// &lt;/table&gt;
///
/// ----
/// 通过iFrame内嵌网页
///
/// &lt;iframe id=&quot;inlineFrameExample&quot;
///    title=&quot;Inline Frame Example&quot;
///    width=&quot;300&quot;
///    height=&quot;200&quot;
///    src=&quot;https://www.openstreetmap.org/export/embed.html?bbox=-0.004017949104309083%2C51.47612752641776%2C0.00030577182769775396%2C51.478569861898606&amp;layer=mapnik&quot;&gt;
/// &lt;/iframe&gt;
///
</code></pre>
<p>生成的html样式如下：</p>
<p><img src="Article/./images/dartdoc_demo.png" alt="image-20210531162202276" /></p>
<h3 id="mock框架"><a class="header" href="#mock框架">Mock框架</a></h3>
<p>各开发平台一般都有Mock库，通过Mock对象方便在测试时更改对象行为。</p>
<p>其它平台的Mock库，如<code>OCMock</code>，可以利用<code>反射</code>技术实现动态的创建Mock类。但在Flutter中使用的dart是不支持<code>反射</code>的，不过<code>pub.dev</code>中仍然有开源的<a href="https://pub.dev/packages/mockito">mockito</a>，是通过预编译阶段生成Mock对象来实现的。</p>
<p>其使用也相对简单，有如下步骤：</p>
<ol>
<li>在<code>pubspec.yaml</code>中，添加<code>dev_dependencies</code>的配置项：</li>
</ol>
<pre><code class="language-dart">  build_runner: ^2.0.4
  mockito: ^5.0.9
</code></pre>
<ol start="2">
<li>在指定的单元测试类中（如：<code>cat_test.dart</code>），进行如下声明：</li>
</ol>
<pre><code class="language-dart">import 'package:dartdoc_demo/src/cat.dart';
import 'package:mockito/annotations.dart';

@GenerateMocks([Cat])
void main() {}
</code></pre>
<p>在main函数(其它函数也可以)前面声明生成Cat类的Mock类：<code>@GenerateMocks([Cat])</code></p>
<ol start="3">
<li>
<p>执行：<code>dart run build_runner build</code>，即可在 <code>cat_test.dart</code>同目录下生成：<code>cat_test.mocks.dart</code></p>
</li>
<li>
<p>在测试代码中就可以使用<code>MockCat</code>对象了</p>
</li>
</ol>
<pre><code class="language-dart">var cat = MockCat();
when(cat.sound()).thenReturn(&quot;Purr&quot;);
expect(cat.sound(), &quot;Purr&quot;);
</code></pre>
<blockquote>
<p>接口的使用跟其它的Mock框架比较类似</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build_runner使用"><a class="header" href="#build_runner使用">build_runner使用</a></h1>
<p>[TOC]</p>
<h3 id="概述"><a class="header" href="#概述">概述</a></h3>
<p><code>builder_runner</code>可以在预编译阶段做一些自己的事情。如：</p>
<ul>
<li>预编译阶段分析dart代码进行预处理，如根据真实对象生成Mock对象。</li>
<li>预编译阶段分析其它类型文件进行预处理，如可以支持pb文件分析生成dart代码。</li>
<li>……</li>
</ul>
<p>目前在<code>pub.dev</code>上有不少工具，都有使用<code>build_runner</code>。如：</p>
<ul>
<li><a href="https://pub.dev/packages/mockito">mockito</a>：Mock框架，在预编译阶段生成Mock对象</li>
<li><a href="https://pub.dev/packages/json_serializable">json_serializable</a>：可以自动生成对象与Json数据的转换接口，避免体力活 (<a href="https://pub.dev/packages/to_string">to_string</a>类似，可以自动生成toString实现)</li>
</ul>
<p>熟悉了该工具的使用，可以很大程度的扩展自己的思考边界，可以想一些不敢想的事情。</p>
<p>本文会从如下三个方面来讲解<code>build_runner</code>：</p>
<ul>
<li>最简单的build_runner使用</li>
<li>最简单的代码解析</li>
<li>build_runner工具本身的介绍</li>
</ul>
<h3 id="最简单示例"><a class="header" href="#最简单示例">最简单示例</a></h3>
<h4 id="工程创建"><a class="header" href="#工程创建">工程创建</a></h4>
<p>创建一个最简单的builder_runner使用工程</p>
<p>1、创建一个dart package (如：<code>dart create --template=package-simple buildver</code>)</p>
<p>2、根目录新建<code>build.yaml</code>，并设置为如下内容：</p>
<pre><code class="language-json">builders:
  build_version:
    import: &quot;package:buildver/builder.dart&quot;
    builder_factories: [&quot;buildVersion&quot;]
    build_extensions: {&quot;$lib$&quot;: [&quot;version.dart&quot;]}
    build_to: source
    auto_apply: dependents
</code></pre>
<p>3、lib中的文件清除掉，新建<code>builder.dart</code>，并设置为如下内容</p>
<pre><code class="language-dart">import 'dart:async';
import 'package:build/build.dart';
import 'package:pubspec_parse/pubspec_parse.dart';

Builder buildVersion(BuilderOptions options) =&gt; _VersionBuilder();

class _VersionBuilder implements Builder {
  @override
  Future build(BuildStep buildStep) async {
    final assetId = AssetId(buildStep.inputId.package, 'pubspec.yaml');

    final content = await buildStep.readAsString(assetId);
    final pubspec = Pubspec.parse(content, sourceUrl: assetId.uri);

    await buildStep.writeAsString(
        AssetId(buildStep.inputId.package, 'lib/version.dart'),
        &quot;const packageVersion = '${pubspec.version}';&quot;);
  }

  @override
  final buildExtensions = const {
    r'$lib$': ['version.dart']
  };
}
</code></pre>
<p>4、<code>pubspec.yaml</code>中添加依赖</p>
<pre><code class="language-json">dependencies:
  build_runner: ^2.0.0
  pubspec_parse: ^1.0.0
</code></pre>
<p>5、创建<code>example</code>工程，并在<code>dev_dependencies</code>中引入<code>buildver</code>的依赖</p>
<p>6、在example中执行：<code>pub run build_runner build</code></p>
<p>7、检查example/lib/version.dart文件，正常情况下该文件已经生成，并且写入了版本号的定义</p>
<h4 id="示例说明"><a class="header" href="#示例说明">示例说明</a></h4>
<h5 id="buildyaml"><a class="header" href="#buildyaml">build.yaml</a></h5>
<p>这个文件是构建配置文件，配置了构建操作的入口函数，要处理的文件等信息。</p>
<p>我们需要重点关注这两个配置项的作用：</p>
<ul>
<li><code>builder_factories</code>：指定了构建的入口函数，执行<code>pub run build_runner build</code>时会挨个执行这些函数。(函数签名是固定的，要返回<code>B</code>)</li>
<li><code>build_extensions</code>：指定要处理的文件类型。示例中<code>$lib$</code>，是表示lib目录。 </li>
</ul>
<blockquote>
<p>该配置文件的详细介绍可以参考：<a href="https://github.com/dart-lang/build/tree/master/build_config">build_config</a>的使用</p>
</blockquote>
<h5 id="builderdart"><a class="header" href="#builderdart">builder.dart</a></h5>
<pre><code class="language-dart">// 构建入口，签名是固定的
Builder buildVersion(BuilderOptions options) =&gt; _VersionBuilder();

// 这儿即可以使用implements组合Builder，也可以使用extends继承Builder
class _VersionBuilder implements Builder {
  // build和buildExtensions是需要重载的接口和属性
  @override
  Future build(BuildStep buildStep) async {
    // buildStep中包含了一些构建的信息，比如输入文件等
    final assetId = AssetId(buildStep.inputId.package, 'pubspec.yaml');

    final content = await buildStep.readAsString(assetId);
    final pubspec = Pubspec.parse(content, sourceUrl: assetId.uri);

    // 通过BuildStep提供的writeAsString接口，就可以将指定的代码写入指定的文件
    await buildStep.writeAsString(
        AssetId(buildStep.inputId.package, 'lib/version.dart'),
        &quot;const packageVersion = '${pubspec.version}';&quot;);
  }

  @override
  final buildExtensions = const {
    // 这儿的定义，与build.yaml中的build_extensions的要对应起来
    r'$lib$': ['version.dart']
  };
}
</code></pre>
<blockquote>
<p>示例来至<a href="https://pub.dev/packages/build_version">build_version</a>，做了少量简化</p>
</blockquote>
<h3 id="代码解析"><a class="header" href="#代码解析">代码解析</a></h3>
<p><code>build_runner</code> 不仅可以做这些简单的读写文件操作，也可以对dart代码做一定的分析与处理。</p>
<p>假设有如下代码：</p>
<pre><code class="language-dart">@MyAnnotation('hello')
void main() {
}
</code></pre>
<p>我们需要识别处<code>@MyAnnotation('hello')</code>，并能获取其携带的参数，并做一些处理，那应该如何做呢？</p>
<p>通过调试可以发现，<code>buildStep.resolver.libraryFor</code>接口可以获取一个<code>LibraryElement</code>的对象，该对象中包含了各种代码相关信息。截图如下：</p>
<img src="Article/images/build_runner_ast.png" alt="img" style="zoom:50%;" />
<p>之所以可以拿到代码相关信息，是因为<code>build_runner</code>依赖的<a href="https://github.com/dart-lang/sdk/tree/master/pkg/analyzer">analyzer</a>有提供相应代码分析的能力。</p>
<p>如果自己从<code>LibraryElement</code>中解析各种数据，还是比较繁琐的。Dart官方因此提供了一个辅助工具：<a href="https://pub.dev/packages/source_gen">source_gen</a>，可以方便的帮我们识别<code>Annotation</code>等代码信息。</p>
<p>具体<code>source_gen</code>的使用示例比较简单，而且网络上很多<code>build_runner</code>资料也都是基于这个工具来讲解的。</p>
<h3 id="build_runner工具介绍"><a class="header" href="#build_runner工具介绍">build_runner工具介绍</a></h3>
<h4 id="实现简介"><a class="header" href="#实现简介">实现简介</a></h4>
<p><code>build_runner</code>是官方提供的预编译工具，很容易让我们误以为其是跟编译工具链在一起的。</p>
<p>并非如此，<code>build_runner</code>只是一个普通的dart package，通过<code>pub run</code>运行该package而已。（参考：<a href="https://dart.cn/tools/pub/cmd/pub-run">pub-run</a>）</p>
<p>其代码的入口即是位于<code>bin/build_runner.dart</code>中，如果要看它的实现，可以从该入口跟进。</p>
<p>虽然可以简单理解<code>build_runner</code>是一个dart package，但其实现还是较复杂的，而且依赖了大量的其它库：</p>
<ul>
<li><a href="https://pub.dev/packages/analyzer">analyzer</a>：代码解析</li>
<li><a href="https://pub.dev/packages/build_config">build_config</a>:<code>build.yaml</code>的解析</li>
<li><a href="https://pub.dev/packages/dart_style">dart_style</a>：支持代码格式化</li>
<li><a href="https://pub.dev/packages/build">build</a>：构建步骤</li>
<li>……</li>
</ul>
<h4 id="工程调试"><a class="header" href="#工程调试">工程调试</a></h4>
<ul>
<li>
<p>首次调试前，先在 <code>example</code> 目录下执行：<code>pub run build_runner build</code>，以生成调试的入口文件：<code>build.dart</code></p>
</li>
<li>
<p>在<code>launch.json</code>中，将<code>example (debug mode)</code>中program的入口文件，指向自己生成的</p>
</li>
<li>
<p>在VSCode执行 <code>example (debug mode)</code> 这个target就可以调试了</p>
</li>
</ul>
<p>如果在调试时，发现断点无法中断，可以在<code>example</code>目录执行这两个命令，然后再重新尝试调试：</p>
<ul>
<li><code>pub run build_runner clean</code></li>
<li><code>pub run build_runner build</code></li>
</ul>
<blockquote>
<p>参考：https://stackoverflow.com/questions/58628425/how-run-flutter-packages-pub-run-build-runner-build-with-debug-mode-in-intelli</p>
</blockquote>
<h4 id="能力限制"><a class="header" href="#能力限制">能力限制</a></h4>
<p><code>build_runner</code>本身提供的能力虽然很强大，但也不是非常灵活。如：</p>
<ul>
<li>对源文件本身的修改比较受限，现有的实现，都是生成新的文件</li>
<li>如果针对<code>main.dart</code>进行预处理，生成的文件只能在<code>main.dart</code>的同组目录下，并且名称要提前定义好，如：<code>main.g.dart</code></li>
</ul>
<p>如果想针对源文件进行修改，可以尝试的办法就是生成新的文件后，再删除老的源文件，但这样可能会破坏代码文件的稳定。</p>
<p>针对第二个问题，去修改<code>build_runner</code>的实现是一个办法，但其对其它工具的依赖也可能涉及改动，比如构建步骤的约束，就是在<code>build</code>工具中做的限制。如果要修改的话，就可能涉及多个依赖工具，维护起来会比较麻烦。</p>
<p>问题二，还有一个办法就是生成文件后，将其再移动到新目录或修改名称。这个方案是推荐的实现。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="词法语法分析工具介绍"><a class="header" href="#词法语法分析工具介绍">词法&amp;语法分析工具介绍</a></h1>
<p>[TOC]</p>
<h2 id="背景"><a class="header" href="#背景">背景</a></h2>
<p>说起语法和和语法分析工具，我们很多同学都会下意识的觉得是写编译器用的，离我们比较远，跟我们工作没什么关系。但举个例子，我们看下面这个问题该如何解决。</p>
<p>有如下这样一个纯文本的配置文件，如果要解析这个配置文件，有什么办法？</p>
<pre><code class="language-sh">config {
	host docs.qq.com;
	port 80;
}
</code></pre>
<p>我们可能会找到一些解决办法，比如用<code>正则表达式</code>来解析、以<code>JSON</code>的格式来作为配置文件等。如果格式就是自定义的，并且随着业务的发展，配置内容越来越复杂，包含嵌套等复杂的规则，那我们又如何解决呢？</p>
<p>其实这种问题用词法分析工具是很容易解决。具体工具，除了以前学校里教的<code>lex</code>、<code>yacc</code>，现在还有python版本的<code>PLY</code>，<code>ANTLR</code>等。了解了一个工具的使用，其它的使用也都比较类似。</p>
<h2 id="lex--yacc-1"><a class="header" href="#lex--yacc-1">lex &amp; Yacc</a></h2>
<p>其实在Mac上，默认就安装有GUN版本的Lex&amp;Yacc工具：<code>flex</code>、<code>bison</code>，不需要再单独安装上什么工具就可以使用。不过在Mac上，<code>flex</code>工具也可以直接用<code>lex</code>来调用，两个命令是同样的。</p>
<h3 id="lex"><a class="header" href="#lex">lex</a></h3>
<p>先看一段最简单的示例</p>
<pre><code class="language-c">%{
	// a.l
    #include &lt;stdio.h&gt;
%}
%%
[0-9]+ printf(&quot;Number received!&quot;);
[a-zA-Z]+ printf(&quot;Word received!&quot;);
%%
</code></pre>
<p>执行如下几步操作：</p>
<ul>
<li><code>lex a.l</code>	(会生成<code>lex.yy.c</code>文件)</li>
<li><code>cc lex.yy.c -ll</code>   (会生成a.out文件)</li>
<li><code>./a.out</code></li>
</ul>
<p>此时就可以通过输入数字、字符串来看执行效果。其中核心即是两个匹配语句，通过正则表达式来匹配相应内容。</p>
<p>lex文件分为3部分，用两个<code>%%</code>来分隔</p>
<pre><code class="language-sh">%{
	// 第1部分%{ %}中的内容，都会原样的输出到生成的.c文件中
	// 所依赖的头文件，要定义的宏等，都放在这儿
%}
%%
第2部分内容，用来定义词法规则
即示例中的stop、start指令，其实这儿是使用正则表达式来匹配规则的
匹配规则之后，可以跟上自己的处理语句，语句可以为多句，用大括号括起来。
正则表达式的使用可以参考：https://people.cs.aau.dk/~marius/sw/flex/Flex-Regular-Expressions.html
%%
// 第3部分是另外的C代码，可以定义自己的函数、main函数等
</code></pre>
<p>Lex的手册，可以参考：<a href="http://westes.github.io/flex/manual/index.html">Lexical Analysis With Flex, for Flex 2.6.2</a></p>
<h3 id="yacc"><a class="header" href="#yacc">Yacc</a></h3>
<p>如果只有lex，则仅能做词法分析，以及做一些简单的逻辑处理，当做一些复杂的逻辑处理时，仍然不可避免的要使用Yacc工具。现在再考虑一个相对复杂点的使用场景，写一个加法计算器。</p>
<p>在词法分析这一步，简单来说就是匹配<code>+</code>和<code>数字</code>。匹配到之后再解析语句，将结果加起来。</p>
<p>示例代码如下，并做了简单注释：(代码来源：<a href="https://sighingnow.github.io/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/lex_yacc.html">Lex和Yacc</a>，做了删减，一些详细说明可以参考该文章)</p>
<p>a.l:</p>
<pre><code class="language-c">%{
#include &lt;stdio.h&gt;
int yywrap();
void yyerror(char *);
#include &quot;a.tab.h&quot;	// 这个是yacc(bison)工具生成的代码文件
%}

%%

[0-9]+ { yylval = atoi(yytext); return INTEGER; }	// yytext、yylval都是工具内置的变量，比如yytext表示匹配到的字符串
[\+\n] { return *yytext; }		// 这儿有匹配换行，是用来换行后用来计算程序结果的
. { yyerror(&quot;invalid char.&quot;); } // 这个是表示匹配剩余的场景

%%

int yywrap() { return 1; }
</code></pre>
<p>a.y:</p>
<pre><code class="language-c">// yacc的文件结构和lex是一样的，都是由两个%%分成3部分，核心也是中间部分
%{
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int yylex();
void yyerror();
%}

// 这儿定义的token，可以在lex文件中使用，作标识用
%token INTEGER
%left '+'

%%

// 入口
program:
    program expr '\n' { printf(&quot;result: %d\n&quot;, $2); }
    |		// 这儿是用来匹配空的，作为结束的出口
    ;

expr:
    INTEGER { $$ = $1; }
    | expr '+' expr { $$ = $1 + $3; }	// 这儿有个递归处理的逻辑，1+2+3，第2个expr首次会匹配到2+3，然后再递归使用这个表达式
    | { yyerror(&quot;invalid input.\n&quot;); }
    ;

%%

// 语法分析错误时，会调用该函数
void yyerror(char *s)
{
    printf(&quot;YACC erro: %s\n&quot;, s);
}

int main()
{
    yyparse();
    return 0;
}
</code></pre>
<p>有了这个工具，现在再回头看那个配置文件解析的，就是一件不算复杂的事情了。</p>
<h2 id="其它工具-1"><a class="header" href="#其它工具-1">其它工具</a></h2>
<p>其它的工具使用上有很多类似的，现在用的比较多的有<code>ANTLR4</code>、<code>PLY</code>等</p>
<h3 id="antlr4-1"><a class="header" href="#antlr4-1">ANTLR4</a></h3>
<p><a href="https://github.com/antlr/antlr4">ANTLR4</a>是现在使用比较多的工具，并且能力也非常强。支持非常多语言代码的生成，比如JS、OC、Python等</p>
<p>要使用ANTLR4，主要的工作是g4文件中定义规则，用<code>antrl4</code>生成相应源码后，再实现自己的<code>listener</code>或<code>visitor</code></p>
<p>简单示例代码如下：(示例来源：<a href="https://zhuanlan.zhihu.com/p/31644101">编程语言试验之Antlr4+JavaScript实现&quot;圈4&quot;</a>)</p>
<p>hello.g4</p>
<pre><code class="language-javascript">grammar hello;

program   : 求约数;

求约数  : '求约数' Number ;

Number  : [0-9]+ ;
Space   : [ \n\t]+ -&gt; skip;
</code></pre>
<p>调用命令：<code>antlr4 -Dlanguage=JavaScript -visitor hello.g4</code>，生成相应的js源文件</p>
<p>然后再实现自己的MyListener.js：</p>
<pre><code class="language-javascript">const helloListener = require('./helloListener.js').helloListener

MyListener = function () {
  helloListener.call(this);
  return this;
}

MyListener.prototype = Object.create(helloListener.prototype);
MyListener.prototype.constructor = MyListener;

// exit***和enter***是标准的接口，表示匹配到某个规则之后，进入和进出的处理时机
MyListener.prototype.exit求约数 = function(ctx) {
  var num = parseInt(ctx.getChild(1).getText());
  console.log(num + &quot;的约数: &quot; + 求约数(num));
};

function 求约数(num) {
  var result = [];
  for (var i = 1; i &lt; num - 1; i++) {
    if (num % i == 0) {
      result.push(i);
    }
  }
  return result;
}

exports.MyListener = MyListener;
</code></pre>
<p>除此之外，Python版本的<a href="https://github.com/dabeaz/ply">PLY</a>、JS版本的<a href="https://github.com/zaach/jison">Jison</a>，以及基于<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95">PEG</a>规则实现的<a href="https://zhuanlan.zhihu.com/p/49833910">PEG.js</a>，功能上都是比较类似的工具，可以根据自己的需求做选择。</p>
<h2 id="参考资料-4"><a class="header" href="#参考资料-4">参考资料</a></h2>
<ul>
<li><a href="https://sighingnow.github.io/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/lex_yacc.html">Lex和Yacc</a></li>
<li><a href="http://westes.github.io/flex/manual/index.html">Lexical Analysis With Flex, for Flex 2.6.2</a></li>
<li><a href="https://abcdabcd987.com/notes-on-antlr4/">ANTLR4 笔记</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wkwebview-cookie开发及需要注意的点"><a class="header" href="#wkwebview-cookie开发及需要注意的点">WKWebview Cookie开发及需要注意的点</a></h1>
<p>[TOC]</p>
<h2 id="cookie设置方式"><a class="header" href="#cookie设置方式">Cookie设置方式</a></h2>
<h3 id="一通过header中的cookies字段来设置"><a class="header" href="#一通过header中的cookies字段来设置">一、通过Header中的Cookies字段来设置</a></h3>
<pre><code class="language-swift">var req = URLRequest(url: myURL!)
let cookieValue = &quot;uin=10000; uid=10001&quot;
req.addValue(cookieValue, forHTTPHeaderField: &quot;Cookie&quot;)
self.webView.load(req)
</code></pre>
<blockquote>
<p>这种设置方式，仅在请求头里包含，前端页面通过<code>document.cookie</code>是无法读取到的</p>
</blockquote>
<h3 id="二通过js注入的方式来设置"><a class="header" href="#二通过js注入的方式来设置">二、通过JS注入的方式来设置</a></h3>
<pre><code class="language-swift">let script = &quot;document.cookie = 'aaaaa=11111; domain=127.0.0.1; path=/; '; document.cookie = 'bbbbbb=22222; domain=127.0.0.1; path=/; ';&quot;
let us = WKUserScript(source: script, injectionTime: .atDocumentStart, forMainFrameOnly: false)
self.webView?.configuration.userContentController.addUserScript(us)
</code></pre>
<h3 id="三通过将cookie存储至wkhttpcookiestore中"><a class="header" href="#三通过将cookie存储至wkhttpcookiestore中">三、通过将Cookie存储至<code>WKHTTPCookieStore</code>中</a></h3>
<pre><code class="language-swift">let wkStore = WKWebsiteDataStore.default().httpCookieStore
cookies.forEach { cookie in
	wkStore.setCookie(cookie)
}
</code></pre>
<h3 id="四通过svr端set-cookie设置"><a class="header" href="#四通过svr端set-cookie设置">四、通过Svr端<code>Set-Cookie</code>设置</a></h3>
<pre><code class="language-swift">// node.js
app.get('/', (req, res) =&gt; {
  let options = {
      domain: 'matthewyan1.repl.co',
      maxAge: 30 * 86400000, // 1 months
      httpOnly: true, // The cookie only accessible by the web server
  }

  // Set cookie
  res.cookie('myTestCookie', '223', options)
  res.send('Hello World!!!')
})
</code></pre>
<h2 id="cookie删除方式"><a class="header" href="#cookie删除方式">Cookie删除方式</a></h2>
<h3 id="一通过wkwebsitedatastore的removedata接口来删除"><a class="header" href="#一通过wkwebsitedatastore的removedata接口来删除">一、通过<code>WKWebsiteDataStore</code>的<code>removeData</code>接口来删除</a></h3>
<pre><code class="language-swift">let types = Set(arrayLiteral: WKWebsiteDataTypeCookies)
let store = WKWebsiteDataStore.default()
store.fetchDataRecords(ofTypes: types) { cookies in
    store.removeData(ofTypes: types, for: cookies) {
        print(&quot;cookies clear result:\(records.count &gt; 0)&quot;)
    }
}
</code></pre>
<h3 id="二通过wkwebsitedatastore中的httpcookiestore提供的delete接口来删除"><a class="header" href="#二通过wkwebsitedatastore中的httpcookiestore提供的delete接口来删除">二、通过<code>WKWebsiteDataStore</code>中的<code>httpCookieStore</code>提供的<code>delete</code>接口来删除</a></h3>
<pre><code class="language-swift">let wkStore = WKWebsiteDataStore.default().httpCookieStore
wkStore.getAllCookies { cookies in
    cookies.forEach { cookie in
        wkStore.delete(cookie) {
            print(&quot;cookie:\(cookie.name) clear ok&quot;)
        }
    }
}
</code></pre>
<h3 id="三服务端通过set-cookie来清除cookie"><a class="header" href="#三服务端通过set-cookie来清除cookie">三、服务端通过<code>Set-Cookie</code>来清除Cookie</a></h3>
<pre><code class="language-javascript">// node.js
app.get('/', (req, res) =&gt; {
  let options = {
      domain: 'matthewyan1.repl.co',
      httpOnly: true, // The cookie only accessible by the web server
  }

  /*
  express的clearCookie的实现
  本质是通过将过期时间设置为过去的一个过期时间来实现cookie被清除的
  res.clearCookie = function clearCookie(name, options) {
	  var opts = merge({ expires: new Date(1), path: '/' }, options);
  	return this.cookie(name, '', opts);
	};
  */
  // clear cookie，使用的express提供的clearCookie接口
  res.clearCookie('myTestCookie', options)

  res.send('Clear Ok!!!')
})
</code></pre>
<blockquote>
<p>需要注意的是，在清楚cookie时，<code>max-Age</code>就不要再设置了，如果<code>max-Age</code>也设置了的话，会以<code>max-Age</code>为准了</p>
</blockquote>
<h2 id="容易踩的坑"><a class="header" href="#容易踩的坑">容易踩的坑</a></h2>
<h3 id="domain域"><a class="header" href="#domain域">Domain域</a></h3>
<p><strong><code>.qq.com</code> 与 <code>qq.com</code> 是不同的！</strong></p>
<p>在平常开发中，很容易出现的一个问题就是 <code>.qq.com</code> 和 <code>qq.com</code> 会混用，但这两个实际上是不一样的。</p>
<p>严格来说，<code>qq.com</code>仅对<code>www.qq.com</code>和<code>qq.com</code>生效，并不能对类似<code>support.qq.com</code>生效的。但各种实现差异挺大，即使仅WKWebview中Cookie的使用，就有一些不同的表现。</p>
<p>假设要访问的url为<code>support.qq.com</code>：</p>
<ul>
<li>通过JS注入Cookie的方式，如果域设置为<code>qq.com</code>，则系统在设置cookie时，会自动转换为<code>.qq.com</code></li>
<li>Svr端设置Cookie，如果域设置为<code>qq.com</code>，则到终端之后，也会自动转换为<code>.qq.com</code></li>
<li>通过<code>WKHTTPCookieStore</code>设置Cookie，如果域设置为<code>qq.com</code>，则在请求时，该cookie是无法带上的</li>
<li>通过<code>WKHTTPCookieStore</code>设置Cookie，如果域设置为<code>.qq.com</code>或 <code>.support.qq.com</code> ，则该cookie是可以正常带上的</li>
</ul>
<p>假设要访问的url为<code>abc.support.qq.com</code>：</p>
<ul>
<li>Svr端设置Cookie，如果Cookie域为<code>qq.com</code>，则会自动转换为<code>.qq.com</code></li>
<li>Svr端设置Cookie，如果Cookie域为<code>support.qq.com</code>，则不会转换为<code>.support.qq.com</code></li>
</ul>
<p>看上面的各种策略，并没有统一的规律，即使在iOS这一个平台上，表现就比较混乱，这儿是非常需要注意的！</p>
<h3 id="302跳转"><a class="header" href="#302跳转">302跳转</a></h3>
<p><strong>如果在首个url请求的header中设置了cookie，则后续302跳转的请求header，会被重置为开始设置的Cookie！</strong></p>
<p>在请求Header中设置Cookie，是为了解决首个请求Cookie带不上的问题。参考:<a href="https://blog.devlxx.com/2018/05/08/WKWebView%E7%9A%84Cookie%E9%97%AE%E9%A2%98/">WKWebView的Cookie问题</a></p>
<p>如果在302跳转时，首个请求在header中设置了Cookie，Svr也通过<code>Set-Cookie</code>来设置了新的Cookie，但跳转链接是无法带上新Cookie的！而且在跳转发生的过程中，开发者是无法介入重新种Cookie的。</p>
<p>302跳转的时候，WKWebview的回调如下：</p>
<pre><code class="language-swift">// 1. 是否允许首个链接打开
func webView(WKWebView, decidePolicyFor: WKNavigationAction, decisionHandler: (WKNavigationActionPolicy) -&gt; Void)

// 2. 页面开始加载
func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!)

// 3. 是否允许跳转链接打开
func webView(WKWebView, decidePolicyFor: WKNavigationAction, decisionHandler: (WKNavigationActionPolicy) -&gt; Void)

// 4. 允许跳转链接之后，就通知链接跳转事件
func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!)

// 5. 收到请求的响应包之后，决定是否允许跳转
func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: @escaping (WKNavigationResponsePolicy) -&gt; Void)

// 6. 允许跳转之后，就开始接收页面内容
func webView(_ webView: WKWebView, didCommit navigation: WKNavigation!)

// 7. 页面加载完成
func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!)
</code></pre>
<p>这儿是没有时机在第二个请求header中种入新的cookie的。</p>
<p>如果在开发中有这样的场景，只能考虑在跳转发生时，终止跳转，并且用新的url重新发起一次请求，或针对这些页面，不再首个请求header里设置Cookie。</p>
<h2 id="资料-47"><a class="header" href="#资料-47">资料</a></h2>
<ul>
<li>
<p><a href="https://repl.it/@matthewyan1/SvrCookieDemo#index.js">Svr端重定向Demo代码</a></p>
</li>
<li>
<p><a href="https://github.com/renaesop/blog/issues/4">cookie规范</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-其它"><a class="header" href="#12-其它">12. 其它</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概念术语"><a class="header" href="#概念术语">概念/术语</a></h1>
<h3 id="六西格玛"><a class="header" href="#六西格玛">六西格玛</a></h3>
<p>是指产品质量问题需要控制在 6 个标准误差里面。</p>
<img src="Other/images/concept/six_sigma.jpg" style="zoom:50%;" />
<blockquote>
<p>标准误差相关的详细解释及公式参考：https://time.geekbang.org/column/article/407445</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计相关"><a class="header" href="#设计相关">设计相关</a></h1>
<h3 id="设计工具"><a class="header" href="#设计工具">设计工具</a></h3>
<p>一般使用 <a href="https://www.sketch.com/">sketch</a></p>
<p>Sketch可以添加已有的组件库，这样就可以复用别人画好的组件来画图，能大大提高效率。</p>
<p>Sketch组件添加方式：</p>
<ul>
<li>下载相应sketch类型文件</li>
<li>打开该文件</li>
<li>&quot;文件&quot; -&gt; &quot;导入组件库&quot;</li>
</ul>
<p>这样就可以复用已有的组件了</p>
<h4 id="苹果官方sketch-library"><a class="header" href="#苹果官方sketch-library">苹果官方Sketch Library</a></h4>
<p>苹果官方也提供了<code>Sketch Library</code>，方便在sketch中直接导入iOS/Mac的组件。</p>
<p>下载地址：<a href="https://developer.apple.com/design/resources/">Apple Design Resources</a></p>
<p>直接点击第一个<a href="sketch://add-library?url=https%3A%2F%2Fdeveloper.apple.com%2Fdesign%2Fdownloads%2Fsketch.rss">Add iOS Sketch Library</a>，即可以跳至sketch中安装。</p>
<h4 id="ant-design的sketch组件包"><a class="header" href="#ant-design的sketch组件包">Ant Design的sketch组件包</a></h4>
<p>https://ant.design/docs/spec/download-cn</p>
<h3 id="交互工具"><a class="header" href="#交互工具">交互工具</a></h3>
<p><a href="https://zhuanlan.zhihu.com/p/54234625">2019年值得关注的四个交互原型工具</a></p>
<p>交互图也可以使用sketch来画</p>
<h3 id="图标库"><a class="header" href="#图标库">图标库</a></h3>
<p><font color=#f33 size=5>要注意版权，不同的资源版权可能不同</font></p>
<p><a href="https://www.iconfont.cn/">iconfont</a></p>
<p><a href="https://www.flaticon.com/">flaticon</a></p>
<p><a href="https://www.iconfinder.com/">iconfinder</a></p>
<p><a href="https://www.vecteezy.com/">vecteezy</a></p>
<h3 id="配色方案"><a class="header" href="#配色方案">配色方案</a></h3>
<p><a href="https://www.colorsupplyyy.com/app">colorsupplyyy</a></p>
<p><a href="https://color.adobe.com/zh/create/color-wheel/">adobe</a></p>
<p><a href="https://colorhunt.co/">colorhunt</a></p>
<p>渐变色：<a href="https://uigradients.com/">uigradients</a></p>
<h3 id="设计常用网站"><a class="header" href="#设计常用网站">设计常用网站</a></h3>
<p><a href="https://dribbble.com/">dribbble</a></p>
<p><a href="https://www.behance.net/">behance</a></p>
<p><a href="https://www.zcool.com.cn/">zcool</a></p>
<p><a href="https://www.pinterest.com/">pinterest</a></p>
<p>插画：<a href="https://stevescott.com.au/">stevescott</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="博客搭建"><a class="header" href="#博客搭建">博客搭建</a></h1>
<h3 id="搭建githubio博客"><a class="header" href="#搭建githubio博客">搭建github.io博客</a></h3>
<ul>
<li>创建仓库，参考：<a href="https://sspai.com/post/54608">GitHub Pages 搭建教程</a></li>
<li>使用<a href="https://hexo.io/zh-cn/docs/">hexo博客框架</a>，<a href="https://theme-next.iissnan.com/getting-started.html">Next主题</a></li>
<li><code>npm install -g hexo-cli</code></li>
<li><code>hexo init blog</code></li>
<li><code>cd blog</code></li>
<li><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></li>
<li><code>npm install hexo-renderer-swig</code></li>
<li><code>npm install hexo-deployer-git</code> 支持直接往github上部署</li>
<li>在站点配置文件中启用next主题：<code>theme: next</code></li>
<li>deploy中，配置正确的type及repository等信息</li>
<li><code>hexo server</code> 查看本地运行效果</li>
<li><code>hexo deploy</code> 发布博客，将其部署至指定仓库</li>
<li><code>hexo new &lt;title&gt;</code> 来创建新的文章</li>
</ul>
<p>如果想支持author：</p>
<ul>
<li>打开<code>themes/next/layout/_macro/post.swig</code>，在 <code>{% if post.comments %}</code> 之前插入如下代码</li>
<li><code>&lt;span&gt; ｜ &lt;/span&gt;&lt;span class=&quot;fa fa-user-o&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#222;&quot;&gt; {{ post.author }}&lt;/span&gt;</code></li>
<li>在文档前面添加上author字段：<code>author: xxx</code></li>
<li><code>hexo clean &amp; hexo server</code>，即可查看效果</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos"><a class="header" href="#macos">MacOS</a></h1>
<h4 id="禁用密码过期提示"><a class="header" href="#禁用密码过期提示">禁用密码过期提示</a></h4>
<ul>
<li><code>pwpolicy getaccountpolicies</code> 查看当前帐户设置</li>
<li><code>pwpolicy getaccountpolicies &gt; temp.xml</code> 将配置写入临时文件中</li>
<li>删除<code>temp.xml</code>中第一行这样的内容：<code>Getting global account policies</code></li>
<li>保存之后，再使用<code>pwpolicy setaccountpolicies temp.xml</code>进行设置</li>
<li>如果想确认当前登录帐帐号：<code>pwpolicy getaccountpolicies -u $(id -nu)</code></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
