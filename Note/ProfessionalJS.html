<!DOCTYPE HTML>
<html lang="zh-Hnas" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JavaScript高级程序设计 - 开发知识库</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Common/index.html"><strong aria-hidden="true">1.</strong> 通用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Common/Git.html"><strong aria-hidden="true">1.1.</strong> Git</a></li><li class="chapter-item expanded "><a href="../Common/VI.html"><strong aria-hidden="true">1.2.</strong> VI</a></li><li class="chapter-item expanded "><a href="../Common/Shell.html"><strong aria-hidden="true">1.3.</strong> Shell</a></li><li class="chapter-item expanded "><a href="../Common/Markdown.html"><strong aria-hidden="true">1.4.</strong> Markdown</a></li><li class="chapter-item expanded "><a href="../Common/Regex.html"><strong aria-hidden="true">1.5.</strong> 正则表达式</a></li><li class="chapter-item expanded "><a href="../Common/Test.html"><strong aria-hidden="true">1.6.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../Common/Database.html"><strong aria-hidden="true">1.7.</strong> 数据库</a></li><li class="chapter-item expanded "><a href="../Common/Network.html"><strong aria-hidden="true">1.8.</strong> 网络</a></li><li class="chapter-item expanded "><a href="../Common/Tools.html"><strong aria-hidden="true">1.9.</strong> 常用工具</a></li><li class="chapter-item expanded "><a href="../Common/Algorithm.html"><strong aria-hidden="true">1.10.</strong> 算法</a></li><li class="chapter-item expanded "><a href="../Common/Graphics.html"><strong aria-hidden="true">1.11.</strong> 图像处理</a></li><li class="chapter-item expanded "><a href="../Common/OperateSystem.html"><strong aria-hidden="true">1.12.</strong> 操作系统</a></li><li class="chapter-item expanded "><a href="../Common/Secure.html"><strong aria-hidden="true">1.13.</strong> 安全</a></li></ol></li><li class="chapter-item expanded "><a href="../Software/index.html"><strong aria-hidden="true">2.</strong> 软件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Software/Architecture.html"><strong aria-hidden="true">2.1.</strong> 软件架构</a></li><li class="chapter-item expanded "><a href="../Software/SoftwareDesign.html"><strong aria-hidden="true">2.2.</strong> 软件设计</a></li><li class="chapter-item expanded "><a href="../Software/DesignPattern.html"><strong aria-hidden="true">2.3.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="../Software/Document.html"><strong aria-hidden="true">2.4.</strong> 设计文档</a></li></ol></li><li class="chapter-item expanded "><a href="../iOS/index.html"><strong aria-hidden="true">3.</strong> iOS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../iOS/Performance.html"><strong aria-hidden="true">3.1.</strong> 性能相关</a></li><li class="chapter-item expanded "><a href="../iOS/UI.html"><strong aria-hidden="true">3.2.</strong> UI相关</a></li><li class="chapter-item expanded "><a href="../iOS/Swift.html"><strong aria-hidden="true">3.3.</strong> Swift</a></li><li class="chapter-item expanded "><a href="../iOS/ObjC.html"><strong aria-hidden="true">3.4.</strong> Objective-C</a></li><li class="chapter-item expanded "><a href="../iOS/SwiftUI.html"><strong aria-hidden="true">3.5.</strong> SwiftUI</a></li><li class="chapter-item expanded "><a href="../iOS/Runtime.html"><strong aria-hidden="true">3.6.</strong> Runtime</a></li><li class="chapter-item expanded "><a href="../iOS/Thread.html"><strong aria-hidden="true">3.7.</strong> 多线程</a></li><li class="chapter-item expanded "><a href="../iOS/Event.html"><strong aria-hidden="true">3.8.</strong> 事件相关</a></li><li class="chapter-item expanded "><a href="../iOS/WKWebview.html"><strong aria-hidden="true">3.9.</strong> WKWebview</a></li><li class="chapter-item expanded "><a href="../iOS/Sign.html"><strong aria-hidden="true">3.10.</strong> 签名相关</a></li><li class="chapter-item expanded "><a href="../iOS/Test.html"><strong aria-hidden="true">3.11.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../iOS/Device.html"><strong aria-hidden="true">3.12.</strong> 设备及系统</a></li><li class="chapter-item expanded "><a href="../iOS/Framework/index.html"><strong aria-hidden="true">3.13.</strong> 框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../iOS/Framework/ReactiveObjC.html"><strong aria-hidden="true">3.13.1.</strong> ReactiveObjC</a></li><li class="chapter-item expanded "><a href="../iOS/Framework/SDWebImage.html"><strong aria-hidden="true">3.13.2.</strong> SDWebImage</a></li></ol></li><li class="chapter-item expanded "><a href="../iOS/Question.html"><strong aria-hidden="true">3.14.</strong> 问题集合</a></li></ol></li><li class="chapter-item expanded "><a href="../Web/index.html"><strong aria-hidden="true">4.</strong> Web</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Web/HTML.html"><strong aria-hidden="true">4.1.</strong> HTML</a></li><li class="chapter-item expanded "><a href="../Web/CSS.html"><strong aria-hidden="true">4.2.</strong> CSS</a></li><li class="chapter-item expanded "><a href="../Web/JS.html"><strong aria-hidden="true">4.3.</strong> JS</a></li><li class="chapter-item expanded "><a href="../Web/TypeScript.html"><strong aria-hidden="true">4.4.</strong> TypeScript</a></li><li class="chapter-item expanded "><a href="../Web/React.html"><strong aria-hidden="true">4.5.</strong> React</a></li><li class="chapter-item expanded "><a href="../Web/Vue.html"><strong aria-hidden="true">4.6.</strong> Vue</a></li><li class="chapter-item expanded "><a href="../Web/WebAssembly.html"><strong aria-hidden="true">4.7.</strong> WebAssembly</a></li><li class="chapter-item expanded "><a href="../Web/CROS.html"><strong aria-hidden="true">4.8.</strong> 同源策略 &amp; 跨域</a></li><li class="chapter-item expanded "><a href="../Web/Cookie.html"><strong aria-hidden="true">4.9.</strong> Cookie</a></li><li class="chapter-item expanded "><a href="../Web/DOM.html"><strong aria-hidden="true">4.10.</strong> DOM</a></li><li class="chapter-item expanded "><a href="../Web/JSEngine.html"><strong aria-hidden="true">4.11.</strong> JS引擎</a></li><li class="chapter-item expanded "><a href="../Web/Canvas.html"><strong aria-hidden="true">4.12.</strong> Canvas</a></li></ol></li><li class="chapter-item expanded "><a href="../Flutter/index.html"><strong aria-hidden="true">5.</strong> Flutter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Flutter/Reference.html"><strong aria-hidden="true">5.1.</strong> Flutter框架</a></li><li class="chapter-item expanded "><a href="../Flutter/Dart.html"><strong aria-hidden="true">5.2.</strong> Dart</a></li><li class="chapter-item expanded "><a href="../Flutter/Layout.html"><strong aria-hidden="true">5.3.</strong> 布局</a></li><li class="chapter-item expanded "><a href="../Flutter/Animation.html"><strong aria-hidden="true">5.4.</strong> 动画</a></li><li class="chapter-item expanded "><a href="../Flutter/Widgets.html"><strong aria-hidden="true">5.5.</strong> 组件</a></li><li class="chapter-item expanded "><a href="../Flutter/State.html"><strong aria-hidden="true">5.6.</strong> 状态管理</a></li><li class="chapter-item expanded "><a href="../Flutter/Theme.html"><strong aria-hidden="true">5.7.</strong> 主题</a></li><li class="chapter-item expanded "><a href="../Flutter/Source.html"><strong aria-hidden="true">5.8.</strong> 源码 &amp; 原理</a></li><li class="chapter-item expanded "><a href="../Flutter/Test.html"><strong aria-hidden="true">5.9.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../Flutter/Performance.html"><strong aria-hidden="true">5.10.</strong> 性能相关</a></li><li class="chapter-item expanded "><a href="../Flutter/Web.html"><strong aria-hidden="true">5.11.</strong> Web开发</a></li><li class="chapter-item expanded "><a href="../Flutter/Desktop.html"><strong aria-hidden="true">5.12.</strong> Desktop开发</a></li></ol></li><li class="chapter-item expanded "><a href="../Server/index.html"><strong aria-hidden="true">6.</strong> 后台</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Server/Linux.html"><strong aria-hidden="true">6.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="../Server/Go.html"><strong aria-hidden="true">6.2.</strong> GO语言</a></li><li class="chapter-item expanded "><a href="../Server/NodeJS.html"><strong aria-hidden="true">6.3.</strong> Node.js</a></li><li class="chapter-item expanded "><a href="../Server/Docker.html"><strong aria-hidden="true">6.4.</strong> Docker</a></li><li class="chapter-item expanded "><a href="../Server/K8S.html"><strong aria-hidden="true">6.5.</strong> K8S</a></li></ol></li><li class="chapter-item expanded "><a href="../Language/index.html"><strong aria-hidden="true">7.</strong> 语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Language/Swift.html"><strong aria-hidden="true">7.1.</strong> Swift</a></li><li class="chapter-item expanded "><a href="../Language/Dart.html"><strong aria-hidden="true">7.2.</strong> Dart</a></li><li class="chapter-item expanded "><a href="../Language/CPP.html"><strong aria-hidden="true">7.3.</strong> C++</a></li><li class="chapter-item expanded "><a href="../Language/Rust.html"><strong aria-hidden="true">7.4.</strong> Rust</a></li><li class="chapter-item expanded "><a href="../Language/JS.html"><strong aria-hidden="true">7.5.</strong> JS</a></li><li class="chapter-item expanded "><a href="../Language/TypeScript.html"><strong aria-hidden="true">7.6.</strong> TypeScript</a></li><li class="chapter-item expanded "><a href="../Language/WebAssembly.html"><strong aria-hidden="true">7.7.</strong> WebAssembly</a></li><li class="chapter-item expanded "><a href="../Language/Haskell.html"><strong aria-hidden="true">7.8.</strong> Haskell</a></li><li class="chapter-item expanded "><a href="../Language/ArmAssembly.html"><strong aria-hidden="true">7.9.</strong> ARM汇编</a></li><li class="chapter-item expanded "><a href="../Language/Compiler.html"><strong aria-hidden="true">7.10.</strong> 编译器</a></li><li class="chapter-item expanded "><a href="../Language/Functional.html"><strong aria-hidden="true">7.11.</strong> 函数式编程</a></li></ol></li><li class="chapter-item expanded "><a href="../CrossPlatform/index.html"><strong aria-hidden="true">8.</strong> 跨平台</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../CrossPlatform/ReactNative.html"><strong aria-hidden="true">8.1.</strong> React Native</a></li><li class="chapter-item expanded "><a href="../CrossPlatform/Hippy.html"><strong aria-hidden="true">8.2.</strong> Hippy</a></li></ol></li><li class="chapter-item expanded "><a href="../Note/index.html"><strong aria-hidden="true">9.</strong> 笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Note/10xWork.html"><strong aria-hidden="true">9.1.</strong> 10x程序员工作法</a></li><li class="chapter-item expanded "><a href="../Note/ProfessionalJS.html" class="active"><strong aria-hidden="true">9.2.</strong> JavaScript高级程序设计</a></li><li class="chapter-item expanded "><a href="../Note/XSW_ArchTech.html"><strong aria-hidden="true">9.3.</strong> 许式伟的架构课</a></li><li class="chapter-item expanded "><a href="../Note/DDD_Distilled.html"><strong aria-hidden="true">9.4.</strong> 领域驱动设计精粹</a></li><li class="chapter-item expanded "><a href="../Note/SoftwareDesign.html"><strong aria-hidden="true">9.5.</strong> 软件设计之美</a></li><li class="chapter-item expanded "><a href="../Note/DDDPractice.html"><strong aria-hidden="true">9.6.</strong> DDD实战课</a></li><li class="chapter-item expanded "><a href="../Note/DDDThoughtworks.html"><strong aria-hidden="true">9.7.</strong> 领域驱动设计综述(Thoughtworks洞见)</a></li><li class="chapter-item expanded "><a href="../Note/SoftwareArchitecture.html"><strong aria-hidden="true">9.8.</strong> 架构整洁之道</a></li><li class="chapter-item expanded "><a href="../Note/XPExplained.html"><strong aria-hidden="true">9.9.</strong> 解析极限编程</a></li><li class="chapter-item expanded "><a href="../Note/RustSwift.html"><strong aria-hidden="true">9.10.</strong> Rust / Swift对比</a></li></ol></li><li class="chapter-item expanded "><a href="../Article/READMD.html"><strong aria-hidden="true">10.</strong> 文章</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Article/SoftwareDesign.html"><strong aria-hidden="true">10.1.</strong> 浅谈软件设计</a></li><li class="chapter-item expanded "><a href="../Article/ExtremeProgramming.html"><strong aria-hidden="true">10.2.</strong> 解析极限编程</a></li><li class="chapter-item expanded "><a href="../Article/FunctionalProgramming.html"><strong aria-hidden="true">10.3.</strong> 浅谈函数式编程</a></li><li class="chapter-item expanded "><a href="../Article/DartIterableEffective.html"><strong aria-hidden="true">10.4.</strong> Dart中自定义Iterable高效操作</a></li><li class="chapter-item expanded "><a href="../Article/FlutterExperience.html"><strong aria-hidden="true">10.5.</strong> Flutter开发小结</a></li><li class="chapter-item expanded "><a href="../Article/Builder_Runner.html"><strong aria-hidden="true">10.6.</strong> builder_runner实现简介</a></li><li class="chapter-item expanded "><a href="../Article/Compiler_Parser.html"><strong aria-hidden="true">10.7.</strong> 词法&amp;语法分析工具介绍</a></li><li class="chapter-item expanded "><a href="../Article/WKWebview_Cookie.html"><strong aria-hidden="true">10.8.</strong> WKWebview Cookie开发及需要注意的点</a></li></ol></li><li class="chapter-item expanded "><a href="../Other/index.html"><strong aria-hidden="true">11.</strong> 其它</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Other/Concept.html"><strong aria-hidden="true">11.1.</strong> 概念/术语</a></li><li class="chapter-item expanded "><a href="../Other/Design.html"><strong aria-hidden="true">11.2.</strong> 设计相关</a></li><li class="chapter-item expanded "><a href="../Other/Blog.html"><strong aria-hidden="true">11.3.</strong> 博客搭建</a></li><li class="chapter-item expanded "><a href="../Other/MacOS.html"><strong aria-hidden="true">11.4.</strong> MacOS</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发知识库</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="javascript高级程序设计"><a class="header" href="#javascript高级程序设计">JavaScript高级程序设计</a></h1>
<p>[TOC]</p>
<h2 id="前提"><a class="header" href="#前提">前提</a></h2>
<h3 id="es标准"><a class="header" href="#es标准">ES标准</a></h3>
<p>ES5即ES3.1，于2009年12月3日正式发布。这几年基本维持了一年一个版本的节奏。</p>
<p>ECMAScript兼容是指：</p>
<blockquote>
<ol>
<li>支持ECMA-262的所有类型、值、对象、属性、函数以及程序句法和语义</li>
<li>支持Unicode字符标准</li>
</ol>
</blockquote>
<h3 id="dom"><a class="header" href="#dom">DOM</a></h3>
<p>DOM是针对HTML的应用程序编程接口。DOM产生的原因，是由于IE和Netscape在实现DHTML(Dynamic HTML)时，各持己见，实现不同，开发人员需要适配两个浏览器，就需要额外做一些工作。最终导致W3C来规划了DOM</p>
<p>DOM也是分级的，目前是分为3级：</p>
<ul>
<li>1级：由<code>DOM核心</code>和<code>DOM HTML</code>组成，DOM核心规定的是如何映射基于XML的文档结构。DOM HTML则在DOM核心的基础上添加了针对HTML的对象和方法</li>
<li>2级：新增了<code>DOOM视图</code>、<code>DOM事件</code>、<code>DOM样式</code>、<code>DOM遍历和范围</code></li>
<li>3级：支持XML 1.0规范，引入了统一方式加载和保存文档的方法，新增了验证文档的方法。</li>
</ul>
<p>DOM并不是针对JS的，很多基于XML的语言也实现了DOM，这些语言也添加了与语言相关的新方法和新接口：</p>
<ul>
<li>SVG (<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model#SVG_interfaces">DOM SVG接口</a>)</li>
<li>MathML</li>
<li>SMIL</li>
</ul>
<h3 id="bom-浏览器对象模型"><a class="header" href="#bom-浏览器对象模型">BOM (浏览器对象模型)</a></h3>
<p>使用BOM可以控制浏览器页面以外的部分。在H5之前，BOM没有标准，但H5中把很多BOM功能写入了正式规范：</p>
<ul>
<li>对cookies的支持</li>
<li>移动、缩放和关闭浏览器功能</li>
<li>提供浏览器各种信息的对象</li>
<li>……</li>
</ul>
<h3 id="script标签"><a class="header" href="#script标签">&lt;script&gt;标签</a></h3>
<p>在&lt;script&gt;标签中，除了有<code>type</code>属性外，还有几个可选属性</p>
<ul>
<li><strong>type</strong>：表明代码使用的脚本语言的内容类型，默认为<code>text/javascript</code>。这个属性是<code>language</code>的替代属性，<code>language</code>已经废弃</li>
<li><strong>src</strong>：引用的外部文件</li>
<li><strong>async</strong>：立即下载，但异步执行（页面渲染和js执行是同步的）</li>
<li><strong>defer</strong>：脚本可以延迟到文档完全解析和显示后再执行</li>
<li><strong>charset</strong>：通过src指定的字符集，很少使用</li>
<li><strong>crossorigin</strong>：配置相关请求的CORS设置</li>
<li><strong>integrity</strong>：通过对比收到的资源和指定的加密签名，来确保CDN不会提供恶意内容</li>
</ul>
<blockquote>
<p>有关async与defer的区别，详细参见：<a href="https://segmentfault.com/q/1010000000640869">defer和async的区别</a></p>
</blockquote>
<h3 id="脚本的加载及执行"><a class="header" href="#脚本的加载及执行">脚本的加载及执行</a></h3>
<ul>
<li>默认情况下，浏览器会按&lt;script&gt;出现的顺序依次解释它们，并且相互之间是串行的。</li>
<li>&lt;script&gt;标签内的代码会被从上到下解释，在&lt;script&gt;中的代码被计算完成之前，页面的其余内容不会被加载，也不会被显示。</li>
<li>如果&lt;script&gt;是引用的外部文件的代码，则在下载、解释JS代码时，会阻止页面剩余部分的加载显示。</li>
<li>如果在&lt;script&gt;中即使用了<code>src</code>引用外部js文件，又在标签体中包含了其他的JS代码，则浏览器仅会下载执行<code>src</code>指定的JS文件，而忽略标签体内嵌的JS代码。</li>
<li>过去喜欢把&lt;script&gt;放在&lt;head&gt;标签中声明，这样会导致一个问题，即页面的渲染需要等所有的JS代码下载、解释完成之后，才能开始渲染。比较好的方式是放在&lt;body&gt;标签之后。</li>
</ul>
<p>除此之外，也可以通过DOM API动态的加载脚本：</p>
<pre><code class="language-js">// 这种创建方式，默认将async属性设置为true了，也即异步方式加载的
let script = document.createElement('script');
script.src = 'demo.js';
document.head.appendChild(script);
</code></pre>
<p>​	</p>
<h2 id="js基础"><a class="header" href="#js基础">JS基础</a></h2>
<ul>
<li>大小写敏感</li>
<li>ES5中增加了严格模式，即在脚本开头添加<code>&quot;use strict&quot;</code>。严格模式是为了限制ES3中的一些不规范写法(<a href="https://www.runoob.com/js/js-strict.html">JavaScript 严格模式</a>)</li>
<li>JS可以省略分号，但应优先使用分号</li>
<li>支持<code>标签函数</code>，使用参考：<a href="https://zhuanlan.zhihu.com/p/31687266">ES6 - 标签函数</a></li>
</ul>
<h3 id="var与let区别"><a class="header" href="#var与let区别"><code>var</code>与<code>let</code>区别</a></h3>
<table><thead><tr><th>var</th><th>let</th></tr></thead><tbody>
<tr><td>声明的变量存在<code>提升</code>，会将变量声明移至作用域的顶部，并且默认赋值为<code>undefined</code></td><td>不提升</td></tr>
<tr><td>声明的作用域是函数作用域</td><td>作用域是块作用域(即在if体里声明，只会在该if体中有效)</td></tr>
<tr><td><code>var</code>声明的变量由于会提升，JS引擎会将多余的声明在作用域顶部合并</td><td><code>let</code>不会</td></tr>
<tr><td>声明变量可以省略<code>var</code>关键字，并且变量会变为全局变量</td><td>使用前必须声明</td></tr>
<tr><td>可以重复用var声明同名的变量</td><td>只能声明一次，再用<code>let</code>声明同名变量就会出错</td></tr>
<tr><td>声明为全局作用域的变量，会成为<code>window</code>对象的属性</td><td><code>let</code>不会</td></tr>
</tbody></table>
<blockquote>
<p>在实际使用中，要<code>const</code>优先，其次<code>let</code>，不使用<code>var</code></p>
</blockquote>
<h3 id="类型相关"><a class="header" href="#类型相关">类型相关</a></h3>
<ul>
<li><code>Undefined</code>类型只有一个值，就是<code>undefined</code>。声明的变量没有初始化，就是给的这个值</li>
<li><code>typeof</code>未声明的变量，也会返回&quot;undefined&quot;</li>
<li><code>Null</code>类型也只有一个值，即<code>null</code>。<code>null</code>表示一个空对象指针</li>
<li><code>typeof null</code>，会返回&quot;object&quot;，原因是<code>null</code>被认为是一个对空对象的引用 (由于上面一点原因产生)</li>
<li><code>undefined</code>值由<code>null</code>值派生出来，所以<code>null == undefined</code>会返回true</li>
<li>在if控制流语句中，会自动将其它类型的值转为Boolean类型。仅<code>&quot;&quot;</code>、<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code>少数几种情况转换为<code>false</code>，其它情况都会转为<code>true</code></li>
<li><code>console.log(0.1 + 0.2);</code>得出的结果是：<code>0.30000000000000004</code>，原因是浮点数计算中微小的舍入导致的（并非JS所独有，使用了<code>IEEE 754</code>数值表示就会存在这种问题）</li>
<li>JS中用0除任意数不会导致错误，但结果需要注意：<code>0 / 0 == NaN</code>、<code>5 / 0 == Infinity</code></li>
<li>任何涉及<code>NaN</code>的操作始终返回<code>NaN</code> （<code>NaN</code>表示<code>Not a Number</code>）</li>
<li><code>一元加操作符</code>与<code>Number()</code>函数遵循相同的转换规则。<code>+&quot;&quot;</code>为0，<code>+&quot;a&quot;</code>为<code>NaN</code>、<code>+true</code>为1</li>
<li><code>Number()</code>与<code>parseInt()</code>转换规则是不同的，<code>parseInt(&quot;10x&quot;)</code>得到的结果是<code>10</code>（<code>Number(&quot;10x&quot;)</code>返回的结果为<code>NaN</code>），原因是<code>parseInt()</code>识别字符串首字符是否是数值，如果是，则遍历到第一个不是字符串的地方，然后进行转换 (<code>paseInt()</code>专注于字符串转换)</li>
</ul>
<h4 id="symbol类型"><a class="header" href="#symbol类型"><code>Symbol</code>类型</a></h4>
<p><code>Symbol</code>类型的作用，一句话概括就是生成<code>全局唯一值</code>。详情参考：<a href="https://zhuanlan.zhihu.com/p/22652486">JS 中的 Symbol 是什么？</a></p>
<p>在如下场景都可以使用<code>Symbol</code>：</p>
<ul>
<li>枚举场景。</li>
</ul>
<pre><code class="language-js">var enumType = {
  // 具体值不被关心，但要表示唯一
  tag1: Symbol(),
  tag2: Symbol()
}
</code></pre>
<ul>
<li>作为Map的<code>key</code></li>
</ul>
<pre><code class="language-js">// 如果创建了Symbol，但没有引用它，则后续就比较难以找到它
let s1 = Symbol();
let o = {[s1]: 'foo'};
</code></pre>
<ul>
<li>用来判断一个实例是否是某对象的实例</li>
</ul>
<pre><code class="language-js">class Bar {}
let b = new Bar();

// 下面两句是等价的
console.log(b instanceof Bar);	// true
console.log(Bar[Symbol.hasInstance](b));	// true
</code></pre>
<p>除此之外，还有<code>Symbol.isConcatSpreadable</code>、<code>Symbol.iterator</code>、<code>Symbol.match</code>等内置符号，用来暴露语言内部行为，可供开发者访问、重写或模拟这些行为</p>
<h3 id="操作符"><a class="header" href="#操作符">操作符</a></h3>
<h4 id="位操作符"><a class="header" href="#位操作符">位操作符</a></h4>
<p><code>位操作符</code>即指二进制bit上的操作</p>
<p><code>位操作符</code>使用时需要注意，特殊值<code>NaN</code>和<code>Infinity</code>在位操作中都会被当成0来处理：</p>
<pre><code class="language-js">const a = Number(&quot;ff1&quot;);
const r = ~a;
console.log(r);	// 会输出-1
</code></pre>
<p>在JS中，除了<code>有符号右移</code>，用<code>&gt;&gt;</code>来表示，还存在<code>无符号右移</code>，用<code>&gt;&gt;&gt;</code>来表示。<code>无符号右移</code>在移动时，会给空位补0</p>
<p><code>逻辑非</code>操作符<code>!</code>可以应用在任意数据上，在对数据进行操作时，也是先转为布尔值，再取反。其中转为布尔值的过程，与在if控制流语句中的默认转换是一样的，即：仅<code>&quot;&quot;</code>、<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code>少数几种情况转换为<code>false</code>，其它情况都会转为<code>true</code></p>
<p><strong><code>逻辑与</code>操作符<code>&amp;&amp;</code>并不一定会返回布尔值</strong>，而是遵循如下规则：（<code>逻辑与</code>操作符与此类似）</p>
<ul>
<li>
<p>第一个操作数是对象时，则返回第二个操作数</p>
</li>
<li>
<p>第一个操作数可以隐式转为<code>true</code>时，则返回第二个操作数</p>
</li>
<li>
<p>第一个操作数隐式转换结果为<code>false</code>时，就返回第一个操作数</p>
</li>
</ul>
<p><strong><font color=red>注意：这儿的规则书上的内容讲错了！</font></strong></p>
<p>书上给的规则中说：如果有一个操作数是<code>null</code>、<code>NaN</code>、<code>undefined</code>中的一种，则返回值就是对应的<code>null</code>、<code>NaN</code>、<code>undefined</code>。但真实的测试情况不同：</p>
<pre><code class="language-js">class Bar {}
let b = new Bar();
let r = 0 &amp;&amp; NaN;

// 此时按书上的结论，应该会输出&quot;NaN&quot;，其实结果是：0
console.log(r);	// 这儿理解上，应该用上面列三条规则来看，这样理解是最简单的，而且是正确的
</code></pre>
<p>​	</p>
<h4 id="乘性操作符"><a class="header" href="#乘性操作符">乘性操作符</a></h4>
<p><code>乘性操作符</code>指的<code>乘</code>、<code>除</code>、<code>取模</code></p>
<ul>
<li>有任一操作数是<code>NaN</code>时，则返回<code>NaN</code></li>
<li><code>Infinity</code>与<code>0</code>相乘时，结果为<code>NaN</code></li>
<li><code>Infinity</code>与<code>非0</code>值相乘时，依第二个操作符的符号来决定返回<code>Infinity</code>或<code>-Infinity</code></li>
<li><code>Infinity</code>与<code>Infinity</code>相除或<code>0</code>与<code>0</code>相除，返回<code>NaN</code></li>
<li><code>非0</code>除<code>0</code>，返回<code>Infinity</code></li>
</ul>
<h4 id="其它操作符"><a class="header" href="#其它操作符">其它操作符</a></h4>
<ul>
<li>加法操作符的任意操作数是字符串时，另外一个操作数都会转为string再拼接</li>
<li><code>-0 + -0 == -0</code></li>
<li>js中除了有<code>==</code>和<code>!=</code>，还有<code>===</code>和<code>!==</code>，后面这个被称为<code>全等</code>和<code>不全等</code>。<code>全等</code>表示在操作数不转换的前提下相等才返回<code>true</code></li>
<li><code>逗号操作符</code>可以返回表达式的最后一个值。<code>let num = (5, 4, 3, 2, 1);</code>执行后的结果，num为<code>1</code></li>
</ul>
<h3 id="语句"><a class="header" href="#语句">语句</a></h3>
<ul>
<li>js中的<code>for-in</code>语句，用来枚举对象中的非符号键属性。<code>for-of</code>语句用来遍历可迭代对象的元素</li>
<li>js支持标签语句，典型场景是在嵌套循环中使用。使用参考：<a href="https://www.jianshu.com/p/13d48d4edbc4">JS 标签语句和 classList</a>中的标签语句部分</li>
<li>为了精简代码，js中支持<code>with</code>语句，但在<code>严格模式</code>下是禁用的，原因是影响性能且难以调试。使用参考：<a href="https://swordair.com/javascript-with-statement-in-depth/">深入JavaScript with语句</a></li>
</ul>
<h3 id="函数"><a class="header" href="#函数">函数</a></h3>
<ul>
<li>js中函数是一等公民，所以js可以方便的支持函数式编程</li>
<li>函数是就是对象，<code>function</code>是继承自<code>object</code>的</li>
<li>严格模式中，函数不能以<code>eval</code>及<code>arguments</code>作为名称以及参数名</li>
</ul>
<h2 id="变量作用域与内存"><a class="header" href="#变量作用域与内存">变量、作用域与内存</a></h2>
<p>JS中数据类型分<code>原始值</code>与<code>引用值</code>两种类型，除了<code>Object</code>是<code>引用值</code>外，其它都是<code>原始值</code>（包括字符串也是<code>原始值</code>）</p>
<h3 id="原始值与引用值特性"><a class="header" href="#原始值与引用值特性">原始值与引用值特性</a></h3>
<ul>
<li><code>引用值</code>可以随时增、删、改其属性和方法，但<code>原始值</code>不行。给<code>原始值</code>添加属性虽然运行时不会报错，但尝试读取该属性值仍然为<code>undefined</code></li>
<li>如果用new来初始化一个原始值，则实际上就是创建的一个对象。<code>let name = new String(&quot;Matt&quot;);</code>此时name的类型就会是<code>object</code></li>
<li>引用值再赋值时，是浅拷贝</li>
</ul>
<h3 id="作用域"><a class="header" href="#作用域">作用域</a></h3>
<ul>
<li>在浏览器环境下，全局上下文一般是<code>window</code>对象，通过var定义的全局变量或函数，都会成为<code>window</code>对象的属性和方法。(通过let和const定义的全局变量不会存储在<code>window</code>对象上)</li>
<li>在node.js环境下，全局变量是<code>global</code>对象，但在node.js环境下通过var定义的全局变量并不会成为<code>global</code>对象的属性</li>
<li>使用<code>var</code>定义的变量，会被添加到最接近的上下文中，比如<code>with</code>语句中使用<code>var</code>定义的变量，作用域就是函数上下文。但<code>let</code>的作用域是<code>块级作用域</code>，由最近的一对花括号<code>{}</code>内界定。</li>
</ul>
<p>通过<code>const</code>声明的变量，不能被重新赋值。但<code>const</code>对象的键仍然可以修改，如：<code>const o = {}; o.name = 'a';</code>。</p>
<p>如果想让整个对象都不能被修改，可以用<code>Object.freeze()</code>来初始化对象：</p>
<pre><code class="language-js">const o = Object.freeze({});
o.name = 'a';
// 不会出错，但是静默失败
console.log(o.name);	// undefined
</code></pre>
<h3 id="垃圾回收"><a class="header" href="#垃圾回收">垃圾回收</a></h3>
<p>JS是<code>自动内存管理</code>，垃圾回收程序每隔一定时间就会自动运行，确定哪些变量不会再使用，然后释放它。如何标记未使用的变量，有两种主要的策略：<code>标记清理</code>和<code>引用计数</code>。</p>
<p><code>标记清理</code>即通过给对象加标识的方式来识别对象是否有在使用，这种方案使用的较多。<code>引用计数</code>是记录每个对象的引用次数，当次数为0时释放。但<code>引用计数</code>的方案很容易导致循环引用，从而出现内存泄露。</p>
<blockquote>
<p>垃圾回收程序运行时，会对性能产生一定的影响，各种JS引擎启动回收程序的策略也不一样。</p>
<p>部分浏览器提供了主动回收内存的方式，但并不推荐主动触发。</p>
</blockquote>
<h4 id="优化内存方式"><a class="header" href="#优化内存方式">优化内存方式</a></h4>
<ul>
<li>将内存占用量保持在一个较小的值，可以让页面性能更好。开发者可以通过将不再使用的数据<strong>主动设置为null</strong>来<code>解除引用</code>，以降低内存的占用量。主动设置为null的操作对全局变量和和全局对象的属性来说是更加适合的。</li>
<li>通过<code>const</code>和<code>let</code>提升性能。因这这两个关键字声明的对象都是块级作用域，可以更早地让垃圾回收程序回收不需要的变量。</li>
<li>避免内存泄露，如尽量不要将对象存到<code>window</code>属性中，对象不要被timer或闭包长时间引用等。</li>
<li>针对<code>V8</code>引擎针对性的优化代码。比如<code>V8</code>中因为隐藏类的存在，尽量让多个实例共享相同的隐藏类可以提升性能。要做到这一点，就尽量在构造函数中提前创建好各属性，不要动态的添加/删除属性。</li>
<li>减少垃圾回收程序运行次数来提升性能。如通过自己管理<code>对象池</code>来影响回收程序的策略、频繁创建、回收的对象可以想办法使其少创建等。</li>
</ul>
<h2 id="迭代器与生成器"><a class="header" href="#迭代器与生成器">迭代器与生成器</a></h2>
<h3 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h3>
<p>任何实现<code>Iterator</code>接口的对象都可以作为迭代器使用。迭代器是仅使用游标来来记录遍历可迭代对象的历程。</p>
<p>提前终止迭代器时，也可以通过添加<code>retrun()</code>方法指定迭代器提前关闭时的执行逻辑。</p>
<h3 id="生成器-es6"><a class="header" href="#生成器-es6">生成器 (ES6)</a></h3>
<p>生成器可以让一个函数块内拥有暂停和恢复代码执行的能力。简单来说，它是对<code>协程</code>的支持。（ES7又提供了<code>async</code>、<code>await</code>来进一步简化使用）</p>
<p>生成器的声明方式为: </p>
<pre><code class="language-js">fuction *generatorFn()

class Foo {
  * generatorFn() {}
}
</code></pre>
<p>生成器特性：</p>
<ul>
<li>调用生成器函数，会生产一个<code>生成器对象</code>，并且开始是处于<code>暂停执行</code>的状态。</li>
<li>生成器对象也实现了<code>Iterator</code>接口，当调用该接口的<code>next()</code>方法后，就可以恢复执行。(同样可以通过<code>for-of</code>来遍历生成器对象)</li>
<li>生成器函数既然是一个迭代器，那么就是可以被迭代的。迭代的中间状态，通过<code>yield</code>关键字来标识。</li>
<li><code>yield</code>关键字只能在生成器函数内部使用，出现在嵌套的非生成器函数中会有语法错误。</li>
<li><code>yield *</code> 可以用来增强<code>yield</code>的行为，返回值可以返回一个可迭代对象并参与迭代。(如数组、甚至自身，可以使用<code>yield *</code> 来实现递归)</li>
</ul>
<p>使用<code>yield</code>实现输入：</p>
<pre><code class="language-js">fuction *generatorFn(v) {
  console.log(v);
  console.log(yield);
}

let g = generatorFn('foo');
g.next('bar');	// 仍然输出：foo，原因是首次调用next()只是用来执行生成器函数
g.next('baz');	// 输出：baz
</code></pre>
<h2 id="对象继承与类"><a class="header" href="#对象继承与类">对象、继承与类</a></h2>
<h3 id="对象"><a class="header" href="#对象">对象</a></h3>
<h4 id="属性"><a class="header" href="#属性">属性</a></h4>
<p>对象的属性分为两种：<code>数据属性</code>和<code>访问器属性</code></p>
<p><strong>数据属性</strong>的类型有如下几种：</p>
<ul>
<li><code>Configurable</code>: 表示属性是否可以通过delete删除并重新定义/是否可以修改它的特性</li>
<li><code>Enumerable</code>: 该属性是否可以通过<code>for-in</code>返回</li>
<li><code>Writable</code>: 属性值是否可以被修改</li>
<li><code>Value</code>: 实际的存储值</li>
</ul>
<p>如果要修改属性的默认特性，需要通过<code>Object.defineProperty()</code>来修改：</p>
<pre><code class="language-js">let person = {};
Object.defineProperty(person, &quot;name&quot;, {
  writable: false,
  value: &quot;Nicholas&quot;
});
person.name = &quot;Greg&quot;;	// 在非严格模式下不生效，严格模式下会出错
</code></pre>
<p><strong>访问器属性</strong>类型有如下几种：</p>
<ul>
<li><code>Configuable</code>: 同<code>数据属性</code>的含义</li>
<li><code>Enumerable</code>: 同<code>数据属性</code>的含义</li>
<li><code>Get</code>: 获取函数，在读取属性时调用</li>
<li><code>Set</code>: 设置函数，在写入属性时调用</li>
</ul>
<p><code>Get</code>和<code>Set</code>使用：</p>
<pre><code class="language-js">let person = {
  age_: 15	// 以 _ 结尾表示私有变量
};
Object.defineProperty(person, &quot;age&quot;, {
  get() {
    return this.age_;
  }
  set(newValue) {
  	this.age_ = newValue;
	}
});
</code></pre>
<p>属性相关其它特性:</p>
<ul>
<li>
<p><code>Object.defineProperty()</code>也可以一次设置或修改多个属性</p>
</li>
<li>
<p><code>Object.getOwnPropertyDescriptor()</code>可以读取属性，返回值是一个对象，里面包含<code>value</code>、<code>configurable</code>等值</p>
</li>
<li>
<p>对象可以通过<code>Object.assign()</code>来进行合并(自有属性和<code>Enumerable</code>为true的属性)</p>
</li>
</ul>
<h4 id="相等判断"><a class="header" href="#相等判断">相等判断</a></h4>
<p>对象间相等判定需要关注的点：</p>
<ul>
<li><code>{} === {}</code>，结果是<code>false</code></li>
<li><code>+0 === -0</code> 为 <code>true</code>；但 <code>Object.is(+0, -0)</code> 结果为<code>false</code></li>
<li><code>NaN === NaN</code> 为 <code>false</code>；<code>isNaN(NaN)</code> 为 <code>true</code>；<code>Ojbect.is(NaN, NaN)</code> 为 <code>true</code></li>
</ul>
<h4 id="es6语法糖"><a class="header" href="#es6语法糖">ES6语法糖</a></h4>
<p>支持属性简写:</p>
<pre><code class="language-js">let name = 'Matt';
let person = {
  name	// 这儿无须写成：name: name
};
console.log(person);	// 输出：{name: 'Matt'}
</code></pre>
<p>支持属性名动态生成：</p>
<pre><code class="language-js">const name = 'name';
let person = {
  [name + 'Key']: 'Matt'
}
console.log(person);	// {nameKey: 'Matt'}
</code></pre>
<p>支持方法名简写：</p>
<pre><code class="language-js">let person = {
  sayName(name) {	// 无须写成：sayName: function(name)
		// some code
  }
}
</code></pre>
<p>支持对象解构：</p>
<pre><code class="language-js">let person = {
  name: 'Matt',
  age: 27,
  job: {
  	title: 'engineer'
	}
};
let {name, age} = person;	// 或：let {name: personName} = person; 此时变量名为personName
console.log(name);	// Matt

// 对象解构支持默认值
let {name='David'} = person;

// 也支持嵌套解构
let {job: {title}} = person;
console.log(title);	// engineer

// 函数参数也可以直接使用解构语法
function printPerson(foo, {name, age}) {
  // some code
}
printPerson('1st', person);
</code></pre>
<blockquote>
<p>在解构过程中出错的话，到出错的位置就会结束，后续的解构就不再执行了</p>
</blockquote>
<h3 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h3>
<p>ES6中的类，也仅是封装了ES5.1的构造函数加原型继承的语法糖。</p>
<p>JS构造函数的使用：（与普通函数的区别就在于调用方式不同）</p>
<pre><code class="language-js">// 定义一个大写开头的函数名，内部使用this.来给属性赋值即可 (大写开头是惯例)
function Person(name, age) {
    this.name = name;
    this.age = age;	
  	// 最后无须return
}
let person = new Person('Matt', 35);	// 这儿使用new来创建对象
console.log(person);
</code></pre>
<p>对象实例中都有一个constructor属性，会指向对象：</p>
<pre><code class="language-js">console.log(person.constructor == Person);	// 返回true
</code></pre>
<p>构造函数也存在一些问题，即对象的方法在每个实例上都会被重新创建一遍</p>
<pre><code class="language-js">function Person(name, age) {
    this.name = name;
    this.sayName = function() {
      console.log(this.name);
    }
}
let person1 = new Person('Matt1');
let person2 = new Person('Matt2');
// 之所以返回false，是因为创建person1和person2时，分别创建了两个sayName函数对象
console.log(person1.sayName == person2.sayName);	// false
</code></pre>
<h3 id="原型"><a class="header" href="#原型">原型</a></h3>
<p>原型是理解JS对象非常关键的信息。</p>
<p>只要定义一个函数，就会按照特定规则为这个函数创建一个prototype属性。</p>
<pre><code class="language-js">function Person(name) {
    this.name = name
}
console.log(Person.prototype)	// Person {}
</code></pre>
<p>前面说的通过构造函数创建对象函数存在的问题，可以通过prototype属性来解决。通过prototype定义的属性和方法会被对象实例共享：</p>
<pre><code class="language-js">function Person(name, age) {
    this.name = name;
}
Person.prototype.sayName = function() {
  console.log(this.name);
}
let person1 = new Person('Matt1');
let person2 = new Person('Matt2');
console.log(person1.sayName == person2.sayName);	// true
</code></pre>
<blockquote>
<p>原型的设置也可以通过<code>字典</code>一次性设置多个属性或方法</p>
</blockquote>
<p>对象创建的实例，可以通过 <code>__proto__</code>(图中<code>[[Prototype]]</code>) 链接到原型对象。整体关系如下图所表示：</p>
<p><img src="./images/js_prototype.jpeg" alt="prototype" /></p>
<p>如果某些实现没有将属性的<code>[[ProtoType]]</code>暴露出来，则可以通过<code>isPrototypeOf()</code>方法来判断某些实例是否指向某原型：<code>Person.prototype.isPrototypeOf(person1)</code></p>
<p>在调用某个实例的属性或方法时，会产生两级搜索：</p>
<ul>
<li>先看实例是否有该属性</li>
<li>如果实例没有，则看原型是否有该属性</li>
</ul>
<p>所以如果在原型和实例中同时定义了属性，则会优先使用实例中的。</p>
<p><code>in</code>操作符，有两种用途：</p>
<ul>
<li>判断某个属性是否可以访问到：<code>&quot;name&quot; in person</code> 即判断person中是否有name属性</li>
<li>通过<code>for-in</code>枚举所有属性 </li>
</ul>
<blockquote>
<p>实例的<code>hasOwnProperty()</code>仅可以判断属性是否声明在类中，不会判断是否在原型中</p>
</blockquote>
<p>除了<code>for-in</code>可以用来枚举属性外，还有其它4种方式可以枚举，它们的枚举顺序是有差异的：</p>
<ul>
<li><code>for-in</code>、<code>Object.keys()</code> 顺序是不确定的，跟实现有关系</li>
<li><code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>、<code>Object.assign()</code> 是按升序枚举数值、字符串和符号键</li>
</ul>
<p>原型使用时需要注意：如果在实例上共享包含引用值的属性，则相当于是个静态变量，任何实例对引用值的修改都可能影响到其它实例。</p>
<h3 id="继承"><a class="header" href="#继承">继承</a></h3>
<p>继承就是通过修改原型链来实现的。子类原型不再指向子类构造函数，而是指向父类原型，以此来继承父类的属性和方法。</p>
<p>原型链的关系如下：</p>
<p><img src="./images/js_inherit.jpeg" alt="inherit" /></p>
<blockquote>
<p>实际上，所有对象都是默认是从<code>Object</code>继承的</p>
</blockquote>
<p>除了原型链继承，还有一些其它继承方式：</p>
<ul>
<li><strong>盗用构造函数</strong>：为了解决原型中<code>属性共享</code>和<code>父类构造函数无法传参</code>的问题，有一种叫的实现方案，思路就是在子类构造函数中调用父类的构造函数。</li>
<li><strong>组合继承</strong>：结合 <code>盗用构造函数</code> 和 <code>原型链继承</code></li>
<li><strong>寄生式继承</strong>：通过在原型链中添加一层包装类来实现</li>
<li><strong>寄生组合继承</strong>：被认为是最有效的类型继承方式</li>
</ul>
<p>几种继承的详细解释也可以参考：<a href="https://segmentfault.com/a/1190000037433126">ES5继承</a></p>
<h3 id="类"><a class="header" href="#类">类</a></h3>
<p>在ES5中实现继承相对都比较繁琐，而且各有各的问题。在ES6中为了解决这些问题增加了<code>class</code>关键字，不过其仍然是一层语法糖，实际实现上仍然是用的<code>原型链</code>和<code>构造函数</code>的概念。</p>
<p>判断一个class的类型时，仍然会返回<code>function</code>：</p>
<pre><code class="language-js">class Person {
}
console.log(typeof Person);	// function
</code></pre>
<p>但在使用上，JS的类与其它面向对象语言的类并没有多少差别，比如支持<code>继承</code>、支持使用<code>static</code>成员等。不过因为基于<code>原型链</code>来实现，它也有一些自己的独特的地方。比如：支持定义一个类的同时去创建一个实例、支持<code>mixin</code>等。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Note/10xWork.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../Note/XSW_ArchTech.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Note/10xWork.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../Note/XSW_ArchTech.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
