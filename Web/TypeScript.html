<!DOCTYPE HTML>
<html lang="zh-Hnas" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TypeScript - 开发知识库</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Common/index.html"><strong aria-hidden="true">1.</strong> 通用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Common/Git.html"><strong aria-hidden="true">1.1.</strong> Git</a></li><li class="chapter-item expanded "><a href="../Common/VI.html"><strong aria-hidden="true">1.2.</strong> VI</a></li><li class="chapter-item expanded "><a href="../Common/Shell.html"><strong aria-hidden="true">1.3.</strong> Shell</a></li><li class="chapter-item expanded "><a href="../Common/Markdown.html"><strong aria-hidden="true">1.4.</strong> Markdown</a></li><li class="chapter-item expanded "><a href="../Common/Regex.html"><strong aria-hidden="true">1.5.</strong> 正则表达式</a></li><li class="chapter-item expanded "><a href="../Common/Test.html"><strong aria-hidden="true">1.6.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../Common/Database.html"><strong aria-hidden="true">1.7.</strong> 数据库</a></li><li class="chapter-item expanded "><a href="../Common/Network.html"><strong aria-hidden="true">1.8.</strong> 网络</a></li><li class="chapter-item expanded "><a href="../Common/Tools.html"><strong aria-hidden="true">1.9.</strong> 常用工具</a></li><li class="chapter-item expanded "><a href="../Common/Algorithm.html"><strong aria-hidden="true">1.10.</strong> 算法</a></li><li class="chapter-item expanded "><a href="../Common/Graphics.html"><strong aria-hidden="true">1.11.</strong> 图像视频处理</a></li><li class="chapter-item expanded "><a href="../Common/System.html"><strong aria-hidden="true">1.12.</strong> 底层相关</a></li><li class="chapter-item expanded "><a href="../Common/Secure.html"><strong aria-hidden="true">1.13.</strong> 安全</a></li><li class="chapter-item expanded "><a href="../Common/Web3.html"><strong aria-hidden="true">1.14.</strong> Web3.0</a></li><li class="chapter-item expanded "><a href="../Common/Other.html"><strong aria-hidden="true">1.15.</strong> 其它通用技术</a></li></ol></li><li class="chapter-item expanded "><a href="../Software/index.html"><strong aria-hidden="true">2.</strong> 软件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Software/Architecture.html"><strong aria-hidden="true">2.1.</strong> 软件架构</a></li><li class="chapter-item expanded "><a href="../Software/SoftwareDesign.html"><strong aria-hidden="true">2.2.</strong> 软件设计</a></li><li class="chapter-item expanded "><a href="../Software/DesignPattern.html"><strong aria-hidden="true">2.3.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="../Software/Document.html"><strong aria-hidden="true">2.4.</strong> 设计文档</a></li><li class="chapter-item expanded "><a href="../Software/Practice.html"><strong aria-hidden="true">2.5.</strong> 软件实践</a></li></ol></li><li class="chapter-item expanded "><a href="../iOS/index.html"><strong aria-hidden="true">3.</strong> iOS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../iOS/Performance.html"><strong aria-hidden="true">3.1.</strong> 性能相关</a></li><li class="chapter-item expanded "><a href="../iOS/UI.html"><strong aria-hidden="true">3.2.</strong> UI相关</a></li><li class="chapter-item expanded "><a href="../iOS/Swift.html"><strong aria-hidden="true">3.3.</strong> Swift</a></li><li class="chapter-item expanded "><a href="../iOS/ObjC.html"><strong aria-hidden="true">3.4.</strong> Objective-C</a></li><li class="chapter-item expanded "><a href="../iOS/SwiftUI.html"><strong aria-hidden="true">3.5.</strong> SwiftUI</a></li><li class="chapter-item expanded "><a href="../iOS/System.html"><strong aria-hidden="true">3.6.</strong> 底层相关</a></li><li class="chapter-item expanded "><a href="../iOS/Thread.html"><strong aria-hidden="true">3.7.</strong> 多线程</a></li><li class="chapter-item expanded "><a href="../iOS/WKWebview.html"><strong aria-hidden="true">3.8.</strong> WKWebview</a></li><li class="chapter-item expanded "><a href="../iOS/Sign.html"><strong aria-hidden="true">3.9.</strong> 签名相关</a></li><li class="chapter-item expanded "><a href="../iOS/Test.html"><strong aria-hidden="true">3.10.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../iOS/Device.html"><strong aria-hidden="true">3.11.</strong> 设备及系统</a></li><li class="chapter-item expanded "><a href="../iOS/Framework/index.html"><strong aria-hidden="true">3.12.</strong> 框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../iOS/Framework/Network.html"><strong aria-hidden="true">3.12.1.</strong> 网络</a></li><li class="chapter-item expanded "><a href="../iOS/Framework/ReactiveObjC.html"><strong aria-hidden="true">3.12.2.</strong> ReactiveObjC</a></li></ol></li><li class="chapter-item expanded "><a href="../iOS/Question.html"><strong aria-hidden="true">3.13.</strong> 问题集合</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/index.html"><strong aria-hidden="true">4.</strong> Android</a></li><li class="chapter-item expanded "><a href="../Web/index.html"><strong aria-hidden="true">5.</strong> Web</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Web/HTML.html"><strong aria-hidden="true">5.1.</strong> HTML</a></li><li class="chapter-item expanded "><a href="../Web/CSS.html"><strong aria-hidden="true">5.2.</strong> CSS</a></li><li class="chapter-item expanded "><a href="../Web/JS.html"><strong aria-hidden="true">5.3.</strong> JS</a></li><li class="chapter-item expanded "><a href="../Web/TypeScript.html" class="active"><strong aria-hidden="true">5.4.</strong> TypeScript</a></li><li class="chapter-item expanded "><a href="../Web/React.html"><strong aria-hidden="true">5.5.</strong> React</a></li><li class="chapter-item expanded "><a href="../Web/Vue.html"><strong aria-hidden="true">5.6.</strong> Vue</a></li><li class="chapter-item expanded "><a href="../Web/WebAssembly.html"><strong aria-hidden="true">5.7.</strong> WebAssembly</a></li><li class="chapter-item expanded "><a href="../Web/CROS.html"><strong aria-hidden="true">5.8.</strong> 同源策略 & 跨域</a></li><li class="chapter-item expanded "><a href="../Web/Cookie.html"><strong aria-hidden="true">5.9.</strong> Cookie</a></li><li class="chapter-item expanded "><a href="../Web/DOM.html"><strong aria-hidden="true">5.10.</strong> DOM</a></li><li class="chapter-item expanded "><a href="../Web/JSEngine.html"><strong aria-hidden="true">5.11.</strong> JS引擎</a></li><li class="chapter-item expanded "><a href="../Web/Browser.html"><strong aria-hidden="true">5.12.</strong> 浏览器</a></li><li class="chapter-item expanded "><a href="../Web/Canvas.html"><strong aria-hidden="true">5.13.</strong> Canvas</a></li><li class="chapter-item expanded "><a href="../Web/MiniProgram.html"><strong aria-hidden="true">5.14.</strong> 小程序</a></li></ol></li><li class="chapter-item expanded "><a href="../Flutter/index.html"><strong aria-hidden="true">6.</strong> Flutter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Flutter/Reference.html"><strong aria-hidden="true">6.1.</strong> Flutter框架</a></li><li class="chapter-item expanded "><a href="../Flutter/Dart.html"><strong aria-hidden="true">6.2.</strong> Dart</a></li><li class="chapter-item expanded "><a href="../Flutter/Layout.html"><strong aria-hidden="true">6.3.</strong> 布局</a></li><li class="chapter-item expanded "><a href="../Flutter/Animation.html"><strong aria-hidden="true">6.4.</strong> 动画</a></li><li class="chapter-item expanded "><a href="../Flutter/Widgets.html"><strong aria-hidden="true">6.5.</strong> 组件</a></li><li class="chapter-item expanded "><a href="../Flutter/State.html"><strong aria-hidden="true">6.6.</strong> 状态管理</a></li><li class="chapter-item expanded "><a href="../Flutter/Theme.html"><strong aria-hidden="true">6.7.</strong> 主题</a></li><li class="chapter-item expanded "><a href="../Flutter/Source.html"><strong aria-hidden="true">6.8.</strong> 源码 & 原理</a></li><li class="chapter-item expanded "><a href="../Flutter/Test.html"><strong aria-hidden="true">6.9.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../Flutter/Performance.html"><strong aria-hidden="true">6.10.</strong> 性能相关</a></li><li class="chapter-item expanded "><a href="../Flutter/Web.html"><strong aria-hidden="true">6.11.</strong> Web开发</a></li><li class="chapter-item expanded "><a href="../Flutter/Desktop.html"><strong aria-hidden="true">6.12.</strong> Desktop开发</a></li></ol></li><li class="chapter-item expanded "><a href="../Server/index.html"><strong aria-hidden="true">7.</strong> 后台</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Server/Linux.html"><strong aria-hidden="true">7.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="../Server/Go.html"><strong aria-hidden="true">7.2.</strong> GO语言</a></li><li class="chapter-item expanded "><a href="../Server/NodeJS.html"><strong aria-hidden="true">7.3.</strong> Node.js</a></li><li class="chapter-item expanded "><a href="../Server/Docker.html"><strong aria-hidden="true">7.4.</strong> Docker</a></li></ol></li><li class="chapter-item expanded "><a href="../Language/index.html"><strong aria-hidden="true">8.</strong> 语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Language/Swift.html"><strong aria-hidden="true">8.1.</strong> Swift</a></li><li class="chapter-item expanded "><a href="../Language/Dart.html"><strong aria-hidden="true">8.2.</strong> Dart</a></li><li class="chapter-item expanded "><a href="../Language/CPP.html"><strong aria-hidden="true">8.3.</strong> C++</a></li><li class="chapter-item expanded "><a href="../Language/Rust.html"><strong aria-hidden="true">8.4.</strong> Rust</a></li><li class="chapter-item expanded "><a href="../Language/JS.html"><strong aria-hidden="true">8.5.</strong> JS</a></li><li class="chapter-item expanded "><a href="../Language/TypeScript.html"><strong aria-hidden="true">8.6.</strong> TypeScript</a></li><li class="chapter-item expanded "><a href="../Language/WebAssembly.html"><strong aria-hidden="true">8.7.</strong> WebAssembly</a></li><li class="chapter-item expanded "><a href="../Language/Haskell.html"><strong aria-hidden="true">8.8.</strong> Haskell</a></li><li class="chapter-item expanded "><a href="../Language/ArmAssembly.html"><strong aria-hidden="true">8.9.</strong> ARM汇编</a></li><li class="chapter-item expanded "><a href="../Language/Compiler.html"><strong aria-hidden="true">8.10.</strong> 编译器</a></li><li class="chapter-item expanded "><a href="../Language/Functional.html"><strong aria-hidden="true">8.11.</strong> 函数式编程</a></li></ol></li><li class="chapter-item expanded "><a href="../DevPlatform/index.html"><strong aria-hidden="true">9.</strong> 开发框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DevPlatform/RN/index.html"><strong aria-hidden="true">9.1.</strong> React Native</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DevPlatform/RN/Dev.html"><strong aria-hidden="true">9.1.1.</strong> RN开发</a></li></ol></li><li class="chapter-item expanded "><a href="../DevPlatform/Hippy.html"><strong aria-hidden="true">9.2.</strong> Hippy</a></li><li class="chapter-item expanded "><a href="../DevPlatform/Dynamic.html"><strong aria-hidden="true">9.3.</strong> 动态化</a></li><li class="chapter-item expanded "><a href="../DevPlatform/Sentry.html"><strong aria-hidden="true">9.4.</strong> Sentry</a></li></ol></li><li class="chapter-item expanded "><a href="../Note/index.html"><strong aria-hidden="true">10.</strong> 笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Note/10xWork.html"><strong aria-hidden="true">10.1.</strong> 10x程序员工作法</a></li><li class="chapter-item expanded "><a href="../Note/ProfessionalJS.html"><strong aria-hidden="true">10.2.</strong> JavaScript高级程序设计</a></li><li class="chapter-item expanded "><a href="../Note/XSW_ArchTech.html"><strong aria-hidden="true">10.3.</strong> 许式伟的架构课</a></li><li class="chapter-item expanded "><a href="../Note/DDD_Distilled.html"><strong aria-hidden="true">10.4.</strong> 领域驱动设计精粹</a></li><li class="chapter-item expanded "><a href="../Note/SoftwareDesign.html"><strong aria-hidden="true">10.5.</strong> 软件设计之美</a></li><li class="chapter-item expanded "><a href="../Note/DDDPractice.html"><strong aria-hidden="true">10.6.</strong> DDD实战课</a></li><li class="chapter-item expanded "><a href="../Note/DDDThoughtworks.html"><strong aria-hidden="true">10.7.</strong> 领域驱动设计综述(Thoughtworks洞见)</a></li><li class="chapter-item expanded "><a href="../Note/SoftwareArchitecture.html"><strong aria-hidden="true">10.8.</strong> 架构整洁之道</a></li><li class="chapter-item expanded "><a href="../Note/XPExplained.html"><strong aria-hidden="true">10.9.</strong> 解析极限编程</a></li><li class="chapter-item expanded "><a href="../Note/RustSwift.html"><strong aria-hidden="true">10.10.</strong> Rust / Swift对比</a></li></ol></li><li class="chapter-item expanded "><a href="../Article/READMD.html"><strong aria-hidden="true">11.</strong> 文章</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Article/SoftwareDesign.html"><strong aria-hidden="true">11.1.</strong> 浅谈软件设计</a></li><li class="chapter-item expanded "><a href="../Article/ExtremeProgramming.html"><strong aria-hidden="true">11.2.</strong> 解析极限编程</a></li><li class="chapter-item expanded "><a href="../Article/FunctionalProgramming.html"><strong aria-hidden="true">11.3.</strong> 浅谈函数式编程</a></li><li class="chapter-item expanded "><a href="../Article/DartIterableEffective.html"><strong aria-hidden="true">11.4.</strong> Dart中自定义Iterable高效操作</a></li><li class="chapter-item expanded "><a href="../Article/FlutterExperience.html"><strong aria-hidden="true">11.5.</strong> Flutter开发小结</a></li><li class="chapter-item expanded "><a href="../Article/Builder_Runner.html"><strong aria-hidden="true">11.6.</strong> builder_runner实现简介</a></li><li class="chapter-item expanded "><a href="../Article/Compiler_Parser.html"><strong aria-hidden="true">11.7.</strong> 词法&语法分析工具介绍</a></li><li class="chapter-item expanded "><a href="../Article/WKWebview_Cookie.html"><strong aria-hidden="true">11.8.</strong> WKWebview Cookie开发及需要注意的点</a></li></ol></li><li class="chapter-item expanded "><a href="../Other/index.html"><strong aria-hidden="true">12.</strong> 其它</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Other/Concept.html"><strong aria-hidden="true">12.1.</strong> 概念/术语</a></li><li class="chapter-item expanded "><a href="../Other/TechArticle.html"><strong aria-hidden="true">12.2.</strong> 技术文章概要</a></li><li class="chapter-item expanded "><a href="../Other/Design.html"><strong aria-hidden="true">12.3.</strong> 设计相关</a></li><li class="chapter-item expanded "><a href="../Other/Blog.html"><strong aria-hidden="true">12.4.</strong> 博客搭建</a></li><li class="chapter-item expanded "><a href="../Other/MacOS.html"><strong aria-hidden="true">12.5.</strong> MacOS</a></li><li class="chapter-item expanded "><a href="../Other/TechSolution.html"><strong aria-hidden="true">12.6.</strong> 业界方案</a></li><li class="chapter-item expanded "><a href="../Other/English.html"><strong aria-hidden="true">12.7.</strong> 英语</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发知识库</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="typescript"><a class="header" href="#typescript">TypeScript</a></h1>
<h3 id="资料"><a class="header" href="#资料">资料</a></h3>
<ul>
<li><a href="https://weread.qq.com/web/bookDetail/a2c321c0721cac5ea2c585f">《TypeScript入门与实战》</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1499075">VSCode使用ts-node 调试TypeScript代码</a></li>
<li><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解 TypeScript</a></li>
<li><a href="https://blog.rexskz.info/typescript-type-system-and-functional-programming.html">TypeScript 类型系统与函数式编程</a></li>
</ul>
<h3 id="特性"><a class="header" href="#特性">特性</a></h3>
<ul>
<li>是静态、弱类型语言</li>
<li>函数也是一等公民，支持函数式编程 </li>
<li>支持泛型</li>
<li>支持可选参数，通过在参数类型后加<code>?</code>。可选参数需要放在参数列表的后面</li>
<li>接口中也支持可选属性，也是通过在属性后添加<code>?</code>来表示是否</li>
<li>支持默认参数</li>
<li>支持<a href="https://www.tslang.cn/docs/handbook/advanced-types.html">交叉类型</a>和联合类型 (交叉类型合并所有成员)</li>
</ul>
<h3 id="类型相关"><a class="header" href="#类型相关">类型相关</a></h3>
<p>从大的类型上来分，有<code>原始类型</code>、<code>对象类型</code>两大类。</p>
<h4 id="类型检查"><a class="header" href="#类型检查">类型检查</a></h4>
<p>TS支持严格类型检查、非严格类型检查。通过在tsconfig.json中做如下配置即可打开严格检查模式:</p>
<pre><code class="language-json">{
    &quot;compilerOptions&quot;: {
        &quot;strict&quot;: true,
    }
}
</code></pre>
<blockquote>
<p>一般非严格类型检查，用来在迁移JS到TS时有用，平常尽可能不用。</p>
</blockquote>
<p>TS中也提供了<code>strictNullChecks</code>编译选项，来检查null和undefined是否进行了无效的赋值。</p>
<pre><code class="language-json">{
    &quot;compilerOptions&quot;: {
        &quot;strictNullChecks&quot;: true,
    }
}
</code></pre>
<h4 id="原始类型"><a class="header" href="#原始类型">原始类型</a></h4>
<ul>
<li>String类型可以方便的进行字符串的格式化：<code>const bar: string = \</code>bar, ${foo}``</li>
<li>除了有number表示数据类型，还有一个<code>bigint</code>，可以表示任意位数的大数</li>
<li>除了JS中的<code>Symbol</code>类型，TS引入了<code>unique symbol</code>，可以用来表示固定的字面量值</li>
<li>提供了void类型，表示某个值不存在。其仅在作为函数返回类型时才有意义</li>
<li>支持枚举类型，并且枚举值有不同类型(数值、字符串、异构)</li>
</ul>
<h4 id="枚举"><a class="header" href="#枚举">枚举</a></h4>
<pre><code class="language-typescript">// 值枚举，数值也默认是从0开始
enum Direction {
    Up,      // 0， 也可以显示改为1，表示从1开始。与OC的枚举一样
    Down,    // 1
    Left,    // 2
    Right,   // 3
}

// 字符串枚举
enum Direction {
    Up = 'UP',
    Down = 'DOWN',
    
    U = Up,     // 可以声明新的枚举值，与另一个值一致
    D = Down,
}

// 异构型枚举，即一个枚举中可以同时定义数值及字符串
enum Color {
    Black = 0,
    White = 'White',
    Green = 2,  // 字符串后面的数值类型，一定要指定初始值
}
</code></pre>
<p>在枚举中，还存在一种联合枚举类型。即枚举成员除了是一个常量值，还可以是一种类型：</p>
<pre><code class="language-typescript">// 前面的Direction.Up是类型，后面的是值
const up: Direction.Up = Direction.Up;

// 联合枚举成员类型是联合枚举类型的子类型，所以可以这样赋值
const direction: Direction = up;

// 当上面的Direction是联合枚举类型时，可以理解为如下：
type UnionDirectionType =
    | Direction.Up
    | Direction.Down
    | Direction.Left
    | Direction.Right;
</code></pre>
<blockquote>
<p>当枚举类型中的所有成员都是字面量枚举成员时，该枚举类型成了联合枚举类型。</p>
</blockquote>
<p>枚举在定义时，也会经常使用<code>const</code>来修饰，表示不需要相应对象信息，生成js代码时直接用枚举值进行替换即可（有点像C里的宏）</p>
<h4 id="字面量类型"><a class="header" href="#字面量类型">字面量类型</a></h4>
<p>在TS中，字面量可以作为类型使用，被称为字面量类型，每一个字面量类型都只有一个可能的值，即字面量本身。</p>
<pre><code class="language-typescript">// 定义true类型的a，其可以赋值给另外的boolean类型的变量
const a: true = true;
let b: boolean = a;

// 定义hello类型的c
const c: 'hello' = 'hello';
let d: string = c;

// 其它字面量也类似
</code></pre>
<h4 id="单元类型-unit-type"><a class="header" href="#单元类型-unit-type">单元类型 (Unit Type)</a></h4>
<p>叫作单例类型（Singleton Type），指的是仅包含一个可能值的类型。</p>
<p>如下类型都是单元类型：</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>unique symbol</li>
<li>void</li>
<li>字面量类型</li>
<li>联合枚举成员类型</li>
</ul>
<h4 id="顶端类型-top-type"><a class="header" href="#顶端类型-top-type">顶端类型 (Top Type)</a></h4>
<p>是一种通用类型，所有其它类型都是顶端类型的子类型，TS中的顶端类型：</p>
<ul>
<li>any</li>
<li>unknown</li>
</ul>
<pre><code class="language-typescript">let x: any;

// 可以将任意类型的值赋值给x
x = true;
x = 3;
x = 'hello';

// 使用上类似any，但相比any更安全。
let y: unknown;

// 与any一样
let y = true;
let y = 3;
</code></pre>
<p><code>any</code>类型可以用来跳过编译器的检查，也即调用不存在的接口也没问题。 （但尽量少用）</p>
<p>如果没有显示声明类型，且编译器无法推断时，编译器就会将其处理为any。如：<code>function f1(x) { console.log(x); }</code> （不过<code>noImplicitAny</code>编译选项可以禁用掉该特性，即必须将类型明确出来）</p>
<p><code>unknown</code>类型比any更安全，体现在如下：</p>
<ul>
<li><code>unknown</code>类型只能赋值给另外的unknown或any类型</li>
<li>在使用<code>unknown</code>前，需要将其细化为具体类型才可使用 (如果直接使用，则会编译出错)</li>
</ul>
<pre><code class="language-typescript">function f2(message: unknown) {
    // 直接使用会编译错误
    // return message.length;

    // 在使用前需要先判断其类型
    if (typeof message === 'string') {
        return message.length;
    }
}
</code></pre>
<h4 id="尾端类型-bottom-type"><a class="header" href="#尾端类型-bottom-type">尾端类型 (Bottom Type)</a></h4>
<p>是所有其它类型的子类型。尾端类型仅有一种，即<code>never</code>。也被称为0类型，或空类型。其含义表示不可能有值。</p>
<pre><code class="language-typescript">let x: never;

// 可以将x赋值给任意其它类型
let a: boolean = x;
let b: string = x;
let c: void = x;
let d: null = x;

// 反过来赋值是禁止的
x = true;   // 错误
x = 3;      // 错误
</code></pre>
<p>如下使用场景上可以使用到never:</p>
<ul>
<li>确定某个函数不可能返回值</li>
<li>可以用来帮助做类型运算 (如<code>Exclude&lt;T, U&gt;</code>的实现)</li>
</ul>
<pre><code class="language-typescript">// 如果一个普通函数，不调用return返回数据时，其实是会返回一个`undefined`的值。
function f(): never {
    throw new Error();
}

// Exclude实现
type Exclude&lt;T, U&gt; = T extends U ? never : T; 

// 即可这样来使用，最终从联合类型中去除string，而变成boolean类型
type T = Exclude&lt;boolean | string, string&gt;; // boolean
</code></pre>
<h4 id="复合类型"><a class="header" href="#复合类型">复合类型</a></h4>
<p>即可以组合多种类型在一起。在数组中使用时，该数组元素就可以存放多种类型。</p>
<p><code>const red: (string | number)[] = ['f', f, 0, 0, 0, 0];</code></p>
<h4 id="数组"><a class="header" href="#数组">数组</a></h4>
<pre><code class="language-typescript">// T[]、Array&lt;T&gt;，都可以用来表示数组类型
const a: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const b: Array&lt;number&gt; = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const red: readonly Array&lt;string | number&gt; = ['f', f, 0, 0, 0, 0];
</code></pre>
<ul>
<li>数组越界的情况下，会返回undefined值，并不会出错</li>
<li>支持readonly修饰符，表示只读数组 (也可以用<code>ReadonlyArray&lt;T&gt;</code>、<code>Readonly&lt;T&gt;</code>来实现只读数组)</li>
</ul>
<h4 id="元组-tuple"><a class="header" href="#元组-tuple">元组 (Tuple)</a></h4>
<p>在TS中，元组是数组的子类型，可以理解为是长度固定的数组。（每个元素也都有确定的类型，并且类型可以不同）</p>
<ul>
<li>元组定义方式：<code>[T0, T1, ..., Tn]</code></li>
<li>元组也可以通过<code>readonly</code>或<code>Readonly&lt;T&gt;</code>将其声明为只读的</li>
<li>通过下标来访问元素</li>
<li>支持可选元组，在类型后添加<code>?</code>即可。可选元素必须放在后面</li>
<li>支持剩余元素，即:<code>[...T[]]</code>。表示剩余的元素都是某种类型的，且不限制个数(也可以为0个)</li>
</ul>
<pre><code class="language-typescript">const score: [string, number] = ['math', 100];
const course = score[0];   // string
const grade = score[1];    // number

// 可选元素
const tuple: [boolean, string?, number?] = [true, 'yes', 1];
tuple = [true]; // 后面两个值默认为yes和1

// 剩余元素，后面可以填任意多个字符串元素
const tuple: [number, ...string[]] = [0, 'a', 'b'];

// 可以将单一类型的元组赋值给数组的
const point: [number, number] = [0, 0];
const nums: number[] = point;   // 正确的
</code></pre>
<h4 id="对象"><a class="header" href="#对象">对象</a></h4>
<h5 id="自动封箱"><a class="header" href="#自动封箱">自动封箱</a></h5>
<p>在JS中充斥着对象，并且有时会存在<code>自动封箱</code>操作，即将原始值自动自动转为对象。</p>
<pre><code class="language-typescript">// 自动封箱，将'hi'转换为String对象类型
'hi'.toUpperCase();

// 自动封箱，将3转换为Number对象类型
// 注意：这里使用了两个点符号
3..toString()
</code></pre>
<h5 id="object"><a class="header" href="#object">Object</a></h5>
<p>除了<code>undefined</code>和<code>null</code>外，其它任何值都可以赋值给Object类型。</p>
<p>包括原始值也可以赋值给Object，原因是<code>自动封箱</code>操作的原因。</p>
<p>这个对象更多是用来描述所有对象共享的属性和方法，自己写代码时，不要使用该类型定义对象。</p>
<h5 id="object-1"><a class="header" href="#object-1">object</a></h5>
<p>它用来强调某个对象表示<code>非原始类型</code>，即对象类型。不能读写该类型中的自定义属性。</p>
<pre><code class="language-typescript">const obj: object = { foo: 0 };

// 编译错误！属性'foo'不存在于类型'object'上
obj.foo;

// 但可以调用基础接口
obj.toString();
</code></pre>
<blockquote>
<p>很多类型(非原始类型)都能赋值给<code>object</code>类型，但<code>object</code>类型仅能赋值给<code>顶端类型</code>、<code>Object类型</code>、<code>空对象类型字面量{}</code></p>
<p>可以理解为遵循一种原则：子类型可以赋值给父类型，反过来不行</p>
</blockquote>
<h5 id="对象类型字面量"><a class="header" href="#对象类型字面量">对象类型字面量</a></h5>
<p>内部成员类型有：</p>
<ul>
<li>属性签名</li>
<li>调用签名</li>
<li>构造签名</li>
<li>方法签名</li>
<li>索引签名</li>
</ul>
<p>定义方式：</p>
<pre><code class="language-typescript">{
    TypeMember;
    TypeMember;     // 这儿也可以使用`,`来进行分割
    ...

    // 属性
    propertyName: Type; // 如果不写`Type`的话，表示该属性的类型是`any`的（不推荐）
    readonly propertyName: Type;    // 只读

    // 可计算属性名，需类型为字面量`string`、`number`等
    const a: 'a' = 'a';
    [a]: boolean;   // 可计算属性名，需类型为字面量`string`、`number`等

    // 可选属性，初始化时可以忽略
    b?: number;
}
</code></pre>
<h4 id="函数参数类型"><a class="header" href="#函数参数类型">函数参数类型</a></h4>
<ul>
<li>函数参数也支持<code>可选参数</code>、<code>默认参数</code>。</li>
<li>参数不能既为可选参数，又为默认参数。</li>
<li>在默认参数情况下，参数类型也支持自动推断，如果填了默认参数，并且可以被推断出来，则是可以不写类型的。</li>
<li>支持剩余参数，用来接受0个或多个参数。</li>
<li>函数返回类型，也支持编译器自动推断 (<code>void</code>类型也仅用于函数返回上)</li>
</ul>
<pre><code class="language-typescript">function add(x: number = 0, y = 0) {
    return x + y;
}

// 可选参数
function add2(x: number = 0, y?: number) {
    return x + y;
}

// 剩余参数，本质是不限个数的可选参数，其类型是数组
function f0(first, ...last: string[]) {
    // ...
}
f0('a', 'b', 'c');  // 'b'和'c'即是last
</code></pre>
<h5 id="函数类型字面量"><a class="header" href="#函数类型字面量">函数类型字面量</a></h5>
<pre><code class="language-typescript">// (params) =&gt; Type
let f: () =&gt; void;  // 即定义函数类型
let f2: (x: number) =&gt; number;  // 参数名x必须要有，返回类型也必须要有
</code></pre>
<p>函数本质也是对象，因为函数中也可以定义其它属性。</p>
<pre><code class="language-typescript">function f(x: number) {
    console.log(x);
}
f.version = '1.0';

let foo: { (x: number): void; version: string } = f;
foo(10);    // 调用函数
console.log(foo.version);   // 调用属性
</code></pre>
<h5 id="构造签名--调用签名"><a class="header" href="#构造签名--调用签名">构造签名 &amp; 调用签名</a></h5>
<p>同其它语言一样，可以通过构造函数来创建对象</p>
<pre><code class="language-typescript">const date = new Date();    // new是必须的

declare const F: {
    new (x: number): Number;  // &lt;- 构造签名
    (x: number): number;      // &lt;- 调用签名
};

// 作为普通函数调用
const a: number = F(1);

// 作为构造函数调用
const b: Number = new F(1);
</code></pre>
<h4 id="类型的高级使用"><a class="header" href="#类型的高级使用">类型的高级使用</a></h4>
<ul>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/52662645">TypeScript的一些小用法</a></p>
</li>
<li>
<p><a href="https://www.tslang.cn/docs/handbook/advanced-types.html">高级类型</a></p>
</li>
<li>
<p>Exclude&lt;T, U&gt; - 用于从类型T中去除不在U类型中的成员</p>
</li>
<li>
<p>Extract&lt;T, U&gt; - 用于从类型T中取出可分配给U类型的成员 （取并集）</p>
</li>
<li>
<p>NonNullable<T> - 用于从类型T中去除undefined和null类型</p>
</li>
<li>
<p>ReturnType<T> - 获取函数类型的返回类型</p>
</li>
<li>
<p>InstanceType<T> - 获取构造函数的实例类型</p>
</li>
</ul>
<p>类型的理解：</p>
<ul>
<li>交叉类型：在mixins的场景，应该使用交叉类型 （交叉类型，让ts的类型系统变得非常灵活和强大）</li>
<li>联合类型：</li>
</ul>
<h3 id="语法"><a class="header" href="#语法">语法</a></h3>
<h4 id="解构"><a class="header" href="#解构">解构</a></h4>
<p>支持数组和对象解构，在很多其它语言也支持类似操作。示例如下：</p>
<pre><code class="language-typescript">// 对象解构
const point = { x: 0, y: 1 };
const { x, y } = point; // 即可给x和y分别赋值为0和1
</code></pre>
<h4 id="可选运算符"><a class="header" href="#可选运算符">可选运算符</a></h4>
<p>当不确定某个对象是否为空时，并且需要调用它的属性的话，就可以通过<code>?.</code>来调用。 (Swift中的Optional)</p>
<p>除了支持属性访问，也支持函数/方法调用。方法调用的方式为：<code>fn?.()</code></p>
<h4 id="空值合并"><a class="header" href="#空值合并">空值合并</a></h4>
<p>即<code>a ?? b</code>，当a为空时，返回b，否则返回a （与Swift中的??一样）</p>
<blockquote>
<p>a为空，即a为undefined或null时</p>
</blockquote>
<h4 id="关键字"><a class="header" href="#关键字">关键字</a></h4>
<h5 id="extends"><a class="header" href="#extends">extends</a></h5>
<p>继承、类型扩展、泛型约束 （参考：<a href="https://cloud.tencent.com/developer/article/1884330">Typescript中的extends关键字</a>）</p>
<h5 id="keyof"><a class="header" href="#keyof">keyof</a></h5>
<p>返回对象属性名组成的<code>字面量联合类型</code></p>
<pre><code class="language-typescript">type Dog = { name: string; age: number;  };
type D = keyof Dog; //type D = &quot;name&quot; | &quot;age&quot;
</code></pre>
<h5 id="in"><a class="header" href="#in">in</a></h5>
<h3 id="其它语法"><a class="header" href="#其它语法">其它语法</a></h3>
<h4 id="interface"><a class="header" href="#interface">interface</a></h4>
<p>与其它语言中的interface一样，是为了对<code>行为</code>进行定义的，在swift中即称为<code>协议</code></p>
<p><a href="https://juejin.cn/post/6844904114925600776">TypeScript 中 interface 和 type 使用区别介绍</a></p>
<p>特性如下：</p>
<ul>
<li>支持可选属性、只读属性、函数类型等</li>
<li>某个接口支持继承多个接口</li>
</ul>
<pre><code class="language-typescript">interface Config {
  color?: string;   // 可选属性
  readonly x: number;   // 只读属性
}

// 函数类型
interface SearchFunc {
  (source: string, subString: string): boolean;
}
</code></pre>
<h4 id="import--import-type"><a class="header" href="#import--import-type">import &amp; import type</a></h4>
<p><a href="https://juejin.cn/post/7111203210542448671">import 和 import type的区别</a></p>
<p>import type只导入类型，而不导入值，而import可以导入类型和值。 使用import type，可以避免生成多余的js代码。</p>
<pre><code class="language-js">// type.ts
export type UnionType = string | number;
export const unionValue: UnionType = '1';


// value1.ts
import { UnionType, unionValue } from './type';

const value1: UnionType = 'value1'; // 作为类型使用
const value2: typeof unionValue = 'value2'; // 获取类型
const value3 = unionValue; // 作为值使用


// value2.ts
import type { UnionType, unionValue } from './type';

const value1: UnionType = 'value1'; // 作为类型使用
const value2: typeof unionValue = 'value2'; // 获取类型
// Error: &quot;unionValue&quot; 是使用 &quot;import type&quot; 导入的，因此不能用作值
const value3 = unionValue; // 作为值使用
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Web/JS.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../Web/React.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Web/JS.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../Web/React.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
